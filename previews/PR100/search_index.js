var documenterSearchIndex = {"docs":
[{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"EditURL = \"../../../literate/HowTo/newComponent.jl\"","category":"page"},{"location":"generated/HowTo/newComponent/#New-component:-Duration-Shift","page":"Define a new duration & jitter component","title":"New component: Duration + Shift","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"We want a new component that changes its duration and shift depending on a column in the event-design. This is somewhat already implemented in the HRF + Pupil bases","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"using UnfoldSim\nusing Unfold\nusing Random\nusing DSP\nusing CairoMakie, UnfoldMakie\n\nsfreq = 100;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newComponent/#Design","page":"Define a new duration & jitter component","title":"Design","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"Let's generate a design with two columns, shift + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"design = UnfoldSim.SingleSubjectDesign(;\n    conditions = Dict(\n        :shift => rand(100) .* sfreq / 5,\n        :duration => 20 .+ rand(100) .* sfreq / 5,\n    ),\n)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"We also need a new AbstractComponent","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"struct TimeVaryingComponent <: AbstractComponent\n    basisfunction::Any\n    maxlength::Any\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"We have to define the length of a component","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"Base.length(c::TimeVaryingComponent) = length(c.maxlength)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"While we could have put the TimeVaryingComponent.basisfunction directly into the simulate function, I thought this is a bit more modular","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"function UnfoldSim.simulate(rng, c::TimeVaryingComponent, design::AbstractDesign)\n    evts = generate_events(design)\n    return c.basisfunction(evts, c.maxlength)\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"finally, the actual function that does the shifting + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"function basis_shiftduration(evts, maxlength)\n    basis = hanning.(Int.(round.(evts.duration))) ## hanning as long as duration\n    if \"shift\" ∈ names(evts)\n        basis = pad_array.(basis, Int.(round.(.-evts.shift)), 0) ## shift by adding 0 in front\n    end\n    # we should make sure that all bases have maxlength by appending / truncating\n    difftomax = maxlength .- length.(basis)\n    if any(difftomax .< 0)\n        @warn \"basis longer than max length in at least one case. either increase maxlength or redefine function. Trying to truncate the basis\"\n        basis[difftomax.>0] = pad_array.(basis[difftomax.>0], difftomax[difftomax.>0], 0)\n        return [b[1:maxlength] for b in basis]\n    else\n        return pad_array.(basis, difftomax, 0)\n    end\nend\n\n\nerp = UnfoldSim.simulate(\n    MersenneTwister(1),\n    TimeVaryingComponent(basis_shiftduration, 50),\n    design,\n)\nplot_erpimage(hcat(erp...), sortvalues = generate_events(design).shift)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"EditURL = \"../../../literate/tutorials/simulateERP.jl\"","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"using UnfoldSim\nusing CairoMakie\nusing Random\nusing Unfold\nusing UnfoldMakie","category":"page"},{"location":"generated/tutorials/simulateERP/#ERP-Complex","page":"Simulate ERPs","title":"ERP Complex","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Here we will learn how to simulate a typical ERP complex with P100, N170, P300.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Let's grab a SingleSubjectDesign and add a continuous predictor","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"design =\n    SingleSubjectDesign(;\n        conditions = Dict(\n            :condition => [\"car\", \"face\"],\n            :continuous => range(0, 5, length = 10),\n        ),\n    ) |> x -> RepeatDesign(x, 100);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Let's make use of the prespecified basis functions, but use different formulas + parameters for each!","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p100 is unaffected by our design and has amplitude of 5","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [5]);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"n170 has a condition effect, faces are more negative than cars","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"n1 = LinearModelComponent(;\n    basis = n170(),\n    formula = @formula(0 ~ 1 + condition),\n    β = [5, 3],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p300 has a continuous effect, higher continuous values will result in larger P300's. We include both a linear and a quadratic effect of the continuous variable.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p3 = LinearModelComponent(;\n    basis = p300(),\n    formula = @formula(0 ~ 1 + continuous + continuous^2),\n    β = [5, 1, 0.2],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Now we can simply combine the components and simulate","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"components = [p1, n1, p3]\ndata, evts = simulate(\n    MersenneTwister(1),\n    design,\n    components,\n    UniformOnset(; width = 0, offset = 1000),\n    PinkNoise(),\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#Analysis","page":"Simulate ERPs","title":"Analysis","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Let's check that everything worked out well, by using Unfold","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"m = fit(\n    UnfoldModel,\n    Dict(\n        Any => (\n            @formula(0 ~ 1 + condition + spl(continuous, 4)),\n            firbasis(τ = [-0.1, 1], sfreq = 100, name = \"basis\"),\n        ),\n    ),\n    evts,\n    data,\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"first the \"pure\" beta/linear regression parameters","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"plot_erp(\n    coeftable(m);\n    axis = (\n        title = \"Estimated regression parameters\",\n        xlabel = \"Time [s]\",\n        ylabel = \"Amplitude [μV]\",\n    ),\n)","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"and now beautifully visualized as marginal betas / predicted ERPs","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"f = plot_erp(\n    effects(Dict(:condition => [\"car\", \"face\"], :continuous => 0:0.5:5), m);\n    axis = (\n        title = \"Predicted event-related potential (ERP)\",\n        xlabel = \"Time [s]\",\n        ylabel = \"Amplitude [μV]\",\n    ),\n    mapping = (:color => :continuous, linestyle = :condition, group = :continuous),\n    legend = (; valign = :top, halign = :right, tellwidth = false),\n    categorical_color = false,\n);\n\n# Workaround to separate legend and colorbar (will be fixed in a future UnfoldMakie version)\nlegend = f.content[2]\nf[:, 1] = legend\ncurrent_figure()","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"EditURL = \"../../../literate/tutorials/multisubject.jl\"","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"using UnfoldSim\nusing Unfold\nusing CairoMakie\nusing UnfoldMakie\nusing DataFrames","category":"page"},{"location":"generated/tutorials/multisubject/#Multi-subject-simulation","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Similar to the single subject case, multi-subject simulation depends on:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Design (typically a MultiSubjectDesign)\nComponents (typically a MixedModelComponent)\nOnset (any)\nNoise (any)","category":"page"},{"location":"generated/tutorials/multisubject/#Design","page":"Multi-subject simulation","title":"Design","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Our first design should be 20 subjects, with 4 items each. Any individual image is shown only either as large or small, thus we choose items_between.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"design = MultiSubjectDesign(\n    n_subjects = 20,\n    n_items = 4,\n    items_between = Dict(:condition => [\"large\", \"small\"]),\n)","category":"page"},{"location":"generated/tutorials/multisubject/#Between,-within?","page":"Multi-subject simulation","title":"Between, within?","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In the beginning, the distinction between between-items, between-subjects and within-subjects, within-items and both-between, both-within feels daunting.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We base our terminology on MixedModelsSim which uses the following definitions:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"subjects_between -> effects between subjects, e.g. young vs old\nitems_between -> effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified in subjects_between as well)\nboth_within -> effects completly crossed, e.g. word vs. scramble, where the \"original\" word is the item, and shown to all subjects","category":"page"},{"location":"generated/tutorials/multisubject/#Components","page":"Multi-subject simulation","title":"Components","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"For multi-subject, similar to the LinearModelComponent specified before, we have to define the fixed effect β, the model parameters that are applied to all subjects.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"β = [1, 2] # 1 = intercept, 2 = difference between large and small","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In addition, we have to provide random effects σs, which define the spread (and  correlation) of the subjects around the fixed effects, foreach parameter","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"σs = Dict(\n    :subject => [0.5, 1], # we have more spread in the condition-effect\n    :item => [1], # the item-variability is higher than the subject-variability\n)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"now we are ready to assemble the parts","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"signal = MixedModelComponent(;\n    basis = UnfoldSim.hanning(50),\n    formula = @formula(0 ~ 1 + condition + (1 + condition | subject) + (1 | item)),\n    β = β,\n    σs = σs,\n    contrasts = Dict(:condition => EffectsCoding()), # we highly recommend specifying your contrasts, by Default its Dummy/ReferenceCoding with alphabetically sorted levels (relying 100% on StatsModels.jl)\n)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"and simulate!","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(design, signal, NoOnset(), NoNoise(), return_epoched = true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We get data with 50 samples (our basis from above), with 4 items and 20 subjects. We get items and subjects separately because we chose no-overlap (via NoOnset) and return_epoched = true`.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"size(data)\n\nfirst(evts, 5)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Finally, let's plot the data","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"f = Figure()\n\nfor k = 1:4\n    series(\n        f[1, k],\n        data[:, k, :]',\n        solid_color = :black,\n        axis = (; limits = ((0, 50), (-5, 6))),\n    )\n    Label(f[1, k, Top()], text = \"Item:\" * evts[k, :item] * \", c:\" * evts[k, :condition])\nend\nf","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Some remarks on interpreting the plot:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"The β main-effect of small (#2 and #4) vs. large (#1 and #3) is clearly visible.\nThe variability between subjects, is the variability between the individual curves.\nThe item effect shows up e.g. that #2 vs. #4 column show different values.","category":"page"},{"location":"generated/tutorials/multisubject/#Continuous-Signals-/-Overlap","page":"Multi-subject simulation","title":"Continuous Signals / Overlap","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Let's continue our tutorial and simulate overlapping signals instead.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We replace the NoOnset with an UniformOnset with 20 to 70 samples between subsequent events.  We further remove the return_epoched, because we want to have continuous data for now.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(design, signal, UniformOnset(offset = 20, width = 50), NoNoise());\nsize(data)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"with the first dimension being continuous data, and the latter still the subjects.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"series(data', solid_color = :black)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Each line is one subject, and it looks a bit unstructured, because the event-onsets are of course random for each subject.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"note: Note\nAll subjects have the same sequence of trials, if you need to change this, specify a event_order_function in the MultiSubjectDesign.","category":"page"},{"location":"generated/tutorials/multisubject/#Analyzing-these-data-with-Unfold.jl","page":"Multi-subject simulation","title":"Analyzing these data with Unfold.jl","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We will analyze these data using the Unfold.jl toolbox. While preliminary support for deconvolution (overlap correction) for mixed models is available, here we will not make use of it, but rather apply a MixedModel to each timepoint, following the Mass-univariate approach.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(\n    design,\n    signal,\n    UniformOnset(offset = 20, width = 50),\n    NoNoise();\n    return_epoched = true,\n);\nsize(data)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"For Unfold.jl, we have to reshape the data, so that all subjects are concatenated.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data = reshape(data, size(data, 1), :)\ntimes = range(0, 1, length = size(data, 1))\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition + (1 | item) + (1 + condition | subject)),\n    evts,\n    data,\n    times,\n)\nplot_erp(coeftable(m), mapping = (; col = :group))","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"The first column shows the fixed effects, the latter the item and subject random effects as they evolve across time","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"EditURL = \"../../../literate/HowTo/newDesign.jl\"","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"using UnfoldSim\nusing StableRNGs\nusing DataFrames\nusing Parameters","category":"page"},{"location":"generated/HowTo/newDesign/#Define-a-new-Design","page":"Define a new, (imbalanced) design","title":"Define a new Design","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"A design specifies how much data is generated, and how the event-table(s) should be generated. Already implemented examples are MultiSubjectDesign and SingleSubjectDesign","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"We need 3 things for a new design: a struct<:AbstractDesign, a size and a generate function","category":"page"},{"location":"generated/HowTo/newDesign/#1)-type","page":"Define a new, (imbalanced) design","title":"1) type","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"We need a ImbalanceSubjectDesign struct. You are free to implement it as you wish, as long as the other two functions are implemented","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"@with_kw struct ImbalanceSubjectDesign <: UnfoldSim.AbstractDesign\n    nTrials::Int\n    balance::Float64 = 0.5 # default balanced\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#2)-size","page":"Define a new, (imbalanced) design","title":"2) size","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"we need a size(design::ImbalanceSubjectDesign) function to tell how many events we will have. This is used at different places, e.g. in the Default onset implementation","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"# note the trailing , to make it a Tuple\nsize(design::ImbalanceSubjectDesign) = (design.nTrials,);\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#3)-generate","page":"Define a new, (imbalanced) design","title":"3) generate","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"We need a type generate_events(design::ImbalanceSubjectDesign) function. This function should return the actual table as a DataFrame","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"function generate_events(design::ImbalanceSubjectDesign)\n    nA = Int(round.(design.nTrials .* design.balance))\n    nB = Int(round.(design.nTrials .* (1 - design.balance)))\n    @assert nA + nB ≈ design.nTrials\n    levels = vcat(repeat([\"levelA\"], nA), repeat([\"levelB\"], nB))\n    return DataFrame(Dict(:condition => levels))\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"Finally, we can test the function and see whether it returns a Design-DataFrame as we requested","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"design = ImbalanceSubjectDesign(; nTrials = 6, balance = 0.2)\ngenerate_events(design)","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"warning: Important\nIt is the users task to ensure that each run is reproducible. So if you have a random process (e.g. shuffling), be sure to   safe a RNG object in your struct and use it in your generate function.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"EditURL = \"../../../literate/HowTo/multichannel.jl\"","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"using UnfoldSim\nusing UnfoldMakie\nusing CairoMakie\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/HowTo/multichannel/#Specifying-a-design","page":"Generate multi channel data","title":"Specifying a design","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"We are using a one-level design for testing here.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"design = SingleSubjectDesign(conditions = Dict(:condA => [\"levelA\"]))","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Next we generate two simple components at two different times without any formula attached (we have a single condition anyway)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [1]);\nc2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [1]);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#The-multichannel-component","page":"Generate multi channel data","title":"The multichannel component","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"next similar to the nested design above, we can nest the component in a MultichannelComponent. We could either provide the projection marix manually, e.g.:","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1])","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"or maybe more convenient: use the pair-syntax: Headmodel=>Label which makes use of a headmodel (HaRTmuT is currently easily available in UnfoldSim)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hart = headmodel(type = \"hartmut\")\nmc = UnfoldSim.MultichannelComponent(c, hart => \"Left Postcentral Gyrus\")\nmc2 = UnfoldSim.MultichannelComponent(c2, hart => \"Right Occipital Pole\")","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nYou could also specify a noise-specific component which is applied prior to projection & summing with other components","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"finally we need to define the onsets of the signal","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"onset = UniformOnset(; width = 20, offset = 4);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#Simulation","page":"Generate multi channel data","title":"Simulation","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Now as usual we simulate data. Inspecting data shows our result is now indeed ~230 Electrodes large! Nice!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"data, events =\n    simulate(MersenneTwister(1), design, [mc, mc2], onset, PinkNoise(noiselevel = 0.05))\nsize(data)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nThe noise declared in the simulate function is added after mixing to channels, each channel receives independent noise. It is also possible to add noise to each individual component+source prior to projection. This would introduce correlated noise.","category":"page"},{"location":"generated/HowTo/multichannel/#Plotting","page":"Generate multi channel data","title":"Plotting","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Let's plot using Butterfly & Topoplot first we convert the electrodes to positions usable in TopoPlots.jl","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"pos3d = hart.electrodes[\"pos\"];\npos2d = to_positions(pos3d')\npos2d = [Point2f(p[1] + 0.5, p[2] + 0.5) for p in pos2d];\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"now plot!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"f = Figure()\ndf = DataFrame(\n    :estimate => data[:],\n    :channel => repeat(1:size(data, 1), outer = size(data, 2)),\n    :time => repeat(1:size(data, 2), inner = size(data, 1)),\n)\nplot_butterfly!(f[1, 1:2], df; positions = pos2d)\nplot_topoplot!(\n    f[2, 1],\n    df[df.time.==28, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nplot_topoplot!(\n    f[2, 2],\n    df[df.time.==48, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nf","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API / DocStrings","title":"API / DocStrings","text":"Modules = [UnfoldSim]","category":"page"},{"location":"api/#UnfoldSim.AutoRegressiveNoise","page":"API / DocStrings","title":"UnfoldSim.AutoRegressiveNoise","text":"AutoRegressiveNoise <: AbstractNoise\n\nNot implemented\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.ExponentialNoise","page":"API / DocStrings","title":"UnfoldSim.ExponentialNoise","text":"ExponentialNoise <: AbstractNoise\n\nNoise with exponential decay in AR spectrum.\n\nnoiselevel is used to scale the noise\n\nwarning: Warning\nWith the current implementation we try to get exponential decay over the whole AR spectrum, which is N-Samples long. This involves the inversion of a cholesky matrix of size NxN matrix, which will need lots of RAM for non-trivial problems.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.LinearModelComponent","page":"API / DocStrings","title":"UnfoldSim.LinearModelComponent","text":"A multiple regression component for one subject\n\nbasis: an object, if accessed, provides a 'basis-function', e.g. hanning(40), this defines the response at a single event. It will be weighted by the model-prediction\nformula: StatsModels Formula-Object  @formula 0~1+cond (left side must be 0)\nβ Vector of betas, must fit the formula\ncontrasts: Dict. Default is empty, e.g. Dict(:condA=>EffectsCoding())\n\nAll arguments can be named, in that case contrasts is optional\n\nWorks best with SingleSubjectDesign\n\nLinearModelComponent(;\n    basis=hanning(40),\n    formula=@formula(0~1+cond),\n    β = [1.,2.],\n    contrasts=Dict(:cond=>EffectsCoding())\n)\n\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.LogNormalOnset","page":"API / DocStrings","title":"UnfoldSim.LogNormalOnset","text":"@with_kw struct LogNormalOnset <: AbstractOnset\n\nLog-normal inter-event distances using the Distributions.jl truncated LogNormal distribution.\n\nBe careful with large μ and σ values, as they are on logscale. σ>8 can quickly give you out-of-memory sized signals!\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MixedModelComponent","page":"API / DocStrings","title":"UnfoldSim.MixedModelComponent","text":"A component that adds a hierarchical relation between parameters according to a LMM defined via MixedModels.jl\n\nbasis: an object, if accessed, provides a 'basis-function', e.g. hanning(40), this defines the response at a single event. It will be weighted by the model-prediction\nformula: Formula-Object in the style of MixedModels.jl e.g. @formula 0~1+cond + (1|subject) - left-handside is ignored\nβ Vector of betas, must fit the formula\nσs Dict of random effect variances, e.g. Dict(:subject=>[0.5,0.4]) or to specify correlationmatrix Dict(:subject=>[0.5,0.4,I(2,2)],...). Technically, this will be passed to MixedModels.jl create_re function, which creates the θ matrices.\ncontrasts: Dict in the style of MixedModels.jl. Default is empty.\n\nAll arguments can be named, in that case contrasts is optional\n\nWorks best with MultiSubjectDesign\n\nMixedModelComponent(;\n    basis=hanning(40),\n    formula=@formula(0~1+cond+(1+cond|subject)),\n    β = [1.,2.],\n    σs= Dict(:subject=>[0.5,0.4]),\n    contrasts=Dict(:cond=>EffectsCoding())\n)\n\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultiSubjectDesign","page":"API / DocStrings","title":"UnfoldSim.MultiSubjectDesign","text":"MultiSubjectDesign\n\nn_subjects::Int -> number of subjects\nn_items::Int -> number of items (sometimes ≈trials)\nsubjects_between = Dict{Symbol,Vector} -> effects between subjects, e.g. young vs old \nitems_between = Dict{Symbol,Vector} -> effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified also in subjects_between)\nboth_within = Dict{Symbol,Vector}\t-> effects completly crossed\nevent_order_function = x->x; # can be used to sort, or e.g. x->shuffle(MersenneTwister(42),x) - be sure to fix/update the rng accordingly!!\n\ntipp: check the resulting dataframe using generate_events(design)\n\n# declaring same condition both sub-between and item-between results in a full between subject/item design\ndesign = MultiSubjectDesign(;\n\t\tn_items = 10,\n\t\tn_subjects = 30,\n\t\tsubjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n\t\titems_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n\t\t);\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultichannelComponent","page":"API / DocStrings","title":"UnfoldSim.MultichannelComponent","text":"Wrapper for an AbstractComponent to project it to multiple target-channels via projection. optional adds noise to the source prior to projection.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.NoNoise","page":"API / DocStrings","title":"UnfoldSim.NoNoise","text":"NoNoise <: AbstractNoise\n\nReturn zeros instead of noise.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.NoOnset","page":"API / DocStrings","title":"UnfoldSim.NoOnset","text":"struct NoOnset <: AbstractOnset end\n\nIn the case that the user directly wants no overlap to be simulated (=> epoched data).\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.PinkNoise","page":"API / DocStrings","title":"UnfoldSim.PinkNoise","text":"PinkNoise <: AbstractNoise\n\nGenerate Pink Noise using the SignalAnalysis.jl implementation.\n\nnoiselevel is used to scale the noise\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RealisticNoise","page":"API / DocStrings","title":"UnfoldSim.RealisticNoise","text":"RealisticNoise <: AbstractNoise\n\nNot implemented - planned to use Artefacts.jl to provide real EEG data to add.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RedNoise","page":"API / DocStrings","title":"UnfoldSim.RedNoise","text":"RedNoise <: AbstractNoise\n\nGenerate Red Noise using the SignalAnalysis.jl implementation.\n\nnoiselevel is used to scale the noise\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RepeatDesign","page":"API / DocStrings","title":"UnfoldSim.RepeatDesign","text":"RepeatDesign{T}\n\nRepeat a design DataFrame multiple times to mimick repeatedly recorded trials.\n\ndesignOnce = MultiSubjectDesign(;\n\t\tn_items=2,\n\t\tn_subjects = 2,\n\t\tsubjects_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n\t\titems_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n\t\t);\n\ndesign = RepeatDesign(designOnce,4);\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.SingleSubjectDesign","page":"API / DocStrings","title":"UnfoldSim.SingleSubjectDesign","text":"conditions = Dict{Symbol,Vector} of conditions, e.g. Dict(:A=>[\"a_small\",\"a_big\"],:B=>[\"b_tiny\",\"b_large\"])\nevent_order_function = x->x; # can be used to sort, or x->shuffle(MersenneTwister(42),x) - be sure to fix/update the rng accordingly!!\n\nNumber of trials / rows in generate_events(design) depend on the full factorial of your conditions.\n\nTo increase the number of repetitions simply use RepeatDesign(SingleSubjectDesign(...),5)\n\nIf conditions are omitted (or set to nothing), a single trial is simulated with a column :dummy and content :dummy - this is for convenience.\n\ntipp: check the resulting dataframe using generate_events(design)\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.UniformOnset","page":"API / DocStrings","title":"UnfoldSim.UniformOnset","text":"struct UniformOnset <: AbstractOnset\n\nProvide a Uniform Distribution of the inter-event-distances. width  is the width of the uniform distribution (=> the jitter). Since the lower bound is 0, width is also the upper bound. offset is the minimal distance. The maximal distance is offset + width.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.WhiteNoise","page":"API / DocStrings","title":"UnfoldSim.WhiteNoise","text":"WhiteNoise <: WhiteNoise\nnoiselevel = 1\nimfilter = 0\n\nGenerate White Noise using randn - thus Gaussian noise. noiselevel is used to scale the noise\n\nUsing imfilter > 0 it is possible to smooth the noise using Image.imfilter.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.size-Tuple{MultiSubjectDesign}","page":"API / DocStrings","title":"Base.size","text":"Returns dimension of experiment design\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Windows.hanning-Tuple{Any, Any, Any}","page":"API / DocStrings","title":"DSP.Windows.hanning","text":"generate a hanning window\n\nduration: in s offset: in s, defines hanning peak sfreq: sampling rate in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.PuRF-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.PuRF","text":"PuRF()\n\nDefault generator for PuRF Pupil Response Function.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}","page":"API / DocStrings","title":"UnfoldSim.add_noise!","text":"add_noise!(rng, noisetype::AbstractNoise, signal)\n\nGenerate and add noise to a data matrix. Assumes that the signal can be linearized, that is, that the noise is stationary\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}","page":"API / DocStrings","title":"UnfoldSim.add_responses!","text":"add_responses!(signal, responses::Vector, e, s, tvec, erpvec)\nadd_responses!(signal, responses::Matrix, e, s, tvec, erpvec)\nadd_responses!(signal, responses::AbstractArray, e, s, tvec, erpvec)\n\nHelper function to add inplace the responses to the signal, but for both 2D (1 channel) and 3D (X channel case).\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{AbstractVector{<:AbstractVector}, Any}","page":"API / DocStrings","title":"UnfoldSim.closest_src","text":"closest_src(coords_list::AbstractVector{<:AbstractVector}, pos)\nclosest_src(coords::Vector{<:Real}, pos)\n\nTakes an array of 'm' target coordinate vector (size 3) (or vector of vectors) and a matrix (n-by-3) of all available positions, and returns an array of size 'm' containing the indices of the respective items in 'pos' that are nearest to each of the target coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{Hartmut, String}","page":"API / DocStrings","title":"UnfoldSim.closest_src","text":"closest_src(head::Hartmut,label::String)\n\nReturns src-ix of the Headmodel Hartmut which is closest to the average of the label.\n\nimportant: Important\nWe use the average in eucledean space, but the cortex is a curved surface. In most cases they will not overlap. Ideally we would calculate the average on the surface, but this is a bit more complex to do (you'd need to calculate the vertices etc.)\n\nhartmut = headmodel()\npos = closest_src(hartmut=>\"Left Middle Temporal Gyrus, posterior division\")\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.convert-NTuple{4, Any}","page":"API / DocStrings","title":"UnfoldSim.convert","text":"Obsolete - # TODO: Transfer function to Unfold.jl\n\nFunction to convert output similar to unfold (data, events)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}","page":"API / DocStrings","title":"UnfoldSim.create_continuous_signal","text":"create_continuous_signal(rng, responses, simulation)\n\nBased on the responses and simulation parameters, simulate onset latencies and add together a continuous signal.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}","page":"API / DocStrings","title":"UnfoldSim.epoch","text":"epoch(data::AbstractVector, args...; kwargs...)\nepoch(\n    data::AbstractArray{T,2},\n    events,\n    τ::Tuple{Number,Number},\n    sfreq;\n    eventtime::Symbol = :latency,\n) where {T<:Union{Missing,Number}}\n\nHelper function to epoch data.\n\nAdapted from Unfold.jl: https://github.com/unfoldtoolbox/Unfold.jl/blob/b3a21c2bb7e93d2f45ec64b0197f4663a6d7939a/src/utilities.jl#L40\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{MultiSubjectDesign}","page":"API / DocStrings","title":"UnfoldSim.generate_events","text":"generate_events(design::MultiSubjectDesign)\n\nGenerate full factorial Dataframe according to MixedModelsSim.jl 's simdat_crossed function. Note: n_items = you can think of it as trials or better, as stimuli.\n\nNote: No condition can be named dv which is used internally in MixedModelsSim / MixedModels as a dummy left-side\n\nAfterwards applies design.event_order_function`.  Could be used to duplicate trials, sort, subselect etc.\n\nFinally it sorts by :subject\n\njulia> d = MultiSubjectDesign(;nsubjects = 10,nitems=20,bothwithin= Dict(:A=>nlevels(5),:B=>nlevels(2))) julia> generateevents(d)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{RepeatDesign}","page":"API / DocStrings","title":"UnfoldSim.generate_events","text":"UnfoldSim.generate_events(design::RepeatDesign{T})\n\nIn a repeated design, iteratively calls the underlying {T} Design and concatenates. In case of MultiSubjectDesign, sorts by subject.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{SingleSubjectDesign}","page":"API / DocStrings","title":"UnfoldSim.generate_events","text":"Generates full-factorial DataFrame of design.conditions\n\nAfterwards applies design.eventorderfunction.\n\nIf conditions is nothing, a single trial is simulated with a column :dummy and content :dummy - this is for convenience.\n\njulia> d = SingleSubjectDesign(;conditions= Dict(:A=>nlevels(5),:B=>nlevels(2))) julia> generate_events(d)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hartmut_citation-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.hartmut_citation","text":"Returns citation-string for HArtMuT\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.headmodel-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.headmodel","text":"Load a headmodel, using Artifacts.jl automatically downloads the required files\n\nCurrently only type=\"hartmut\" is implemented\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hrf-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.hrf","text":"Generate a HRF kernel. \n\nTR = 1/sfreq default parameters taken from SPM\n\nCode adapted from Unfold.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.leadfield-Tuple{Hartmut}","page":"API / DocStrings","title":"UnfoldSim.leadfield","text":"Returns the leadfield\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Tuple{AbstractHeadmodel}","page":"API / DocStrings","title":"UnfoldSim.magnitude","text":"Extracts magnitude of the orientation-including leadfield.\n\nBy default uses the orientation specified in the headmodel\n\nFallback: along the third dimension using norm - the maximal projection\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Tuple{Hartmut}","page":"API / DocStrings","title":"UnfoldSim.magnitude","text":"magnitude(headmodel::Hartmut; type = \"perpendicular\") = Extract magnitude of 3-orientation-leadfield,  type (default: \"perpendicular\") => uses the provided source-point orientations - otherwise falls back to norm.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:Real","page":"API / DocStrings","title":"UnfoldSim.magnitude","text":"magnitude(lf::AbstractArray{T,3}) where {T<:Real}\n\nIf orientation is not specified, returns the maximal magnitude (norm of leadfield).\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T<:Real","page":"API / DocStrings","title":"UnfoldSim.magnitude","text":"magnitude(lf::AbstractArray{T,3}, orientation::AbstractArray{T,2}) where {T<:Real}\n\nReturn the magnitude along an orientation of the leadfield.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.maxlength-Tuple{Vector{<:AbstractComponent}}","page":"API / DocStrings","title":"UnfoldSim.maxlength","text":"maxlength(c::Vector{<:AbstractComponent}) = maximum(length.(c))\n\nmaximum of individual component lengths\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n170-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.n170","text":"n170(;sfreq=100)\n\nGenerator for Hanning window, negative (!) peak at 170ms, width 150ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n400-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.n400","text":"n400(;sfreq=100)\n\nGenerator for Hanning window, negative (!) peak at 400ms, width 400ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{AbstractComponent}","page":"API / DocStrings","title":"UnfoldSim.n_channels","text":"n_channels(c::AbstractComponent)\n\nReturn the number of channels. By default = 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{MultichannelComponent}","page":"API / DocStrings","title":"UnfoldSim.n_channels","text":"n_channels(c::MultichannelComponent)\n\nFor MultichannelComponent return the length of the projection vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{Vector{<:AbstractComponent}}","page":"API / DocStrings","title":"UnfoldSim.n_channels","text":"For a vector of MultichannelComponents, return the first but asserts all are of equal length.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.p100-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.p100","text":"p100(;sfreq=100)\n\nGenerator for Hanning window, peak at 100ms, width 100ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.p300-Tuple{}","page":"API / DocStrings","title":"UnfoldSim.p300","text":"p300(;sfreq=100)\n\nGenerator for Hanning window, peak at 300ms, width 300ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}","page":"API / DocStrings","title":"UnfoldSim.pad_array","text":"Pads array with specified value, length pad_array(arr, len, val)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}","page":"API / DocStrings","title":"UnfoldSim.predef_2x2","text":"predef_2x2(rng::AbstractRNG;kwargs...)\n\nThe most used kwargs is: return_epoched=true which returns already epoched data. If you want epoched data without overlap, specify onset=NoOnset() and return_epoched=true\n\ndesign\n\nn_items=100,\nn_subjects=1,\nconditions = Dict(:A=>[\"asmall\",\"abig\"],:B=>[\"btiny\",\"blarge\"]),\nevent_order_function = x->shuffle(deepcopy(rng),x),\n\ncomponent / signal\n\nsignalsize = 100, length of simulated hanning window\nbasis= hanning(signalsize), the actual \"function\",signalsize` is only used here\nβ = [1,-0.5,.5,+1], the parameters\nσs = Dict(:subject=>[1,0.5,0.5,0.5],:item=>[1]), - only in n_subjects>=2 case, specifies the random effects\ncontrasts = Dict(:A=>EffectsCoding(),:B=>EffectsCoding()) - effect coding by default\nformula = n_subjects==1 ? @formula(0~1+AB) : @formula(dv~1+AB+(A*B|subject)+(1|item)),\n\nnoise\n\nnoiselevel = 0.2,\nnoise = PinkNoise(;noiselevel=noiselevel),\n\nonset\n\noverlap = (0.5,0.2),\nonset=UniformOnset(;offset=signalsizeoverlap[1],width=signalsizeoverlap[2]), #put offset to 1 for no overlap. put width to 0 for no jitter\n\nCareful if you modify nitems with nsubjects = 1, n_items has to be a multiple of 4 (or your equivalent conditions factorial, e.g. all combinations length)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_eeg-Tuple{Any}","page":"API / DocStrings","title":"UnfoldSim.predef_eeg","text":"predefeeg(;kwargs...) predefeeg(rng;kwargs...) predefeeg(rng,nsubjects;kwargs...)\n\nGenerate a P1/N1/P3 complex. In case n_subjects is defined - MixedModelComponents are generated, else LinearModelComponents.\n\nThe most used kwargs is: return_epoched=true which returns already epoched data. If you want epoched data without overlap, specify onset=NoOnset() and return_epoched=true\n\nDefault params:\n\nn_repeats = 100\neventorderfunction = x->shuffle(deepcopy(rng),x # random trial order\nconditions = Dict(...),\n\ncomponent / signal\n\nsfreq = 100,\np1 = (p100(;sfreq=sfreq), @formula(0~1),[5],Dict()), # P1 amp 5, no effects\nn1 = (n170(;sfreq=sfreq), @formula(0~1+condition),[5,-3],Dict()), # N1 amp 5, dummycoded condition effect (levels \"car\", \"face\") of -3\np3 = (p300(;sfreq=sfreq), @formula(0~1+continuous),[5,1],Dict()), # P3 amp 5, continuous effect range [-5,5] with slope 1\n\nnoise\n\nnoiselevel = 0.2,\nnoise = PinkNoise(;noiselevel=noiselevel),\n\nonset\n\noverlap = (0.5,0.2), # offset + width/length of Uniform noise. put offset to 1 for no overlap. put width to 0 for no jitter\nonset=UniformOnset(;offset=sfreq0.5overlap[1],width=sfreq0.5overlap[2]), \n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}","page":"API / DocStrings","title":"UnfoldSim.simulate_and_add!","text":"simulate_and_add!(epoch_data::AbstractMatrix, c, simulation, rng)\nsimulate_and_add!(epoch_data::AbstractArray, c, simulation, rng)\n\nHelper function to call simulate_component and add it to a provided Array.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}","page":"API / DocStrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::AbstractComponent, simulation::Simulation)\n\nBy default call simulate_component with (::Abstractcomponent,::AbstractDesign) instead of the whole simulation. This allows users to provide a hook to do something completely different :)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}","page":"API / DocStrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::AbstractComponent, simulation::Simulation)\n\nGenerate a linear model design matrix, weight it by c.β and multiply the result with the given basis vector.\n\njulia> c = UnfoldSim.LinearModelComponent([0,1,1,0],@formula(0~1+cond),[1,2],Dict()) julia> design = MultiSubjectDesign(;nsubjects=2,nitems=50,itemsbetween=(;:cond=>[\"A\",\"B\"])) julia> simulatecomponent(StableRNG(1),c,design)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}","page":"API / DocStrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::MixedModelComponent, design::AbstractDesign)\n\nGenerates a MixedModel and simulates data according to c.β and c.σs.\n\nA trick is used to remove the Normal-Noise from the MixedModel which might lead to rare numerical instabilities. Practically, we upscale the σs by factor 10000, and provide a σ=0.0001. Internally this results in a normalization where the response scale is 10000 times larger than the noise.\n\nCurrently, it is not possible to use a different basis for fixed and random effects, but a code-stub exists (it is slow though).\n\nreturn_parameters (Bool,false) - can be used to return the per-event parameters used to weight the basis function. Sometimes useful to see what is simulated\n\njulia> design = MultiSubjectDesign(;nsubjects=2,nitems=50,items_between=(;:cond=>[\"A\",\"B\"])) julia> c = UnfoldSim.MixedModelComponent([0.,1,1,0],@formula(0~1+cond+(1|subject)),[1,2],Dict(:subject=>[2],),Dict()) julia> simulate(StableRNG(1),c,design)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}","page":"API / DocStrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng,c::MultichannelComponent,design::AbstractDesign)\n\nReturn the projection of a component from source to \"sensor\" space.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_noise-Tuple{Any, NoNoise, Int64}","page":"API / DocStrings","title":"UnfoldSim.simulate_noise","text":"simulate_noise(rng, t::NoNoise, n::Int)\n\nReturn zeros instead of noise.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_noise-Tuple{Any, Union{PinkNoise, RedNoise}, Int64}","page":"API / DocStrings","title":"UnfoldSim.simulate_noise","text":"simulate_noise(rng, t::Union{PinkNoise,RedNoise}, n::Int)\n\nGenerate Pink or Red Noise using the SignalAnalysis.jl implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}","page":"API / DocStrings","title":"UnfoldSim.simulate_onsets","text":"simulate_onsets(rng, onset::AbstractOnset, simulation::Simulation)\n\nCall simulate_interonset_distances to generate distances between events and then add them up to generate the actual latencies in samples.\n\nmain call from simulation\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_responses-Tuple{Any, Vector{<:AbstractComponent}, Simulation}","page":"API / DocStrings","title":"UnfoldSim.simulate_responses","text":"simulate_responses(\n    rng,\n    components::Vector{<:AbstractComponent},\n    simulation::Simulation)\n\nSimulate multiple component responses and accumulates them on a per-event basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.weight_σs-Tuple{Dict, Float64, Float64}","page":"API / DocStrings","title":"UnfoldSim.weight_σs","text":"Weights a σs Dict for MixedModels.jl by a Float64\n\nFinally sales it by σ_lmm, as a trick to simulate noise-free LMMs\n\nI anticipate a function     function weight_σs(σs::Dict,b_σs::Dict,σ_lmm::Float64) where each σs entry can be weighted individually\n\n\n\n\n\n","category":"method"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"EditURL = \"../../../literate/reference/noisetypes.jl\"","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"using UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs\nimport StatsBase.autocor","category":"page"},{"location":"generated/reference/noisetypes/#What's-the-noise?","page":"Overview: NoiseTypes","title":"What's the noise?","text":"","category":"section"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"There are several noise-types directly implemented. Here is a comparison:","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"f = Figure()\nax_sig =\n    f[1, 1:3] =\n        Axis(f; title = \"1.000 samples of noise\", xlabel = \"Time\", ylabel = \"Amplitude\")\nax_spec =\n    f[2, 1:2] = Axis(\n        f;\n        title = \"Welch Periodogram\",\n        xlabel = \"Normalized frequency\",\n        ylabel = \"log(Power)\",\n    )\nax_auto =\n    f[2, 3:4] = Axis(\n        f;\n        title = \"Autocorrelogram (every 10th lag)\",\n        xlabel = \"Lag\",\n        ylabel = \"Autocorrelation\",\n    )\nfor n in [PinkNoise RedNoise WhiteNoise NoNoise ExponentialNoise]\n\n    # generate\n    noisevec = simulate_noise(StableRNG(1), n(), 10000)\n\n    # plot 1000 samples\n    lines!(ax_sig, noisevec[1:1000]; label = string(n))\n\n    # calc spectrum\n    perio = welch_pgram(noisevec)\n\n    # plot spectrum\n    lines!(ax_spec, freq(perio), log10.(power(perio)))\n\n    lags = 0:10:500\n    autocor_vec = autocor(noisevec, lags)\n    lines!(ax_auto, lags, autocor_vec)\n\nend\nf[1, 4] = Legend(f, ax_sig, \"Noise type\", tellheight = true)\nf","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"hint: Hint\nWe recommed for smaller signals the ExponentialNoise, maybe with a removed DC offset or a HighPass filter. For long signals, this Noise requires lots of memory though. maybe Pinknoise is a better choice then.","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"EditURL = \"../../../literate/reference/basistypes.jl\"","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"using UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs","category":"page"},{"location":"generated/reference/basistypes/#Basistypes","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Basistypes","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"There are several basis types directly implemented. They can be easily used for the components.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"note: Note\nYou can use any arbitrary shape defined by yourself! We often make use of hanning(50) from the DSP.jl package.","category":"page"},{"location":"generated/reference/basistypes/#EEG","page":"Overview: Components (EEG, fMRI, Pupil)","title":"EEG","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"By default, the EEG bases assume a sampling rate of 100, which can easily be changed by e.g. p100(;sfreq=300)","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"f = Figure()\nax = f[1, 1] = Axis(f)\nfor b in [p100, n170, p300, n400]\n    lines!(ax, b(), label = string(b))\n    scatter!(ax, b(), label = string(b))\nend\naxislegend(ax, merge = true)\nf","category":"page"},{"location":"generated/reference/basistypes/#fMRI","page":"Overview: Components (EEG, fMRI, Pupil)","title":"fMRI","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"default hrf TR is 1. Get to know all your favourite shapes!","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"##--\nf = Figure()\nplotConfig = (\n    :peak => 1:3:10,\n    :post_undershoot => 10:5:30,\n    :amplitude => 2:5,\n    :shift => 0:3:10,\n    :peak_width => 0.1:0.5:1.5,\n    :post_undershoot_width => 0.1:0.5:1.5,\n)\n\nfor (ix, pl) in enumerate(plotConfig)\n    col = (ix - 1) % 3 + 1\n    row = Int(ceil(ix / 3))\n\n    ax = f[row, col] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.hrf(; TR = 0.1, (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/#Pupil","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Pupil","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"We use the simplified PuRF from Hoeks & Levelt, 1993. Note that https://www.science.org/doi/10.1126/sciadv.abi9979 show some evidence in their supplementary material, that the convolution model is not fully applicable.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"f = Figure()\nplotConfig = (:n => 5:3:15, :tmax => 0.5:0.2:1.1)\n\nfor (ix, pl) in enumerate(plotConfig)\n    ax = f[1, ix] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.PuRF(; (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"EditURL = \"../../../literate/tutorials/poweranalysis.jl\"","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"using UnfoldSim\nusing Statistics\nusing HypothesisTests\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/tutorials/poweranalysis/#Simple-Poweranalysis-Script","page":"Poweranalysis","title":"Simple Poweranalysis Script","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"For a power analysis, we will repeatedly simulate data, and check whether we can find a significant effect.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"We perform the power analysis on epoched data.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"pvals = fill(NaN, 100)\n@time for seed in eachindex(pvals)\n    # Simulate data of 30 subjects\n    data, evts = UnfoldSim.predef_2x2(\n        MersenneTwister(seed);\n        n_subjects = 20, ## 30 subjects\n        overlap = (1, 0), ## deactivate overlap\n        noiselevel = 10,  ## add more noise to make it more challenging\n        return_epoched = true, ## saves us the epoching step\n    )\n\n\n    # take the mean over a pre-specified timewindow\n    evts.y = dropdims(mean(data[40:60, :, :], dims = 1), dims = (1))[:]\n\n    # extract the two levels of condition A\n    evts_reduced = combine(groupby(evts, [:subject, :A]), :y => mean)\n    y_big = evts_reduced[evts_reduced.A.==\"a_big\", :y_mean]\n    y_small = evts_reduced[evts_reduced.A.==\"a_small\", :y_mean]\n\n    # calculate a one-sided t-test\n    pvals[seed] = pvalue(OneSampleTTest(y_big, y_small))\nend","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"let's calculate the power","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"power = mean(pvals .< 0.05) * 100","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"EditURL = \"../../../literate/reference/onsettypes.jl\"","category":"page"},{"location":"generated/reference/onsettypes/#Onset-types","page":"Overview: OnsetTypes","title":"Onset types","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The onset types determine the distances between event onsets in the continuous EEG signal. The distances are sampled from a certain probability distribution. Currently, there are two types of onset distributions implemented: UniformOnset and LogNormalOnset.","category":"page"},{"location":"generated/reference/onsettypes/#Setup","page":"Overview: OnsetTypes","title":"Setup","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"using UnfoldSim\nusing CairoMakie\nusing Random\n\n# Define a simple design and repeat it 10000.\n# This will result in 20000 events i.e. event onsets.\ndesign =\n    SingleSubjectDesign(conditions = Dict(:cond => [\"A\", \"B\"])) |>\n    x -> RepeatDesign(x, 10000);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#UniformOnset","page":"Overview: OnsetTypes","title":"UniformOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The UniformOnset is based on a uniform distribution and has two parameters: width and offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"onset_uniform = UniformOnset(; width = 50, offset = 0);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The width parameter defines the upper bound of the interval of the uniform distribution (its lower bound is 0) i.e. all values between 0 and width are equally probable.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the uniform distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let # hide\n    f = Figure() # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((50, 0), (80, 0)), \"width\"), # hide\n        (((50, 0), (50, 20)), \"offset\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for width and one for offset # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (width, offset) in combinations # hide\n            distances = UnfoldSim.simulate_interonset_distances( # hide\n                MersenneTwister(42), # hide\n                UniformOnset(; width = width, offset = offset), # hide\n                design, # hide\n            ) # hide\n\n            hist!(\n                ax,\n                distances,\n                bins = range(0, 100, step = 1),\n                label = \"($width, $offset)\",\n            ) # hide\n\n            if label == \"offset\" && offset != 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let\n    f = Figure()\n\n    # Define parameter combinations\n    parameters = [(((50, 0), (80, 0)), \"width\"), (((50, 0), (50, 20)), \"offset\")]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for width and one for offset\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (width, offset) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                UniformOnset(; width = width, offset = offset),\n                design,\n            )\n\n            hist!(ax, onsets, bins = range(0, 100, step = 1), label = \"($width, $offset)\")\n\n            if label == \"offset\" && offset != 0\n                vlines!(offset, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#LogNormalOnset","page":"Overview: OnsetTypes","title":"LogNormalOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The LogNormalOnset is based on a log-normal distribution and has four parameters: μ, σ, offset and truncate_upper.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"onset_lognormal = LogNormalOnset(; μ = 3, σ = 0.25, offset = 0, truncate_upper = nothing);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The parameters μ and σ are the location and scale parameter of the log-normal distribution. However, they are not identical to its mean and standard deviation. If a variable X is log-normally distributed then Y = ln(X) is normally distributed with mean μ and standard deviation σ[1].","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the log-normal distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The truncate_upper parameter allows to truncate the distribution at a certain sample value. Its default value is nothing, i.e. no truncation.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let # hide\n    f = Figure(size = (600, 800)) # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (μ, σ, offset, truncate_upper) in combinations # hide\n            onsets = UnfoldSim.simulate_interonset_distances( # hide\n                MersenneTwister(42), # hide\n                LogNormalOnset(; # hide\n                    μ = μ, # hide\n                    σ = σ, # hide\n                    offset = offset, # hide\n                    truncate_upper = truncate_upper, # hide\n                ), # hide\n                design, # hide\n            ) # hide\n\n            hist!( # hide\n                ax, # hide\n                onsets, # hide\n                bins = range(0, 100, step = 1), # hide\n                label = \"($μ,$σ,$offset,$truncate_upper)\", # hide\n            ) # hide\n\n            if label == \"offset\" && offset !== 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing # hide\n                vlines!(truncate_upper, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let\n    f = Figure(size = (600, 800))\n\n    # Define parameter combinations\n    parameters = [\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"),\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"),\n    ]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (μ, σ, offset, truncate_upper) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                LogNormalOnset(;\n                    μ = μ,\n                    σ = σ,\n                    offset = offset,\n                    truncate_upper = truncate_upper,\n                ),\n                design,\n            )\n\n            hist!(\n                ax,\n                onsets,\n                bins = range(0, 100, step = 1),\n                label = \"($μ,$σ,$offset,$truncate_upper)\",\n            )\n\n            if label == \"offset\" && offset !== 0\n                vlines!(offset, color = \"black\")\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing\n                vlines!(truncate_upper, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#Overlap-of-subsequent-events","page":"Overview: OnsetTypes","title":"Overlap of subsequent events","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"note: Note\nThe overlap of subsequent events can be indirectly controlled by setting the offset parameter relative to the length of the component basis.   Assuming that signal is a component e.g. LinearModelComponent,if offset > length(signal.basis) -> no overlap\nif offset < length(signal.basis) -> there might be overlap, depending on the other parameters of the onset distribution","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"[1]: Wikipedia contributors. (2023, December 5). Log-normal distribution. In Wikipedia, The Free Encyclopedia. Retrieved 12:27, December 7, 2023, from https://en.wikipedia.org/w/index.php?title=Log-normal_distribution&oldid=1188400077#","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"EditURL = \"../../../literate/reference/overview.jl\"","category":"page"},{"location":"generated/reference/overview/#Overview-of-functionality","page":"Overview: Toolbox Functions","title":"Overview of functionality","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"UnfoldSim has many modules, here we try to collect them to provide you with an overview.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"using UnfoldSim\nusing InteractiveUtils","category":"page"},{"location":"generated/reference/overview/#Design","page":"Overview: Toolbox Functions","title":"Design","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Designs define the experimental design. They can be nested, e.g. RepeatDesign(SingleSubjectDesign,10) would repeat the generated design-dataframe 10x.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractDesign)","category":"page"},{"location":"generated/reference/overview/#Component","page":"Overview: Toolbox Functions","title":"Component","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Components define a signal. Some components can be nested, e.g. LinearModelComponent|>MultichannelComponent, see the multi-channel tutorial for more information.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractComponent)","category":"page"},{"location":"generated/reference/overview/#Onsets","page":"Overview: Toolbox Functions","title":"Onsets","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Onsets define the distance between events in the continuous signal.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractOnset)","category":"page"},{"location":"generated/reference/overview/#Noise","page":"Overview: Toolbox Functions","title":"Noise","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Choose the noise you need!","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractNoise)","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"EditURL = \"../../../literate/tutorials/quickstart.jl\"","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"using UnfoldSim\nusing Random\nusing CairoMakie","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"tip: Tip\nUse subtypes(AbstractNoise) (or subtypes(AbstractComponent) etc.) to find already implemented building blocks.","category":"page"},{"location":"generated/tutorials/quickstart/#\"Experimental\"-Design","page":"Quickstart","title":"\"Experimental\" Design","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a 1 x 2 design with 20 trials. That is, one condition (condaA) with two levels.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"design =\n    SingleSubjectDesign(; conditions = Dict(:condA => [\"levelA\", \"levelB\"])) |>\n    x -> RepeatDesign(x, 10);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Component-/-Signal","page":"Quickstart","title":"Component / Signal","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a simple component and ground truth simulation formula. Akin to ERP components, we call one simulation signal a component.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nYou could easily specify multiple components by providing a vector of components, which are automatically added at the same onsets. This procedure simplifies to generate some response that is independent of simulated condition, whereas other depends on it.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"signal = LinearModelComponent(;\n    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + condA),\n    β = [1, 0.5],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Onsets-and-Noise","page":"Quickstart","title":"Onsets and Noise","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"We will start with a uniform (but overlapping, offset < length(signal.basis)) onset-distribution","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"onset = UniformOnset(; width = 20, offset = 4);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"And we will use some noise","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"noise = PinkNoise(; noiselevel = 0.2);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Combine-and-Generate","page":"Quickstart","title":"Combine & Generate","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Finally, we will simulate some data","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"data, events = simulate(MersenneTwister(1), design, signal, onset, noise);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Data is a n-sample Vector (but could be a Matrix for e.g. MultiSubjectDesign).","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Events is a DataFrame that contains a column latency with the onsets of events.","category":"page"},{"location":"generated/tutorials/quickstart/#Plot-them!","page":"Quickstart","title":"Plot them!","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"lines(data; color = \"black\")\nvlines!(events.latency; color = [\"orange\", \"teal\"][1 .+ (events.condA.==\"levelB\")])\ncurrent_figure()","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"EditURL = \"../../../literate/HowTo/repeatTrials.jl\"","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"using UnfoldSim","category":"page"},{"location":"generated/HowTo/repeatTrials/#Repeating-Design-entries","page":"Repeating a design","title":"Repeating Design entries","text":"","category":"section"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"Sometimes we want to repeat a design, that is, have multiple trials with identical values, but it is not always straight forward to implement. For instance, there is no way to easily modify MultiSubjectDesign to have multiple identical subject/item combinations, without doing awkward repetitions of condition-levels or something.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"If you struggle with this problem RepeatDesign is an easy tool for you:","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"designOnce = MultiSubjectDesign(;\n    n_items = 2,\n    n_subjects = 2,\n    subjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n    items_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n);\n\ndesign = RepeatDesign(designOnce, 4);\ngenerate_events(design)","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"As you can see, the design was simply repeated.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"note: Note\nIf you implemented your own AbstractDesign, you need to define the size function accordingly. E.g.:   Base.size(design::RepeatDesign{SingleSubjectDesign}) = size(design.design).*design.repeat","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = UnfoldSim","category":"page"},{"location":"#UnfoldSim","page":"Home","title":"UnfoldSim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for UnfoldSim.","category":"page"},{"location":"#Start-simulating-timeseries","page":"Home","title":"Start simulating timeseries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We offer some predefined signals, check them out!","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance an P1/N170/P300 complex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnfoldSim\nusing CairoMakie # plotting\n\ndata, evts = UnfoldSim.predef_eeg(; n_repeats = 1, noiselevel = 0.8)\n\nlines(data; color = \"black\")\nvlines!(evts.latency; color = [\"orange\", \"teal\"][1 .+ (evts.condition.==\"car\")])\n\ncurrent_figure()","category":"page"},{"location":"#Or-simulate-epoched-data-directly","page":"Home","title":"Or simulate epoched data directly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\ndata, evts = UnfoldSim.predef_eeg(; n_repeats = 20, noiselevel = 0.8, return_epoched = true)\nheatmap(data[:, sortperm(evts, [:condition, :continuous])])\n","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"EditURL = \"../../../literate/HowTo/predefinedData.jl\"","category":"page"},{"location":"generated/HowTo/predefinedData/#Use-existing-experimental-designs-and-onsets-in-the-simulation","page":"Use predefined design / onsets data","title":"Use existing experimental designs & onsets in the simulation","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"Let's say you want to use the events data frame (containing the levels of the experimental variables and the event onsets (latencies)) from a previous study in your simulation.","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"using UnfoldSim\nusing DataFrames\nusing Random\nusing CairoMakie # for plotting","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"From a previous study, we (somehow, e.g. by using pyMNE.jl) imported an event data frame like this:","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"my_events = DataFrame(:condition => [:A, :B, :B, :A, :A], :latency => [7, 13, 22, 35, 41])","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"To use exactly these values, we can generate a new AbstractDesign, which will always return this event dataframe","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"struct MyManualDesign <: AbstractDesign\n    my_events::Any\nend\nUnfoldSim.generate_events(d::MyManualDesign) = deepcopy(d.my_events) ## generate function which is called internally in UnfoldSim\nUnfoldSim.size(d::MyManualDesign) = size(d.my_events, 1); ## necessary function to tell what the dimensionality of the experimental design is\nnothing #hide","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"note: Note\nNote the UnfoldSim.generate_events which tells Julia to \"overload\" the generate_events function as defined in UnfoldSim.","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"Next we generate a MyManualDesign","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"mydesign = MyManualDesign(my_events);\nnothing #hide","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"We could already use this \"solo\" and simulate some data, for example:","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"signal = LinearModelComponent(;\n    basis = [1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + condition),\n    β = [1, 0.5],\n);\n\ndata, events =\n    simulate(MersenneTwister(1), mydesign, signal, UniformOnset(; width = 10, offset = 5))\nlines(data) # plotting\nvlines!(my_events.latency; linestyle = :dash)\ncurrent_figure()","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"Looks good, but the events don't match our custom onsets yet.","category":"page"},{"location":"generated/HowTo/predefinedData/#Custom-Timings","page":"Use predefined design / onsets data","title":"Custom Timings","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"Finally, we want to use our custom timings as well. For this we define a new AbstractOnset. Again, it simply returns our manually provided latencies","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"struct MyManualOnset <: AbstractOnset end\nUnfoldSim.simulate_onsets(rng, onset::MyManualOnset, simulation::Simulation) =\n    generate_events(simulation.design).latency","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"hint: Hint\nThis is a bit of a trick, it relies that MyManualOnset is always used in combination with MyManualDesign. You could of course repeat the structure from MyManualDesign also for MyManualOnset and have an explicit field in the structure containing the onsets.","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"And that's it","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"data, events = simulate(MersenneTwister(1), mydesign, signal, MyManualOnset())\nlines(data) # plotting\nvlines!(my_events.latency, linestyle = :dash)\ncurrent_figure()","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"now everything matches, lovely!","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use predefined design / onsets data","title":"Use predefined design / onsets data","text":"This page was generated using Literate.jl.","category":"page"}]
}
