var documenterSearchIndex = {"docs":
[{"location":"developer_docs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Welcome to the developer documentation! We are excited that you are interested in contributing to our package.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Feel free to submit your work in a state you are comfortable with—we genuinely appreciate every contribution! If you are interested in following best practices and learning along the way, keep reading. But don't worry, we welcome your input just as it is 🙂.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"note: Contribution guide\nIf you haven't already, please read the Contribution guide first.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Please note that the following documentation is adapted from the BestieTemplate.jl developer documentation but has been customized to fit our needs.","category":"page"},{"location":"developer_docs/#Development/GitHub-Workflow","page":"Developer documentation","title":"Development/GitHub Workflow","text":"","category":"section"},{"location":"developer_docs/#Before-you-start-coding","page":"Developer documentation","title":"Before you start coding","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Check whether there exists a GitHub issue about the topic (e.g. bug, new feature etc). If not create one with a short description of the problem or feature idea.\nDiscuss your approach with the package maintainers either in the issue or via another channel.","category":"page"},{"location":"developer_docs/#First-time-clone-and-development-version","page":"Developer documentation","title":"First time clone & development version","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"If this is the first time you work with this repository, follow the instructions below to clone the repository and create a dev version. ","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"tip: `dev` version of a Julia package\nHaving a dev (development) version of a Julia package allows you to import a local version of the package with your changes instead of the registered package version (which is static).","category":"page"},{"location":"developer_docs/#a)-If-you-have-writing-access-for-the-GitHub-repository","page":"Developer documentation","title":"a) If you have writing access for the GitHub repository","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Option 1: Clone this repository using git clone.\nOption 2 (recommended): Use the Julia dev command to create a development version of the package:\nStart a Julia session and run cd(\"/path/to/your/project\") to navigate to your project folder.\nPress ] to enter pkg mode.\nRun dev --local UnfoldSim to clone the package to ./dev/UnfoldSim and automatically add it to your Julia project environment.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"important: Important\nIf you have writing rights, whenever upstream is mentioned below, use origin instead.","category":"page"},{"location":"developer_docs/#b)-If-you-don't-have-writing-access-for-the-GitHub-repository","page":"Developer documentation","title":"b) If you don't have writing access for the GitHub repository","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Fork the UnfoldSim.jl repository.\nClone your repository (this will create a git remote called origin).\nAdd the UnfoldSim.jl repository as a remote:\ngit remote add upstream https://github.com/unfoldtoolbox/UnfoldSim.jl","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"This will ensure that you have two remotes in your git: origin and upstream. You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"tip: `dev` version without writing rights\nYou can also use the dev command on your fork. Run ]dev --local url/of/your/fork to clone the package to ./dev/UnfoldSim and automatically add it to your Julia project environment.","category":"page"},{"location":"developer_docs/#Revise.jl","page":"Developer documentation","title":"Revise.jl","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Further, we recommend to use Revise.jl: a Julia package which allows you to track source code changes in a running Julia session without need to restart it and reload the package.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"We recommend to install it in the global environment:","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"julia> # Press ]\npkg> activate\npkg> add Revise","category":"page"},{"location":"developer_docs/#Working-on-a-new-issue","page":"Developer documentation","title":"Working on a new issue","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"We try to keep a linear Git history in this repository, so it is important to keep your branches up-to-date.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Fetch from the remote and fast-forward your local main\ngit fetch upstream\ngit switch main\ngit merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\ngit switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\ngit push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the main branch of the original UnfoldSim.jl repository.","category":"page"},{"location":"developer_docs/#Branch-naming","page":"Developer documentation","title":"Branch naming","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then either create an issue first, or discuss in another channel with the maintainers.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"page"},{"location":"developer_docs/#Commit-messages","page":"Developer documentation","title":"Commit messages","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"page"},{"location":"developer_docs/#Before-creating-a-pull-request","page":"Developer documentation","title":"Before creating a pull request","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Ideally: Make sure the tests pass (see Testing).\nAdd appropriate documentation (ideally using the Docstring templates).\nIdeally: Follow the formatting rules from JuliaFormatter.jl (see Formatting).\nFetch any main updates from upstream and rebase your branch, if necessary:\ngit fetch upstream\ngit rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"important: Best practices not shackles\nWe encourage you to share your contributions in whatever state you are comfortable with. Don’t feel overwhelmed by the number of guides — think of them as helpful resources, not strict requirements. Every contribution is valuable, and we’re happy to refine things together! ","category":"page"},{"location":"developer_docs/#Formatting","page":"Developer documentation","title":"Formatting","text":"","category":"section"},{"location":"developer_docs/#JuliaFormatter.jl","page":"Developer documentation","title":"JuliaFormatter.jl","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"We use JuliaFormatter.jl for formatting and recommend you to install it in your global environment:","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"julia> # Press ]\npkg> activate\npkg> add JuliaFormatter","category":"page"},{"location":"developer_docs/#Beware-of-reviewdog","page":"Developer documentation","title":"Beware of reviewdog 🐶","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"We use the julia-format Github action to ensure that the code follows the formatting rules defined by JuliaFormatter.jl. When opening a pull request reviewdog will automatically make formatting suggestions for your code.","category":"page"},{"location":"developer_docs/#Testing","page":"Developer documentation","title":"Testing","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"julia> # press ]\npkg> activate .\npkg> test","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"tip: Running single tests\nInstead of running all tests, you can also run the test/setup.jl to load all required packages, and subsequently run single tests manually either by include(\"test/my_test.jl\") or by opening the file and running the specific test block you want to run.","category":"page"},{"location":"developer_docs/#Documentation","page":"Developer documentation","title":"Documentation","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Documentation is key to maintaining a codebase that is easy to understand and extend. Whether it is comments in the code, docstrings, or tutorials, when writing documentation,  think about your future self or the next person reading the code or using your functions.","category":"page"},{"location":"developer_docs/#Building-and-viewing-the-documentation-locally","page":"Developer documentation","title":"Building and viewing the documentation locally","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"We recommend using LiveServer.jl to build and preview the documentation locally. To simplify this process we created the docs/run_liveserver.jl script.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Please follow these steps:","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Navigate to the docs folder and activate it.\nRun using Revise (in case you decided to install it in your docs environment).\nIf this is the first time building the docs\nPress ] to enter pkg mode.\nRun pkg> dev .. to use the development version of your package.\nPress backspace to leave pkg mode.\nRun include(\"run_liveserver.jl\").\nClick on the provided link or go to http://0.0.0.0:8000/ in your browser.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"tip: Live preview of docstrings\nInstall Revise.jl in the docs environment to enable live updating of docstrings in the docs preview.","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"tip: Separate Julia session for docs preview\nWe recommend using a separate Julia session (in VSCode) to run the run_liveserver.jl script, as it continues running. This way, you can avoid \"blocking\" the REPL and run other code in the meantime.","category":"page"},{"location":"developer_docs/#Adding-a-documentation-page","page":"Developer documentation","title":"Adding a documentation page","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"We recommend to write a Literate.jl document and place it in docs/literate/FOLDER/FILENAME.jl with FOLDER being HowTo, Explanation, Tutorial or Reference (recommended reading on the 4 categories).\nLiterate.jl converts the .jl file to a .md automatically and places it in docs/src/generated/FOLDER/FILENAME.md.\nEdit make.jl with a reference to docs/src/generated/FOLDER/FILENAME.md.","category":"page"},{"location":"developer_docs/#Docstring-templates","page":"Developer documentation","title":"Docstring templates","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"The following docstring templates are mainly based on the Julia manual and Blue: a Style Guide for Julia.","category":"page"},{"location":"developer_docs/#Function-docstring-template","page":"Developer documentation","title":"Function docstring template","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"\"\"\"\n    my_function(argument1:Type1; keyword_argument3::Type3 = value3)\n    my_function(argument1::Type1, optional_argument2::Type2; keyword_argument3::Type3 = value3)\n\nOne-line description using the imperative form (\"Do this\") instead of the third person and ending with a period.\n\nIf the one-line description is not sufficient, one can also write a short paragraph with additional information.\n\n# Arguments (if needed)\n- `argument1::Type1`: Description of argument1.\n- `optional_argument2::Type2` (optional): Description of optional_argument2.\n\n# Keyword arguments (if needed)\n- `keyword_argument3::Type3 = value3`: Description of keyword_argument3.\n\n# Returns\n- `result::Type4` : Description of result.\n\n# Examples\n```julia-repl\njulia> my_function(value1, value2)\nresult1\n\njulia> my_function(value1; keyword_argument3 = value4)\nresult2\n```\n\nSee also [`my_function2`](@ref), [`my_function3`](@ref).\n\"\"\"","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"Special cases:","category":"page"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"If a function accepts many keyword arguments, only include <keyword arguments> as a placeholder in the signature and give a keyword list with descriptions in the Keyword arguments section of the docstring.\nIf a function returns more than one variable, write the Returns section in the following way:\n# Returns\n- (result1, result2)::Tuple{Type1, Type2}:\n    - Description of result1\n    - Description of result2","category":"page"},{"location":"developer_docs/#Type-docstring-template","page":"Developer documentation","title":"Type docstring template","text":"","category":"section"},{"location":"developer_docs/","page":"Developer documentation","title":"Developer documentation","text":"\"\"\"\n    MyType <: MyAbstractType\n\nOne-line desciption of my type which ends with a period.\n\nIf the one-line description is not sufficient, one can also write a short paragraph with additional information.\n\n# Fields\n- `field1::Type1`: Description of field1.\n- `optional_field2::Type2 = value2` (optional): Description of field2. If not provided, defaults to `value2`.\n\n# Examples\n```julia-repl\njulia> MyType(field1, field2)\nresult1\n```\n\nSee also [`MyType2`](@ref), [`my_function2`](@ref).\n\"\"\"","category":"page"},{"location":"installation/#Installing-Julia-and-UnfoldSim.jl","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"","category":"section"},{"location":"installation/#Installing-Julia","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"The recommended way to install julia is juliaup.","category":"page"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"TL;DR: If you don't want to read the explicit instructions, just copy the following command:","category":"page"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"Windows: winget install julia -s msstore\nMac/Linux: curl -fsSL https://install.julialang.org | sh","category":"page"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"We further recommend to use VSCode and install the Julia Extension.","category":"page"},{"location":"installation/#Installing-UnfoldSim.jl","page":"Installing Julia & UnfoldSim.jl","title":"Installing UnfoldSim.jl","text":"","category":"section"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"The following instructions are intended for Julia beginners. More advanced Julia users can jump ahead to step 3.","category":"page"},{"location":"installation/#1.-Start-an-interactive-Julia-session-(\"REPL\")","page":"Installing Julia & UnfoldSim.jl","title":"1. Start an interactive Julia session (\"REPL\")","text":"","category":"section"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"Option 1: Type julia in the command line.\nOption 2: In VSCode, press Ctrl + Shift + P to open the command palette and type in Julia: Start REPL.","category":"page"},{"location":"installation/#2.-Activate-your-project-environment","page":"Installing Julia & UnfoldSim.jl","title":"2. Activate your project environment","text":"","category":"section"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"Before installing UnfoldSim.jl make sure that you activated your project environment.","category":"page"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"Option 1: cd(\"/path/to/your/project\") and ]activate .\nOption 2: ]activate /path/to/your/project/","category":"page"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"hint: Hint\nAfter activating you should see (environment) pkg> (where environment is the name of your project folder). If you see (@v1.11) pkg> instead, you still have to activate your environment.","category":"page"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"Note that by typing ] you enter the Julia package manager. To get back to the Julia REPL, press backspace.","category":"page"},{"location":"installation/#3.-Install-the-UnfoldSim.jl-package","page":"Installing Julia & UnfoldSim.jl","title":"3. Install the UnfoldSim.jl package","text":"","category":"section"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"If you are not in the package manager anymore, type ].\nThen type add UnfoldSim.","category":"page"},{"location":"installation/","page":"Installing Julia & UnfoldSim.jl","title":"Installing Julia & UnfoldSim.jl","text":"After the installation is finished you can use using UnfoldSim in the REPL to import the package.","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"EditURL = \"../../../literate/HowTo/newComponent.jl\"","category":"page"},{"location":"generated/HowTo/newComponent/#Define-a-new-component-(with-variable-duration-and-shift)","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"We want a new component that changes its duration and shift depending on a column in the event design. This is somewhat already implemented in the HRF + Pupil bases.","category":"page"},{"location":"generated/HowTo/newComponent/#Setup","page":"Define a new component (with variable duration and shift)","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"using UnfoldSim\nusing Unfold\nusing Random\nusing DSP\nusing CairoMakie, UnfoldMakie\n\nsfreq = 100;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"</details >","category":"page"},{"location":"generated/HowTo/newComponent/#Design","page":"Define a new component (with variable duration and shift)","title":"Design","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"Let's generate a design with two columns, shift + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"design = UnfoldSim.SingleSubjectDesign(;\n    conditions = Dict(\n        :shift => rand(100) .* sfreq / 5,\n        :duration => 20 .+ rand(100) .* sfreq / 5,\n    ),\n)","category":"page"},{"location":"generated/HowTo/newComponent/#Implement-a-new-AbstractComponent","page":"Define a new component (with variable duration and shift)","title":"Implement a new AbstractComponent","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"We also need a new AbstractComponent","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"struct TimeVaryingComponent <: AbstractComponent\n    basisfunction::Any\n    maxlength::Any\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"We have to define the length of a component","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"Base.length(c::TimeVaryingComponent) = length(c.maxlength)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"While we could have put the TimeVaryingComponent.basisfunction directly into the simulate function, I thought this is a bit more modular","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"function UnfoldSim.simulate(rng, c::TimeVaryingComponent, design::AbstractDesign)\n    evts = generate_events(design)\n    return c.basisfunction(evts, c.maxlength)\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"finally, the actual function that does the shifting + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"function basis_shiftduration(evts, maxlength)\n    basis = hanning.(Int.(round.(evts.duration))) ## hanning as long as duration\n    if \"shift\" ∈ names(evts)\n        basis = pad_array.(basis, Int.(round.(.-evts.shift)), 0) ## shift by adding 0 in front\n    end\n    # we should make sure that all bases have maxlength by appending / truncating\n    difftomax = maxlength .- length.(basis)\n    if any(difftomax .< 0)\n        @warn \"basis longer than max length in at least one case. either increase maxlength or redefine function. Trying to truncate the basis\"\n        basis[difftomax.>0] = pad_array.(basis[difftomax.>0], difftomax[difftomax.>0], 0)\n        return [b[1:maxlength] for b in basis]\n    else\n        return pad_array.(basis, difftomax, 0)\n    end\nend","category":"page"},{"location":"generated/HowTo/newComponent/#Simulate-data-with-the-new-component-type","page":"Define a new component (with variable duration and shift)","title":"Simulate data with the new component type","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"erp = UnfoldSim.simulate(\n    MersenneTwister(1),\n    TimeVaryingComponent(basis_shiftduration, 50),\n    design,\n)\nplot_erpimage(hcat(erp...), sortvalues = generate_events(design).shift)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"EditURL = \"../../../literate/tutorials/simulateERP.jl\"","category":"page"},{"location":"generated/tutorials/simulateERP/#Simulate-event-related-potentials-(ERPs)","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"One subfield of EEG research focuses on so-called event-related potentials (ERPs) which are defined as brain responses time-locked to a certain event e.g. stimulus onset. The waveform of an ERP usually consists of multiple ERP components which denote the peaks and troughs of the waveform.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"ERP components are characterized (and named) by their timing relative to the event, their polarity (positive or negative) and their scalp topography. For example, the N170 describes a negative deflection which occurrs roughly 170 ms after the onset of (certain) visual stimuli. Often, researchers are interested how a component (e.g. its amplitude or timing) changes depending on certain experimental factors. For example, N170 has been shown to be related to face processing and its amplitude is modulated by whether the stimulus is a face or an object e.g. a car. (Source)","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Here we will learn how to simulate a typical ERP complex with P100, N170, P300.","category":"page"},{"location":"generated/tutorials/simulateERP/#Setup","page":"Simulate event-related potentials (ERPs)","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"# Load required packages\nusing UnfoldSim # For simulation\nusing Random # For randomization\nusing StableRNGs # To get an RNG\nusing Unfold # For analysis\nusing CairoMakie # For plotting\nusing UnfoldMakie # For plotting","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"</details >","category":"page"},{"location":"generated/tutorials/simulateERP/#Specify-the-simulation-\"ingredients\"","page":"Simulate event-related potentials (ERPs)","title":"Specify the simulation \"ingredients\"","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/#1.-Experimental-design","page":"Simulate event-related potentials (ERPs)","title":"1. Experimental design","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"We specify an experimental design with one subject in two experimental conditions including a continuous variable with 10 values. To mimic randomization in an experiment, we shuffle the trials using the event_order_function argument. To generate more trials we repeat the design 100 times which results in 2000 trials in total.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"design =\n    SingleSubjectDesign(;\n        conditions = Dict(\n            :condition => [\"car\", \"face\"],\n            :continuous => range(0, 5, length = 10),\n        ),\n        event_order_function = shuffle,\n    ) |> x -> RepeatDesign(x, 100);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"The generate_events function can be used to create an events data frame from the specified experimental design.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"events_df = generate_events(StableRNG(1), design);\nfirst(events_df, 5)","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Above you can see the first five rows extracted from the events data frame representing the experimental design. Each row corresponds to one event. The columns continuous and condition display the levels of the predictor variables for the specific event.","category":"page"},{"location":"generated/tutorials/simulateERP/#2.-Event-basis-functions-(Components)","page":"Simulate event-related potentials (ERPs)","title":"2. Event basis functions (Components)","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Next, we create a signal consisting of three different components.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"For the first component, we use the prespecified P100 base which will be unaffected by our design and has an amplitude of 5 µV.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"p1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [5]);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"For the second component, we use the prespecified N170 base with an intercept of 5 µV and a condition effect of 3 µV for the “face/car” condition i.e. faces will have a more negative signal than cars.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"n1 = LinearModelComponent(;\n    basis = n170(),\n    formula = @formula(0 ~ 1 + condition),\n    β = [5, 3],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"For the third component, we use the prespecified P300 base and include a linear and a quadratic effect of the continuous variable: the larger the value of the continuous variable, the larger the simulated potential.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"p3 = LinearModelComponent(;\n    basis = p300(),\n    formula = @formula(0 ~ 1 + continuous + continuous^2),\n    β = [5, 1, 0.2],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#3.-Inter-onset-distribution","page":"Simulate event-related potentials (ERPs)","title":"3. Inter-onset distribution","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"In the next step, we specify an inter-onset distribution, in this case, a uniform distribution with an inter-event distance of exactly 200 samples.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"onset = UniformOnset(; width = 0, offset = 200);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#4.-Noise-specification","page":"Simulate event-related potentials (ERPs)","title":"4. Noise specification","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"As the last ingredient, we specify the noise, in this case, Pink noise.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"noise = PinkNoise(; noiselevel = 2);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#Simulate-data","page":"Simulate event-related potentials (ERPs)","title":"Simulate data","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Finally, we combine all the ingredients and simulate data. To make the simulation reproducible, one can specify a random generator.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"# Combine the components in a vector\ncomponents = [p1, n1, p3]\n\n# Simulate data\neeg_data, events_df = simulate(StableRNG(1), design, components, onset, noise);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"To inspect the simulated data we will visualize the first 1400 samples.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"<details>\n<summary>Click to show the code for the figure below</summary>","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"f = Figure(size = (1000, 400))\nax = Axis(\n    f[1, 1],\n    title = \"Simulated EEG data\",\n    titlesize = 18,\n    xlabel = \"Time [samples]\",\n    ylabel = \"Amplitude [µV]\",\n    xlabelsize = 16,\n    ylabelsize = 16,\n    xgridvisible = false,\n    ygridvisible = false,\n)\n\nn_samples = 1400\nlines!(eeg_data[1:n_samples]; color = \"black\")\nv_lines = [\n    vlines!(\n        [r[\"latency\"]];\n        color = [\"orange\", \"teal\"][1+(r[\"condition\"]==\"car\")],\n        label = r[\"condition\"],\n    ) for r in\n    filter(:latency => x -> x < n_samples, events_df)[:, [\"latency\", \"condition\"]] |>\n    eachrow\n]\nxlims!(ax, 0, n_samples)\naxislegend(\"Event onset\"; unique = true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"</details >","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"current_figure()","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"The vertical lines denote the event onsets and their colour represents the respective condition i.e. car or face.","category":"page"},{"location":"generated/tutorials/simulateERP/#Validate-the-simulation-results","page":"Simulate event-related potentials (ERPs)","title":"Validate the simulation results","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"To validate the simulation results, we use the Unfold.jl package to fit an Unfold regression model to the simulated data and examine the estimated regression parameters and marginal effects. For the formula, we include a categorical predictor for condition and a non-linear predictor (based on splines) for continuous.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"m = fit(\n    UnfoldModel,\n    [\n        Any => (\n            @formula(0 ~ 1 + condition + spl(continuous, 4)),\n            firbasis(τ = [-0.1, 1], sfreq = 100, name = \"basis\"),\n        ),\n    ],\n    events_df,\n    eeg_data,\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"To inspect the modelling results we will visualize the model coefficient estimates together with the estimated marginal effects i.e. the predicted ERPs.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"<details>\n<summary>Click to show the code for the figure below</summary>","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"# Create a data frame with the model coefficients and extract the coefficient names\ncoefs = coeftable(m)\ncoefnames = unique(coefs.coefname)\n\nf2 = Figure(size = (1000, 400))\nga = f2[1, 1] = GridLayout()\ngb = f2[1, 2] = GridLayout()\n\n# Plot A: Estimated regression parameters\nax_A = Axis(\n    ga[1, 1],\n    title = \"Estimated regression parameters\",\n    titlegap = 12,\n    xlabel = \"Time [s]\",\n    ylabel = \"Amplitude [μV]\",\n    xlabelsize = 16,\n    ylabelsize = 16,\n    xgridvisible = false,\n    ygridvisible = false,\n)\n\nfor coef in coefnames\n    estimate = filter(:coefname => ==(coef), coefs)\n\n    lines!(ax_A, estimate.time, estimate.estimate, label = coef)\nend\naxislegend(\"Coefficient\", framevisible = false)\nhidespines!(ax_A, :t, :r)\n\n# Plot B: Marginal effects\nplot_B = plot_erp!(\n    gb,\n    effects(Dict(:condition => [\"car\", \"face\"], :continuous => 0:0.5:5), m);\n    mapping = (; color = :continuous, linestyle = :condition, group = :continuous),\n    legend = (; valign = :top, halign = :right),\n    axis = (\n        title = \"Marginal effects\",\n        titlegap = 12,\n        xlabel = \"Time [s]\",\n        ylabel = \"Amplitude [μV]\",\n        xlabelsize = 16,\n        ylabelsize = 16,\n        xgridvisible = false,\n        ygridvisible = false,\n    ),\n)\n\n# Add letter labels to the plots\n# Adapted from: https://docs.makie.org/stable/tutorials/layout-tutorial/\nfor (label, layout) in zip([\"A\", \"B\"], [ga, gb])\n    Label(\n        layout[1, 1, TopLeft()],\n        label,\n        fontsize = 26,\n        font = :bold,\n        padding = (0, 5, 5, 0),\n        halign = :right,\n    )\nend","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"</details >","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"current_figure()","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"In subplot A, one can see the model coefficient estimates and as intended the first component is unaffected by the experimental design, there is a condition effect in the second component and an effect of the continuous variable on the third component. The relation between the levels of the continuous variable and the scaling of the third component is even clearer visible in subplot B which depicts the estimated marginal effects of the predictors which are obtained by evaluating the estimated function at specific values of the continuous variable.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"As shown in this example, UnfoldSim.jl and Unfold.jl can be easily combined to investigate the effects of certain features, e.g. the type of noise or its intensity on the analysis result and thereby assess the robustness of the analysis.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"EditURL = \"../../../literate/tutorials/multisubject.jl\"","category":"page"},{"location":"generated/tutorials/multisubject/#Multi-subject-simulation","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In this tutorial, you will learn how to simulate data for multiple subjects. In particular, you will learn how to specify fixed and random effects and what their influence on the simulated data looks like.","category":"page"},{"location":"generated/tutorials/multisubject/#Setup","page":"Multi-subject simulation","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"# Load required packages\nusing UnfoldSim\nusing Unfold\nusing CairoMakie\nusing UnfoldMakie\nusing DataFrames","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"</details >\n<br />","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Similar to the single subject case, multi-subject simulation depends on:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Design (typically a MultiSubjectDesign)\nComponents (typically a MixedModelComponent)\nOnset (any)\nNoise (any)","category":"page"},{"location":"generated/tutorials/multisubject/#Design","page":"Multi-subject simulation","title":"Design","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Our first design should be 20 subjects, with 4 items each. Any individual image is shown only either as large or small, thus we choose items_between.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"design = MultiSubjectDesign(\n    n_subjects = 20,\n    n_items = 4,\n    items_between = Dict(:condition => [\"large\", \"small\"]),\n)","category":"page"},{"location":"generated/tutorials/multisubject/#Between,-within?","page":"Multi-subject simulation","title":"Between, within?","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In the beginning, the distinction between between-items, between-subjects and within-subjects, within-items and both-between, both-within feels daunting.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We base our terminology on MixedModelsSim which uses the following definitions:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"subjects_between -> effects between subjects, e.g. young vs old\nitems_between -> effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified in subjects_between as well)\nboth_within -> effects completly crossed, e.g. word vs. scramble, where the \"original\" word is the item, and shown to all subjects","category":"page"},{"location":"generated/tutorials/multisubject/#Components","page":"Multi-subject simulation","title":"Components","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"For multi-subject, similar to the LinearModelComponent specified before, we have to define the fixed effect β, the model parameters that are applied to all subjects.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"β = [1, 2] # 1 = intercept, 2 = difference between large and small","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In addition, we have to provide random effects σs, which define the spread (and  correlation) of the subjects around the fixed effects, foreach parameter","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"σs = Dict(\n    :subject => [0.5, 1], # we have more spread in the condition-effect\n    :item => [1], # the item-variability is higher than the subject-variability\n)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"now we are ready to assemble the parts","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"signal = MixedModelComponent(;\n    basis = UnfoldSim.hanning(50),\n    formula = @formula(0 ~ 1 + condition + (1 + condition | subject) + (1 | item)),\n    β = β,\n    σs = σs,\n    contrasts = Dict(:condition => EffectsCoding()), # we highly recommend specifying your contrasts, by Default its Dummy/ReferenceCoding with alphabetically sorted levels (relying 100% on StatsModels.jl)\n)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"and simulate!","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(design, signal, NoOnset(), NoNoise(), return_epoched = true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We get data with 50 samples (our basis from above), with 4 items and 20 subjects. We get items and subjects separately because we chose no-overlap (via NoOnset) and return_epoched = true`.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"size(data)\n\nfirst(evts, 5)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Finally, let's plot the data","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"f = Figure()\n\nfor k = 1:4\n    series(\n        f[1, k],\n        data[:, k, :]',\n        solid_color = :black,\n        axis = (; limits = ((0, 50), (-5, 6))),\n    )\n    Label(f[1, k, Top()], text = \"Item:\" * evts[k, :item] * \", c:\" * evts[k, :condition])\nend\nf","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Some remarks on interpreting the plot:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"The β main-effect of small (#2 and #4) vs. large (#1 and #3) is clearly visible.\nThe variability between subjects, is the variability between the individual curves.\nThe item effect shows up e.g. that #2 vs. #4 column show different values.","category":"page"},{"location":"generated/tutorials/multisubject/#Continuous-Signals-/-Overlap","page":"Multi-subject simulation","title":"Continuous Signals / Overlap","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Let's continue our tutorial and simulate overlapping signals instead.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We replace the NoOnset with an UniformOnset with 20 to 70 samples between subsequent events.  We further remove the return_epoched, because we want to have continuous data for now.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(design, signal, UniformOnset(offset = 20, width = 50), NoNoise());\nsize(data)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"with the first dimension being continuous data, and the latter still the subjects.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"series(data', solid_color = :black)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Each line is one subject, and it looks a bit unstructured, because the event-onsets are of course random for each subject.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"note: Note\nAll subjects have the same sequence of trials, if you need to change this, specify a event_order_function in the MultiSubjectDesign.","category":"page"},{"location":"generated/tutorials/multisubject/#Analyzing-these-data-with-Unfold.jl","page":"Multi-subject simulation","title":"Analyzing these data with Unfold.jl","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We will analyze these data using the Unfold.jl toolbox. While preliminary support for deconvolution (overlap correction) for mixed models is available, here we will not make use of it, but rather apply a MixedModel to each timepoint, following the Mass-univariate approach.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(\n    design,\n    signal,\n    UniformOnset(offset = 20, width = 50),\n    NoNoise();\n    return_epoched = true,\n);\nsize(data)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"For Unfold.jl, we have to reshape the data, so that all subjects are concatenated.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data = reshape(data, size(data, 1), :)\ntimes = range(0, 1, length = size(data, 1))\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition + (1 | item) + (1 + condition | subject)),\n    evts,\n    data,\n    times,\n)\nplot_erp(coeftable(m), mapping = (; col = :group))","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"The first column shows the fixed effects, the latter the item and subject random effects as they evolve across time","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"EditURL = \"../../../literate/HowTo/newDesign.jl\"","category":"page"},{"location":"generated/HowTo/newDesign/#Define-a-new-(imbalanced)-design","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"A design specifies how much data is generated, and how the event-table(s) should be generated. Already implemented examples are MultiSubjectDesign and SingleSubjectDesign.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"We need 3 things for a new design: a struct<:AbstractDesign, a size and a generate_events function.","category":"page"},{"location":"generated/HowTo/newDesign/#Setup","page":"Define a new (imbalanced) design","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"using UnfoldSim\nusing StableRNGs\nusing DataFrames\nusing Parameters\nusing Random","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"</details>\n<br />","category":"page"},{"location":"generated/HowTo/newDesign/#1)-type","page":"Define a new (imbalanced) design","title":"1) type","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"We need a ImbalanceSubjectDesign struct. You are free to implement it as you wish, as long as the other two functions are implemented","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"@with_kw struct ImbalanceSubjectDesign <: UnfoldSim.AbstractDesign\n    n_trials::Int\n    balance::Float64 = 0.5 # default balanced\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#2)-size","page":"Define a new (imbalanced) design","title":"2) size","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"we need a size(design::ImbalanceSubjectDesign) function to tell how many events we will have. This is used at different places, e.g. in the Default onset implementation","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"# note the trailing , to make it a Tuple\nUnfoldSim.size(design::ImbalanceSubjectDesign) = (design.n_trials,);\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#3)-generate_events","page":"Define a new (imbalanced) design","title":"3) generate_events","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"We need a type generate_events(rng::AbstractRNG, design::ImbalanceSubjectDesign) function. This function should return the actual table as a DataFrame","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"function UnfoldSim.generate_events(rng::AbstractRNG, design::ImbalanceSubjectDesign)\n    nA = Int(round.(design.n_trials .* design.balance))\n    nB = Int(round.(design.n_trials .* (1 - design.balance)))\n    @assert nA + nB ≈ design.n_trials\n    levels = vcat(repeat([\"levelA\"], nA), repeat([\"levelB\"], nB))\n    return DataFrame(Dict(:condition => levels))\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"Finally, we can test the function and see whether it returns a Design-DataFrame as we requested","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"design = ImbalanceSubjectDesign(; n_trials = 6, balance = 0.2)\ngenerate_events(design)","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"EditURL = \"../../../literate/HowTo/multichannel.jl\"","category":"page"},{"location":"generated/HowTo/multichannel/#Generate-multi-channel-data","page":"Generate multi channel data","title":"Generate multi channel data","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Here you will learn how to simulate EEG data for multiple channels/electrodes. The idea is to specify a signal on source level and then use a head model or a manual projection matrix to project the source signal to a number of electrodes.","category":"page"},{"location":"generated/HowTo/multichannel/#Setup","page":"Generate multi channel data","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"# Load required packages\nusing UnfoldSim\nusing UnfoldMakie\nusing CairoMakie\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"</details >","category":"page"},{"location":"generated/HowTo/multichannel/#Specifying-a-design","page":"Generate multi channel data","title":"Specifying a design","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"We are using a one-level design for testing here.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"design = SingleSubjectDesign(conditions = Dict(:condA => [\"levelA\"]));\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Next we generate two simple components at two different times without any formula attached (we have a single condition anyway)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [1]);\nc2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [1]);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#The-multichannel-component","page":"Generate multi channel data","title":"The multichannel component","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Next, similar to the nested design above, we can nest the component in a MultichannelComponent. We could either provide the projection matrix manually, e.g.:","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1])","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"or maybe more convenient: use the pair-syntax: Headmodel=>Label which makes use of a headmodel (HaRTmuT is currently easily available in UnfoldSim)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hart = Hartmut()\nmc = UnfoldSim.MultichannelComponent(c, hart => \"Left Postcentral Gyrus\")\nmc2 = UnfoldSim.MultichannelComponent(c2, hart => \"Right Occipital Pole\")","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nYou could also specify a noise-specific component which is applied prior to projection & summing with other components.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"finally we need to define the onsets of the signal","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"onset = UniformOnset(; width = 20, offset = 4);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#Simulation","page":"Generate multi channel data","title":"Simulation","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Now as usual we simulate data. Inspecting data shows our result is now indeed ~230 Electrodes large! Nice!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"data, events =\n    simulate(MersenneTwister(1), design, [mc, mc2], onset, PinkNoise(noiselevel = 0.05));\n\nsize(data)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nThe noise declared in the simulate function is added after mixing to channels, each channel receives independent noise. It is also possible to add noise to each individual component+source prior to projection. This would introduce correlated noise.","category":"page"},{"location":"generated/HowTo/multichannel/#Plotting","page":"Generate multi channel data","title":"Plotting","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Let's plot using Butterfly & Topoplot first we convert the electrodes to positions usable in TopoPlots.jl","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"pos3d = hart.electrodes[\"pos\"]\npos2d = to_positions(pos3d')\npos2d = [Point2f(p[1] + 0.5, p[2] + 0.5) for p in pos2d];\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"now plot!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"f = Figure()\ndf = DataFrame(\n    :estimate => data[:],\n    :channel => repeat(1:size(data, 1), outer = size(data, 2)),\n    :time => repeat(1:size(data, 2), inner = size(data, 1)),\n)\nplot_butterfly!(f[1, 1:2], df; positions = pos2d)\nplot_topoplot!(\n    f[2, 1],\n    df[df.time.==28, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nplot_topoplot!(\n    f[2, 2],\n    df[df.time.==48, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nf","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API / Docstrings","title":"API / Docstrings","text":"Modules = [UnfoldSim]","category":"page"},{"location":"api/#UnfoldSim.AutoRegressiveNoise","page":"API / Docstrings","title":"UnfoldSim.AutoRegressiveNoise","text":"AutoRegressiveNoise <: AbstractNoise\n\nNot implemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.ExponentialNoise","page":"API / Docstrings","title":"UnfoldSim.ExponentialNoise","text":"ExponentialNoise <: AbstractNoise\n\nType for generating noise with exponential decay in AR spectrum.\n\nTip: To manually create noise samples use the simulate_noise function.\n\nwarning: Warning\nWith the current implementation we try to get exponential decay over the whole autoregressive (AR) spectrum, which is N samples (the total number of samples in the signal) long. This involves the inversion of a Cholesky matrix of size NxN matrix, which will need lots of RAM for non-trivial problems.\n\nFields\n\nnoiselevel = 1 (optional): Factor that is used to scale the noise.\nν = 1.5 (optional): Exponential factor of AR decay \"nu\".\n\nExamples\n\njulia> noise = ExponentialNoise()\nExponentialNoise\n  noiselevel: Int64 1\n  ν: Float64 1.5\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 5)\n5-element Vector{Float64}:\n  -5.325200748641231\n  -3.437402125380177\n   2.7852625669058884\n  -1.5381022393382109\n -14.818799857226612\n\nSee also PinkNoise, RedNoise, NoNoise, WhiteNoise.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.Hartmut","page":"API / Docstrings","title":"UnfoldSim.Hartmut","text":"Hartmut <: AbstractHeadmodel\n\nType for accessing the HArtMuT model (Harmening et al., 2022), a head model which includes not only brain sources but also muscular and ocular sources.\n\nNote: Use Hartmut() to create an instance of this head model.\n\nFields\n\nartefacual::Any: Dict with artefactual sources (e.g. muscular and ocular) containing label, leadfield, orientation and position.\ncortical::Any:  Dict with cortical sources containing label, leadfield, orientation and position.\nelectrodes::Any: Dict with electrode labels and their positions in 3D space.\n\nExamples\n\njulia> h = Hartmut()\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\nHArtMuT-Headmodel\n227 electrodes:  (AF3,AF3h...) - hartmut.electrodes\n2004 source points: (Left Middle Temporal Gyrus, posterior division,...) - hartmut.cortical\n4260 source points: (Muscle_DepressorLabii_left,...) - hartmut.artefactual\n\nIn addition to UnfoldSim.jl please cite:\nHArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\n# Access artefactual sources\njulia> h.artefactual\nDict{String, Any} with 4 entries:\n  \"label\"       => [\"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Muscle_DepressorLabii_left\", \"Mu…\n  \"leadfield\"   => [-0.00148682 -0.00229078 … -0.307231 -0.321305; 0.0141537 0.0134523 … -0.141177 -0.140583; … ; 0.108747 0.1091 … 0.106614 0.117126; 0.0257134 0.0248186 … 0.00105064 -0.00433068;;; 0.0898798 0.0891799 … 2.02466 1.81…\n  \"orientation\" => [0.54244 0.482395 -0.687789; 0.546949 0.507161 -0.666059; … ; 0.193693 -0.979684 0.0519768; 0.327641 -0.944196 -0.0338583]\n  \"pos\"         => [-29.3728 58.6061 -120.829; -28.4183 59.0185 -121.448; … ; -21.8088 70.5968 -28.7679; -21.1545 70.1282 -31.4184]\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.LinearModelComponent","page":"API / Docstrings","title":"UnfoldSim.LinearModelComponent","text":"LinearModelComponent <: AbstractComponent\n\nA multiple regression component for one subject.\n\nAll fields can be named. Works best with SingleSubjectDesign.\n\nFields\n\nbasis::Any: an object, if accessed, provides a 'basis function', e.g. hanning(40)::Vector, this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects\nformula::Any: StatsModels formula object, e.g.  @formula 0 ~ 1 + cond (left-hand side must be 0).\nβ::Vector Vector of betas/coefficients, must fit the formula.\ncontrasts::Dict (optional): Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding.    For more information see https://juliastats.org/StatsModels.jl/stable/contrasts.\n\nExamples\n\njulia> LinearModelComponent(;\n           basis = hanning(40),\n           formula = @formula(0 ~ 1 + cond),\n           β = [1., 2.],\n           contrasts = Dict(:cond => EffectsCoding())\n       )\nLinearModelComponent\n  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  …  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]\n  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term}}\n  β: Array{Float64}((2,)) [1.0, 2.0]\n  contrasts: Dict{Symbol, EffectsCoding}\n\nSee also MixedModelComponent, MultichannelComponent.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.LogNormalOnset","page":"API / Docstrings","title":"UnfoldSim.LogNormalOnset","text":"LogNormalOnset <: AbstractOnset\n\nLog-normal inter-event distances (in samples) using the Distributions.jl truncated LogNormal distribution (code and mathematical reference).\n\nBe careful with large μ and σ values, as they are on logscale. σ>8 can quickly give you out-of-memory sized signals! \nTip: To manually generate inter-event distance samples use the simulate_interonset_distances function.\n\nFields\n\nμ: The mean of the log-transformed variable (the log-normal random variable's logarithm follows a normal distribution).\nσ: The standard deviation of the log-transformed variable.\noffset = 0 (optional): The minimal distance between events.\ntruncate_upper = nothing (optional): Upper limit (in samples) at which the distribution is truncated.\n\nExamples\n\njulia> onset_distribution = LogNormalOnset(3, 0.25, 10, 25)\nLogNormalOnset\n  μ: Int64 3\n  σ: Float64 0.25\n  offset: Int64 10\n  truncate_upper: Int64 25\n\nSee also UniformOnset, NoOnset.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MixedModelComponent","page":"API / Docstrings","title":"UnfoldSim.MixedModelComponent","text":"MixedModelComponent <: AbstractComponent\n\nA component that adds a hierarchical relation between parameters according to a Linear Mixed Model (LMM) defined via MixedModels.jl.\n\nAll fields can be named. Works best with MultiSubjectDesign.\n\nFields\n\nbasis::Any: an object, if accessed, provides a 'basis function', e.g. hanning(40)::Vector, this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects\nformula::Any: Formula-object in the style of MixedModels.jl e.g. @formula 0 ~ 1 + cond + (1|subject). The left-hand side is ignored.\nβ::Vector Vector of betas (fixed effects), must fit the formula.\nσs::Dict Dict of random effect variances, e.g. Dict(:subject => [0.5, 0.4]) or to specify correlation matrix Dict(:subject=>[0.5,0.4,I(2,2)],...). Technically, this will be passed to the MixedModels.jl create_re function, which creates the θ matrices.\ncontrasts::Dict (optional): Dict in the style of MixedModels.jl. Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding. For more information see https://juliastats.org/StatsModels.jl/stable/contrasts.\n\nExamples\n\njulia> MixedModelComponent(;\n           basis = hanning(40),\n           formula = @formula(0 ~ 1 + cond + (1 + cond|subject)),\n           β = [1., 2.],\n           σs= Dict(:subject => [0.5, 0.4]),\n           contrasts=Dict(:cond => EffectsCoding())\n       )\nMixedModelComponent\n  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  …  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]\n  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term, StatsModels.FunctionTerm{typeof(|), Vector{StatsModels.AbstractTerm}}}}\n  β: Array{Float64}((2,)) [1.0, 2.0]\n  σs: Dict{Symbol, Vector{Float64}}\n  contrasts: Dict{Symbol, EffectsCoding}\n\nSee also LinearModelComponent, MultichannelComponent.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultiSubjectDesign","page":"API / Docstrings","title":"UnfoldSim.MultiSubjectDesign","text":"MultiSubjectDesign <: AbstractDesign\n\nA type for specifying the experimental design for multiple subjects (based on the given random-effects structure).\n\nTip: Check the resulting dataframe using the generate_events function. \nPlease note that the number of items n_items has to be a multiple of the number of between-item levels. The sample applies for n_subjects and the number of between-subject levels.\n\nFields\n\nn_subjects::Int: Number of subjects.\nn_items::Int: Number of items/stimuli (sometimes ≈ trials).\nsubjects_between::Dict{Symbol,Vector}: Effects between subjects, e.g. young vs old.\nitems_between::Dict{Symbol,Vector}: Effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified also in subjects_between).\nboth_within::Dict{Symbol,Vector}: Effects completely crossed i.e. conditions/covariates that are both within-subject and within-item.\nevent_order_function = (rng, x) -> x: Can be used to sort, or shuffle the events e.g. (rng, x) -> shuffle(rng, x) (or shorter just event_order_function = shuffle).   The default is the identify function, i.e. not changing the order of the events.\n\nExamples\n\n# Declaring the same condition both between-subject and between-item results in a full between-subject/item design.\njulia> design = MultiSubjectDesign(;\n                       n_items = 10,\n                       n_subjects = 30,\n                       subjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n                       items_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n                       )\nMultiSubjectDesign\n  n_subjects: Int64 30\n  n_items: Int64 10\n  subjects_between: Dict{Symbol, Vector}\n  items_between: Dict{Symbol, Vector}\n  both_within: Dict{Symbol, Vector}\n  event_order_function: #3 (function of type UnfoldSim.var\"#3#7\")\n\njulia> generate_events(StableRNG(1), design)\n150×3 DataFrame\n Row │ subject  cond    item   \n     │ String   String  String \n─────┼─────────────────────────\n   1 │ S01      levelA  I01\n   2 │ S01      levelA  I03\n   3 │ S01      levelA  I05\n  ⋮  │    ⋮       ⋮       ⋮\n 148 │ S30      levelB  I06\n 149 │ S30      levelB  I08\n 150 │ S30      levelB  I10\n               144 rows omitted\n\nSee also SingleSubjectDesign, RepeatDesign\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultichannelComponent","page":"API / Docstrings","title":"UnfoldSim.MultichannelComponent","text":"MultichannelComponent <: AbstractComponent\n\nProjects a AbstractComponent to multiple \"channels\" via the projection vector.\n\nOptionally, noise can be added to the source prior to projection. By default a MultichannelComponent can be constructed using one of the following options for projection:\n\nprojection::AbstractVector: Directly pass a custom projection vector.\nprojection::Pair{<:AbstractHeadmodel,String}: Generate a projection vector by specifying which headmodel to use and which sources should be active.\n\nFields\n\ncomponent::AbstractComponent: The component that should be projected to the sensors.\nprojection::AbstractVector or projection::Pair{<:AbstractHeadmodel,String}: Vector p that projects the (source) component c[t] (where t is time) to the sensors s.   The length of p equals the number of sensors s. Typically, it is a slice of the leadfield matrix. out[s,t] = p[s]*c[t].\nnoise::AbstractNoise (optional): Noise added in the source space. Default is NoNoise.\n\nExamples\n\n# Variant 1: Specify the projection vector manually\njulia> c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [1]);\n\njulia> mc1 = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1])\nMultichannelComponent\n  component: LinearModelComponent\n  projection: Array{Float64}((7,)) [1.0, 2.0, -1.0, 3.0, 5.0, 2.3, 1.0]\n  noise: NoNoise NoNoise()\n\n# Variant 2: Use a headmodel and specify a source\njulia> c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [1]);\n\njulia> hart = headmodel(type = \"hartmut\");\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> mc2 = UnfoldSim.MultichannelComponent(c2, hart => \"Right Occipital Pole\")\nMultichannelComponent\n  component: LinearModelComponent\n  projection: Array{Float64}((227,)) [-0.03461859471337842, -0.04321094803502425, 0.0037088347968313525, -0.014722528968861278, -0.0234889834534478, 0.02731807504242923, 0.038863688452528036, 0.1190531258070562, -0.09956890221613562, -0.0867729334438599  …  0.37435404409695094, -0.020863789022627935, 0.25627478723535513, -0.05777985212119245, 0.37104376432271147, -0.19446620423767172, 0.2590764703721097, -0.12923837607416555, 0.1732886690359311, 0.4703016561960567]\n  noise: NoNoise NoNoise()\n\nSee also LinearModelComponent, MixedModelComponent.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.NoNoise","page":"API / Docstrings","title":"UnfoldSim.NoNoise","text":"NoNoise <: AbstractNoise\n\nA type for simulations without noise; return zeros instead of noise.\n\nTip: To manually create noise samples use the simulate_noise function.\n\nExamples\n\njulia> noise = NoNoise()\nNoNoise()\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 3)\n3-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n\nSee also PinkNoise, RedNoise, ExponentialNoise, WhiteNoise.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.NoOnset","page":"API / Docstrings","title":"UnfoldSim.NoOnset","text":"NoOnset <: AbstractOnset\n\nFor cases where the user wants to simulate epoched data without any overlap between consecutive events.\n\nExamples\n\njulia> onset_distribution = NoOnset()\nNoOnset()\n\nSee also UniformOnset, LogNormalOnset.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.PinkNoise","page":"API / Docstrings","title":"UnfoldSim.PinkNoise","text":"PinkNoise <: AbstractNoise\n\nA type for generating Pink Noise using the SignalAnalysis.jl implementation.\n\nThe noise values are sampled from a standard normal distribution 𝒩(μ=0, σ=1). That means that ~95% of the values are between ~-2 and ~2 (with noiselevel = 1).\nTip: To manually create noise samples use the simulate_noise function.\n\nFields\n\nnoiselevel = 1 (optional): Factor that is used to scale the noise.\nfunc = SignalAnalysis.PinkGaussian (optional): Function that is used to create the noise samples.   This field is for internal use and should not typically be modified directly by the user.   Changes to this field may result in unexpected behavior.\n\nExamples\n\njulia> noise = PinkNoise(noiselevel = 3)\nPinkNoise\n  noiselevel: Int64 3\n  func: UnionAll\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 5)\n5-element Vector{Float64}:\n 2.578878369756878\n 3.4972108606501786\n 2.878568584946028\n 2.2725654770788384\n 3.5291669151888683\n\nSee also RedNoise, WhiteNoise, ExponentialNoise, NoNoise.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RealisticNoise","page":"API / Docstrings","title":"UnfoldSim.RealisticNoise","text":"RealisticNoise <: AbstractNoise\n\nNot implemented - planned to use Artifacts.jl to provide real EEG data to add.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RedNoise","page":"API / Docstrings","title":"UnfoldSim.RedNoise","text":"RedNoise <: AbstractNoise\n\nA type for generating Red Noise using the SignalAnalysis.jl implementation.\n\nThe noise values are sampled from a standard normal distribution 𝒩(μ=0, σ=1). That means that ~95% of the values are between ~-2 and ~2 (with noiselevel = 1).\nTip: To manually create noise samples use the simulate_noise function.\n\nFields\n\nnoiselevel = 1 (optional): Factor that is used to scale the noise.\nfunc = SignalAnalysis.RedGaussian (optional): Function that is used to create the noise samples.   This field is for internal use and should not typically be modified directly by the user.   Changes to this field may result in unexpected behavior.\n\nExamples\n\njulia> noise = RedNoise(noiselevel = 2)\nRedNoise\n  noiselevel: Int64 2\n  func: UnionAll\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(2), noise, 3)\n3-element Vector{Float64}:\n -0.34153942884005967\n -0.4651387715669636\n -0.4951538876376382\n\nSee also PinkNoise, WhiteNoise, ExponentialNoise, NoNoise.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RepeatDesign","page":"API / Docstrings","title":"UnfoldSim.RepeatDesign","text":"RepeatDesign{T} <: AbstractDesign\n\nRepeat a design (and the corresponding events DataFrame) multiple times to mimick repeatedly recorded trials.\n\nTip: Check the resulting dataframe using the generate_events function. Please note that when using an event_order_function(e.g. shuffle) in a RepeatDesign, the corresponding RNG is shared across repetitions and not deep-copied for each repetition. As a result, the order of events will differ for each repetition.\n\nFields\n\ndesign::T: The experimental design that should be repeated.\nrepeat::Int = 1: The number of repetitions.\n\nExamples\n\njulia> using StableRNGs # For using the `generate_events` function in a reproducible way\n\njulia> design_once =\n           SingleSubjectDesign(;\n               conditions = Dict(\n                   :stimulus_type => [\"natural\", \"artificial\"],\n                   :contrast_level => range(0, 1, length = 2),\n               ),\n               event_order_function = shuffle,\n           );\n\njulia> generate_events(StableRNG(1), design_once)\n4×2 DataFrame\n Row │ contrast_level  stimulus_type \n     │ Float64         String        \n─────┼───────────────────────────────\n   1 │            1.0  natural\n   2 │            1.0  artificial\n   3 │            0.0  natural\n   4 │            0.0  artificial\n\njulia> design = RepeatDesign(design_once, 2)\nRepeatDesign{SingleSubjectDesign}\n  design: SingleSubjectDesign\n  repeat: Int64 2\n\njulia> generate_events(StableRNG(1), design)\n8×2 DataFrame\n Row │ contrast_level  stimulus_type \n     │ Float64         String        \n─────┼───────────────────────────────\n   1 │            1.0  natural\n   2 │            1.0  artificial\n   3 │            0.0  natural\n   4 │            0.0  artificial\n   5 │            1.0  artificial\n   6 │            0.0  natural\n   7 │            1.0  natural\n   8 │            0.0  artificial\n\nSee also SingleSubjectDesign, MultiSubjectDesign\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.Simulation","page":"API / Docstrings","title":"UnfoldSim.Simulation","text":"Simulation\n\nA type to store all \"ingredients\" for a simulation including their parameters.\n\nCan either be created by the user or will be created automatically when calling the simulate function with the required \"ingredients\". Tip: Use the subtypes function to get an overview of the implemented \"ingredients\", e.g. subtypes(AbstractDesign).\n\nFields\n\ndesign::AbstractDesign: Experimental design.\ncomponents::Vector{AbstractComponent}: Response function(s) for the events (e.g. the ERP shape in EEG).\nonset::AbstractOnset: Inter-onset distance distribution.\nnoisetype::AbstractNoise: Noise type.\n\nExamples\n\njulia> design = SingleSubjectDesign(; conditions = Dict(:stimulus_type => [\"natural\", \"artificial\"]));\n\njulia> component = LinearModelComponent(;\n           basis = p100(),\n           formula = @formula(0 ~ 1 + stimulus_type),\n           β = [2, 3],\n       );\n\njulia> onset = UniformOnset();\n\njulia> noise = PinkNoise();\n\njulia> simulation = Simulation(design, component, onset, noise);\n\njulia> using StableRNGs\n\njulia> data, events = simulate(StableRNG(1), simulation);\n\njulia> events\n2×2 DataFrame\n Row │ stimulus_type  latency \n     │ String         Int64   \n─────┼────────────────────────\n   1 │ natural             20\n   2 │ artificial          70\n\njulia> data\n85-element Vector{Float64}:\n  0.8596261232522926\n  1.1657369535500595\n  0.9595228616486761\n  ⋮\n  0.9925202143746904\n  0.2390652543395527\n -0.11672523788068771\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.SingleSubjectDesign","page":"API / Docstrings","title":"UnfoldSim.SingleSubjectDesign","text":"SingleSubjectDesign <: AbstractDesign\n\nA type for specifying the experimental design for a single subject (based on the given conditions).\n\nTip: Check the resulting dataframe using the generate_events function. \nThe number of trials/rows in the output of generate_events([rng, ]design) depends on the full factorial of your conditions. \nTo increase the number of repetitions, e.g. by 5, simply use RepeatDesign(SingleSubjectDesign(...), 5). \nIf conditions are omitted (or set to nothing), a single trial is simulated with a column :dummy and content :dummy - this is for convenience.\n\nFields\n\nconditions::Dict{Symbol,Vector}: Experimental conditions, e.g. Dict(:A => [\"a_small\",\"a_big\"], :B => [\"b_tiny\",\"b_large\"]).\nevent_order_function = (rng, x) -> x: Can be used to sort by specifying sort, or shuffling by providing shuffle, or custom functions following the interface (rng, x) -> my_shuffle(rng,x).   The default is the identify function, i.e. not changing the order of the events.\n\nExamples\n\njulia> using StableRNGs # For using the `generate_events` function in a reproducible way\n\njulia> design =\n           SingleSubjectDesign(;\n               conditions = Dict(\n                   :stimulus_type => [\"natural\", \"artificial\"],\n                   :contrast_level => range(0, 1, length = 5),\n               ),\n           )\nSingleSubjectDesign\n  conditions: Dict{Symbol, Vector}\n  event_order_function: #10 (function of type UnfoldSim.var\"#10#14\")\n\njulia> generate_events(StableRNG(1), design)\n10×2 DataFrame\n Row │ contrast_level  stimulus_type \n     │ Float64         String        \n─────┼───────────────────────────────\n   1 │           0.0   natural\n   2 │           0.25  natural\n   3 │           0.5   natural\n  ⋮  │       ⋮               ⋮\n   8 │           0.5   artificial\n   9 │           0.75  artificial\n  10 │           1.0   artificial\n                       4 rows omitted\n\nSee also MultiSubjectDesign, RepeatDesign\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.UniformOnset","page":"API / Docstrings","title":"UnfoldSim.UniformOnset","text":"UniformOnset <: AbstractOnset\n\nProvide a Uniform Distribution for the inter-event distances (in samples).\n\nTip: To manually generate inter-event distance samples use the simulate_interonset_distances function.\n\nFields\n\nwidth = 50 (optional): Width of the uniform distribution (=> the \"jitter\"). Since the lower bound is 0, width is also the upper bound.\noffset = 0 (optional): The minimal distance between events. The maximal distance is offset + width.\n\nExamples\n\njulia> onset_distribution = UniformOnset(width = 25, offset = 5)\nUniformOnset\n  width: Int64 25\n  offset: Int64 5\n\nSee also LogNormalOnset, NoOnset.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.WhiteNoise","page":"API / Docstrings","title":"UnfoldSim.WhiteNoise","text":"WhiteNoise <: AbstractNoise\n\nA type for generating White Noise using randn - thus Gaussian noise.\n\nThe noise values are sampled from a standard normal distribution 𝒩(μ=0, σ=1). That means that ~95% of the values are between ~-2 and ~2 (with noiselevel = 1).\nTip: To manually create noise samples use the simulate_noise function.\n\nFields\n\nnoiselevel = 1 (optional): Factor that is used to scale the noise.\nimfilter = nothing (optional): Use imfilter > 0 to smooth the noise using Image.imfilter with a Gaussian kernel with σ = imfilter.\n\nExamples\n\njulia> noise = WhiteNoise()\nWhiteNoise\n  noiselevel: Int64 1\n  imfilter: Nothing nothing\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 3)\n3-element Vector{Float64}:\n -0.5325200748641231\n  0.098465514284785\n  0.7528865221245234\n\nSee also PinkNoise, RedNoise, ExponentialNoise, NoNoise.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.length-Tuple{AbstractDesign}","page":"API / Docstrings","title":"Base.length","text":"Length is the product of all dimensions and equals the number of events in the corresponding events dataframe.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{MultiSubjectDesign}","page":"API / Docstrings","title":"Base.size","text":"Return the dimensions of the experiment design.\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Windows.hanning-Tuple{Any, Any, Any}","page":"API / Docstrings","title":"DSP.Windows.hanning","text":"hanning(duration, offset, sfreq)\n\nGenerate a (potentially shifted) hanning window with a certain duration. \n\nNote: This function extends the DSP.hanning function using multiple dispatch.\n\nArguments\n\nduration: in s.\noffset: in s, defines hanning peak i.e. shift of the hanning window.\nsfreq: Sampling rate in Hz.\n\nReturns\n\nVector: Contains a shifted (i.e. zero-padded) hanning window.\n\nExamples\n\njulia> UnfoldSim.hanning(0.1, 0.3, 100)\n25-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.9698463103929542\n 0.75\n 0.41317591116653485\n 0.11697777844051105\n 0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.PuRF-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.PuRF","text":"PuRF(; n = 10.1, tmax = 0.93, sfreq = 100)\n\nDefault generator for PuRF Pupil Response Function. The canonical PRF is a gamma function and implemented according to Denison 2020 equation (2) going back to Hoeks & Levelt, 1993.\n\nThe pupil response is evaluated at t = 0:1/sfreq:3*tmax. The response is normalized by the peak-maximum at tmax, thus typically a pupil-response of 1 is returned (disregarding numerical issues).\n\nKeyword arguments:\n\nn = 10.1: shape parameter\ntmax = 0.93: peak maximum\nsfreq = 100: sampling frequency\n\nReturns\n\nVector: canonical pupil response with length(0:1/sfreq:3*tmax) entries.\n\nExamples\n\njulia> PuRF(; n = 5)\n280-element Vector{Float64}:\n 0.0\n 2.0216617815131253e-8\n 6.130689396024061e-7\n 4.4118063684811444e-6\n 1.761817666835793e-5\n ⋮\n 0.012726253506722554\n 0.012280989091455786\n 0.011850525657416842\n 0.011434405338911133\n 0.011032182932283816\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}","page":"API / Docstrings","title":"UnfoldSim.add_noise!","text":"add_noise!(rng, noisetype::AbstractNoise, signal)\n\nGenerate and add noise to a signal.\n\nAssumes that the signal can be linearized, that is, that the noise is stationary.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}","page":"API / Docstrings","title":"UnfoldSim.add_responses!","text":"add_responses!(signal, responses::Vector, e, s, tvec, trial_idx)\nadd_responses!(signal, responses::Matrix, e, s, tvec, trial_idx)\nadd_responses!(signal, responses::AbstractArray, e, s, tvec, trial_idx)\n\nAdd (in-place) the given responses to the signal, for both 2D (1 channel) and 3D (X channel case). Helper function.\n\nArguments\n\nsignal: Continuous EEG signal to be modified in place. Has the dimensions channels x continuous_time x subjects.\nresponses::Union{Vector, Matrix, AbstractArray}: Responses to be added. In the multi-channel case, the dimensions are channels x maxlength(components) x length(simulation.design), else maxlength(components) x length(simulation.design).  The data for all the subjects and their respective trials is concatenated.\ne: Index of the channel (in signal) for which to add the response.\ns: Index of the subject (in signal) for which to add the response.\ntvec: Time points (indices in signal) at which to add the response.\ntrial_idx: Index of the particular trial (in responses) from where the response is to be added.\n\nReturns\n\nNothing: signal is modified in-place.\n\nExamples\n\njulia> signal, responses, tvec = zeros(5,15,2), ones(5,6), 1:5;\n\njulia> UnfoldSim.add_responses!(signal, responses, 1, 2, tvec, 5);\n\njulia> signal\n5×15×2 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n[:, :, 2] =\n 1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.apply_event_order_function-Tuple{Any, Any, Any}","page":"API / Docstrings","title":"UnfoldSim.apply_event_order_function","text":"apply_event_order_function(fun, rng, events)\n\nApply fun(rng, events), raise an error if function fun is wrongly defined. Convenience function to not repeat the error handling at multiple places.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{AbstractVector{<:AbstractVector}, Any}","page":"API / Docstrings","title":"UnfoldSim.closest_src","text":"closest_src(coords_list::AbstractVector{<:AbstractVector}, pos)\n\nWhen applied to a vector of target coordinate vectors, return the index of the closest position in pos for each of the targets. \n\nReturns\n\nVector: Index of the closest position in pos for each vector in coords_list.\n\nExamples\n\njulia> positions = [0 0 0; 2 2 2; 3 3 3; 4 4 4];\njulia> target_coordinate_vectors = [[0.5, 0, 0.5], [10, 1, 8]];\n\njulia> UnfoldSim.closest_src(target_coordinate_vectors, positions)\n2-element Vector{Int64}:\n 1\n 4\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{Hartmut, String}","page":"API / Docstrings","title":"UnfoldSim.closest_src","text":"closest_src(head::Hartmut, label::String)\n\nReturn the index of the Harmut model source point that is closest (using Euclidean distance) to the mean position of the source points matching the given label.\n\nimportant: Important\nWe use the average in Euclidean space, but the cortex is a curved surface. In most cases they will not overlap. Ideally we would calculate the average on the surface, but this is a bit more complex to do (you'd need to calculate the vertices etc.).\n\nArguments\n\nhead::Hartmut: Headmodel of type Hartmut.\nlabel::String: Label of the source point(s) of interest.\n\nReturns\n\nInt: Index of the closest Hartmut source point.\n\nExamples\n\njulia> hartmut = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> label = \"Right Cingulate Gyrus, posterior division\";\n\njulia> UnfoldSim.closest_src(hartmut, label)\n1875\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{Vector{<:Real}, Any}","page":"API / Docstrings","title":"UnfoldSim.closest_src","text":"closest_src(coords::Vector{<:Real}, pos)\n\nReturn the index of the position that is closest to the target coordinates (using the Euclidean distance).\n\nArguments\n\ncoords::Vector{<:Real}: Target coordinate vector (typically with length 3).\npos: Matrix that contains all possible positions.   Its dimensions are the number of positions n times number of entries in the position coordinate vectors (usually 3) i.e. n x 3.\n\nReturns\n\nInt: Row index of the position in pos that is closest to coords.\n\nExamples\n\njulia> positions = [0 0 0; 2 2 2; 3 3 3; 4 4 4]\n4×3 Matrix{Int64}:\n 0  0  0\n 2  2  2\n 3  3  3\n 4  4  4\n\njulia> target_coordinates = [0.5, 0, 0.5]\n3-element Vector{Float64}:\n 0.5\n 0.0\n 0.5\n\n julia> UnfoldSim.closest_src(target_coordinates, positions)\n1\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}","page":"API / Docstrings","title":"UnfoldSim.create_continuous_signal","text":"create_continuous_signal(rng, responses, simulation)\n\nSimulate onset latencies and add together a continuous signal, based on the given responses and simulation parameters. Helper function.\n\nArguments\n\nrng: Random number generator, important to ensure reproducibility.\nresponses: Responses to be combined with the given onsets.\nsimulation: Simulation parameters, including design, components, onsets, and noisetype.\n\nReturns\n\n(signal, latencies)::Tuple{Array, Array}:\nsignal contains the generated signal. Has the dimensions channels x continuous_time x subjects.\nlatencies contains the onset latencies.\n\nExamples\n\njulia> using StableRNGs # to get an RNG\n\njulia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);\n\njulia> c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [2]);\n\njulia> simulation = Simulation(design, [c1, c2], UniformOnset(; width = 0, offset = 30), PinkNoise());\n\njulia> responses = simulate_responses(StableRNG(1), [c1, c2], simulation)\n45×2 Matrix{Float64}:\n 0.0        0.0\n 0.0        0.0\n ⋮          \n 0.0233794  0.0233794\n 0.0        0.0\n\njulia> signal, latencies = UnfoldSim.create_continuous_signal(StableRNG(1), responses, simulation);\n\njulia> signal\n106-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n ⋮\n 0.023379444289913343\n 0.0\n 0.0\n\n julia> latencies\n2-element Vector{Int64}:\n 31\n 61\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}","page":"API / Docstrings","title":"UnfoldSim.epoch","text":"epoch(data::AbstractVector, args...; kwargs...)\n\nOne channel case. The data is reshaped and then passed to the multi-channel epoch method.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.epoch-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Tuple{Number, Number}, Any}} where T<:Union{Missing, Number}","page":"API / Docstrings","title":"UnfoldSim.epoch","text":"epoch(\n    data::AbstractArray{T,2},\n    events,\n    τ::Tuple{Number,Number},\n    sfreq;\n    eventtime::Symbol = :latency,\n) where {T<:Union{Missing,Number}}\n\nHelper function to segment continuous data into epochs based on the given events and the time window τ.\n\nAdapted from Unfold.jl: https://github.com/unfoldtoolbox/Unfold.jl/blob/b3  a21c2bb7e93d2f45ec64b0197f4663a6d7939a/src/utilities.jl#L40\n\nArguments\n\ndata::AbstractArray{T,2}: Continuous data with the dimensions channels x continuous_time.\nevents: Events data frame (based on the design) with latencies.\nτ::Tuple{Number,Number}: Time window for epoching in s.\nsfreq: Sampling frequency in Hz.\n\nKeyword arguments\n\neventtime::Symbol = :latency: The name of the column in events that contains the latencies.\n\nReturns\n\nArray: Epoched data with the dimensions channels x times x event (or times x event for the single channel case).\n\nExamples\n\n# One channel example\njulia> data, events = UnfoldSim.predef_eeg();\n\njulia> size(data), size(events)\n((120199,), (2000, 3))\n\njulia> UnfoldSim.epoch(data, events, (-0.2, 1), 100)\n121×2000 Matrix{Float64}:\n  0.114127   -0.105347     …  -0.125485   1.6383\n  0.128198    0.0474874        0.0112935  1.28122\n  0.0547917  -0.0832977       -0.126181   0.850062\n  0.0992842  -0.230224        -0.0449072  0.496583\n  0.024461   -0.175023        -0.0223837  0.170389\n  0.165133   -0.000793527  …  -0.0278197  0.104454\n  ⋮                        ⋱              \n -0.362249    2.91297          0.546699   0.0\n -0.199265    2.58394          0.171159   0.0\n -0.184075    2.34611         -0.0269841  0.0\n -0.13901     2.11971         -0.0552873  0.0\n -0.0674085   1.74561      …  -0.187959   0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events","page":"API / Docstrings","title":"UnfoldSim.generate_events","text":"generate_events(design::AbstractDesign)\ngenerate_events(rng::AbstractRNG, design::AbstractDesign)\n\nGenerate a full-factorial events DataFrame based on the experimental conditions and covariates defined in the design.\n\nArguments\n\ndesign::AbstractDesign: Experimental design for which the events DataFrame should be created.\nrng::AbstractRNG (optional): Random number generator (RNG) to make the process reproducible. If none is given, MersenneTwister(1) will be used.\n\nReturns\n\nDataFrame: Each row corresponds to one combination of condition/covariate levels which is often equivalent to one stimulus or trial.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}","page":"API / Docstrings","title":"UnfoldSim.generate_events","text":"generate_events(design::MultiSubjectDesign)\ngenerate_events(rng::AbstractRNG, design::MultiSubjectDesign)\n\nGenerate the events Dataframe according to MixedModelsSim.jl's simdat_crossed function.\n\nAfterwards apply design.event_order_function and finally sort by :subject. \nNote: No condition can be named dv which is used internally in MixedModelsSim / MixedModels as a dummy left-side\n\nExamples\n\njulia> using Random # for shuffling\njulia> using StableRNGs\n\njulia> design = MultiSubjectDesign(;\n                       n_items = 4,\n                       n_subjects = 5,\n                       both_within = Dict(:condition => [\"red\", \"green\"]),\n                       event_order_function = shuffle,\n                       );\n\njulia> generate_events(StableRNG(1), design)\n40×3 DataFrame\n Row │ subject  item    condition \n     │ String   String  String    \n─────┼────────────────────────────\n   1 │ S1       I2      red\n   2 │ S1       I2      green\n   3 │ S1       I3      green\n  ⋮  │    ⋮       ⋮         ⋮\n  38 │ S5       I3      red\n  39 │ S5       I2      red\n  40 │ S5       I4      green\n                   34 rows omitted\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, RepeatDesign}","page":"API / Docstrings","title":"UnfoldSim.generate_events","text":"UnfoldSim.generate_events([rng::AbstractRNG, ]design::RepeatDesign{T})\n\nFor a RepeatDesign, iteratively call generate_events for the underlying {T} design and concatenate the results.\n\nIn case of MultiSubjectDesign, sort by subject. \nPlease note that when using an event_order_function(e.g. shuffle) in a RepeatDesign, the corresponding RNG is shared across repetitions and not deep-copied for each repetition. As a result, the order of events will differ for each repetition.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, SingleSubjectDesign}","page":"API / Docstrings","title":"UnfoldSim.generate_events","text":"generate_events(design::SingleSubjectDesign)\ngenerate_events(rng::AbstractRNG, design::SingleSubjectDesign)\n\nGenerate the events DataFrame based on design.conditions and afterwards apply design.event_order_function.\n\nIf design.conditions is nothing, a single trial is simulated with a column :dummy and content :dummy - this is for convenience.\n\nExamples\n\njulia> using Random # for shuffling\njulia> using StableRNGs\n\njulia> design = SingleSubjectDesign(;\n           conditions = Dict(:A => [\"small\", \"large\"], :B => range(1, 5, length = 3)),\n           event_order_function = shuffle,\n       );\n\n# Variant 1: Without specifying an RNG, MersenneTwister(1) will be used for the shuffling specified as `event_order_function`.\njulia> generate_events(design)\n6×2 DataFrame\n Row │ A       B       \n     │ String  Float64 \n─────┼─────────────────\n   1 │ large       5.0\n   2 │ large       1.0\n   3 │ large       3.0\n   4 │ small       1.0\n   5 │ small       3.0\n   6 │ small       5.0\n\n# Variant 2: Use a custom RNG.\njulia> generate_events(StableRNG(1), design)\n6×2 DataFrame\n Row │ A       B       \n     │ String  Float64 \n─────┼─────────────────\n   1 │ large       5.0\n   2 │ large       3.0\n   3 │ small       1.0\n   4 │ small       3.0\n   5 │ large       1.0\n   6 │ small       5.0\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hartmut_citation-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.hartmut_citation","text":"Return the citation string for HArtMuT.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hrf-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.hrf","text":"hrf(;\nTR = 1,\npeak = 6.0,\npost_undershoot = 16,\nlength = 32.0,\npeak_width = 1.0,\npost_undershoot_width = 1,\namplitude = 6,\nshift = 0)\n\nGenerate a parameterized BOLD haemodynamic response function (HRF) kernel based on gamma-functions.\n\nImplementation and default parameters were taken from the SPM-toolbox.\n\nNote: TR = 1/sfreq\n\nKeyword arguments\n\nTR = 1: repetition time, 1/sfreq.\nlength = 32.0: total length of the kernel in seconds.\namplitude = 6: maximal amplitude.\npeak = 6.0: peak timing.\npeak_width = 1.0: width of the peak.\npost_undershoot = 16: post-undershoot timing.\npost_undershoot_width = 1: post-undershoot width.\nshift = 0: shift the whole HRF.\n\nReturns\n\nVector: HRF BOLD response.\n\nExamples\n\njulia> hrf()\n33-element Vector{Float64}:\n  0.0\n  0.0007715994433635659\n  0.019784004131204957\n  0.08202939459091822\n  0.158157713522699\n  ⋮\n -0.0006784790038792572\n -0.00042675060451877775\n -0.000263494738348278\n -0.00015990722628360688\n -9.548780093799345e-5\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.leadfield-Tuple{Hartmut}","page":"API / Docstrings","title":"UnfoldSim.leadfield","text":"leadfield(hart::Hartmut; type = \"cortical\")\n\nReturn the leadfield for the (cortical or artefacual) sources of the HArtMuT model.\n\nKeyword arguments\n\ntype = \"cortical\": Defines whether the \"cortical\" or \"artefactual\" leadfield should be returned.\n\nReturns\n\nArray{Float64, 3}: Leadfield values i.e. how much each source contributes to the potential measured at each electrode.   The output dimensions are electrodes x sources x spatial dimension.\n\nExamples\n\njulia> h = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> lf = leadfield(h);\n\njulia> size(lf)\n(227, 2004, 3)\n\n# Access the leadfield for one spatial dimension\njulia> lf[:,:,1]\n227×2004 Matrix{Float64}:\n  0.151429    0.0284341  …  -0.119927     -0.158114\n  0.1732      0.0441432     -0.110515     -0.165316\n  0.249592    0.10857       -0.000593027  -0.0206122\n  0.245206    0.104854      -0.0200251    -0.055392\n  0.126496    0.0118467     -0.128248     -0.146107\n  0.253092    0.111688   …   0.02277       0.0184387\n  ⋮                      ⋱                \n  0.20306     0.138837       0.133486      0.18334\n -0.689154   -1.00904       -0.108276     -0.105398\n  0.192729    0.148448       0.0924756     0.142322\n -1.26181    -1.59936       -0.140598     -0.133054\n  0.213982    0.145953   …   0.115515      0.170698\n  0.0731569   0.0794415      0.0485819     0.107929\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Tuple{AbstractHeadmodel}","page":"API / Docstrings","title":"UnfoldSim.magnitude","text":"magnitude(headmodel::AbstractHeadmodel)\n\nReturn the magnitude for the given headmodel based on the leadfield (and potentially the source orientations) specified in the headmodel.\n\nIf the headmodel includes source orientations these are used in the calculations, otherwise the leadfield is returned assuming that the source orientations are already included. Please note that (at least in the case of the HArtMuT model) the leadfield for the cortical sources is used.\n\nReturns\n\nMatrix{Float64}: Contribution of each source to the potential measured at each electrode taking into account the orientation of the sources.   The output dimensions are electrodes x sources.\n\nExamples\n\n# Using the HArtMut model as an example\njulia> h = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> magnitude(h)\n227×2004 Matrix{Float64}:\n  0.111706   …   0.301065\n  0.0774359      0.332934\n  ⋮          ⋱  \n -0.164539      -0.246555\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T<:Real","page":"API / Docstrings","title":"UnfoldSim.magnitude","text":"magnitude(lf::AbstractArray{T,3}, orientation::AbstractArray{T,2}) where {T<:Real}\n\nReturn the magnitude of the leadfield lf along the given orientation.\n\nArguments\n\nlf::AbstractArray{T,3}: Leadfield with the dimensions electrodes x sources x spatial dimension.\norientation::AbstractArray{T,2}: Source orientations with the dimensions sources x spatial dimensions.\n\nExamples\n\n# Specify the leadfield (often given by a headmodel)\njulia> lf = cat([1 0; 0 1; 0 0], [1 1; 0 0; 0.5 0.5], dims=3);\n\n# Specify the source orientations\njulia> ori = [1.0 0; 0 1]\n\n# Calculate the magnitude\njulia> magnitude(lf, ori)\n3×2 Matrix{Float64}:\n 1.0  1.0\n 0.0  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.maxlength-Tuple{Vector{<:AbstractComponent}}","page":"API / Docstrings","title":"UnfoldSim.maxlength","text":"maxlength(c::Vector{<:AbstractComponent}) = maximum(length.(c))\n\nReturn the maximum of the individual components' lengths.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n170-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.n170","text":"n170(; sfreq = 100)\n\nGenerate a Hanning window mimicking an N170 EEG component with a negative (!) peak at 170ms and a width of 150ms.\n\nKeyword arguments\n\nsfreq = 100: Sampling frequency in Hz.\n\nReturns\n\nVector: Contains a shifted (i.e. zero-padded) hanning window.\n\nExamples\n\njulia> n170(; sfreq = 120)\n28-element Vector{Float64}:\n -0.0\n -0.0\n -0.0\n -0.0\n -0.0\n  ⋮\n -0.45386582026834904\n -0.2771308221117309\n -0.1304955413896705\n -0.03376388529782215\n -0.0\n\nSee also p100, p300, n400, hanning.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n400-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.n400","text":"n400(; sfreq = 100)\n\nGenerate a Hanning window mimicking an N400 EEG component with a negative (!) peak at 400ms and a width of 400ms.\n\nKeyword arguments\n\nsfreq = 100: Sampling frequency in Hz.\n\nReturns\n\nVector: Contains a shifted (i.e. zero-padded) hanning window.\n\nExamples\n\njulia> n400(; sfreq = 250)\n150-element Vector{Float64}:\n -0.0\n -0.0\n -0.0\n -0.0\n -0.0\n  ⋮\n -0.016025649301821876\n -0.009035651368646647\n -0.00402259358460233\n -0.0010066617640578368\n -0.0\n\nSee also p100, p300, n170, hanning.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{AbstractComponent}","page":"API / Docstrings","title":"UnfoldSim.n_channels","text":"n_channels(c::AbstractComponent)\n\nReturn the number of channels for the given component c. By default = 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{MultichannelComponent}","page":"API / Docstrings","title":"UnfoldSim.n_channels","text":"n_channels(c::MultichannelComponent)\n\nFor MultichannelComponent return the length of the projection vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{Vector{<:AbstractComponent}}","page":"API / Docstrings","title":"UnfoldSim.n_channels","text":"n_channels(c::Vector{<:AbstractComponent})\n\nFor a vector of MultichannelComponents, return the number of channels for the first component but assert all are of equal length.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.orientation-Tuple{Hartmut}","page":"API / Docstrings","title":"UnfoldSim.orientation","text":"orientation(hart::Hartmut; type = \"cortical\")\n\nReturn the orientations of the (cortical or artefacual) sources of the HArtMuT model. \n\nThe norm of the orientation vectors is 1 and the values are between -1 and 1.\n\nKeyword arguments\n\ntype = \"cortical\": Defines whether the \"cortical\" or \"artefactual\" orientations should be returned.\n\nReturns\n\nMatrix{Float64}: Orientations in 3D space. The output dimensions are sources x spatial dimensions.\n\nExamples\n\njulia> h = Hartmut();\nPlease cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce\n\njulia> orientation(h)\n2004×3 Matrix{Float64}:\n -0.921919   0.364292   0.131744\n -0.900757  -0.415843  -0.125345\n -0.954087   0.117479  -0.27553\n -0.814613  -0.55344    0.17352\n -0.790526   0.276849  -0.546281\n  ⋮                    \n -0.962905   0.20498   -0.17549\n -0.828358   0.557468  -0.0552498\n -0.963785  -0.265607  -0.0239074\n -0.953909   0.203615   0.22045\n -0.75762    0.128027   0.640016\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.p100-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.p100","text":"p100(; sfreq = 100)\n\nGenerate a Hanning window mimicking a P100 EEG component with a peak at 100ms and a width of 100ms.\n\nKeyword arguments\n\nsfreq = 100: Sampling frequency in Hz.\n\nReturns\n\nVector: Contains a shifted (i.e. zero-padded) hanning window.\n\nExamples\n\njulia> p100(; sfreq = 200)\n30-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.37725725642960045\n 0.22652592093878665\n 0.10542974530180327\n 0.02709137914968268\n 0.0\n\nSee also p300, n170, n400, hanning.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.p300-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.p300","text":"p300(; sfreq = 100)\n\nGenerate a Hanning window mimicking a P300 EEG component with a peak at 300ms and a width of 300ms.\n\nKeyword arguments\n\nsfreq = 100: Sampling frequency in Hz.\n\nReturns\n\nVector: Contains a shifted (i.e. zero-padded) hanning window.\n\nExamples\n\njulia> p300(; sfreq = 150)\n67-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ⋮\n 0.07937323358440934\n 0.04518400232274078\n 0.02025351319275137\n 0.005089279059533658\n 0.0\n\nSee also p100, n170, n400, hanning.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}","page":"API / Docstrings","title":"UnfoldSim.pad_array","text":"pad_array(arr::Vector, len::Int, val)    \npad_array(arr::Vector, len::Tuple, val)\n\nPads the input array arr with a specified value val either before or after the existing elements, based on the sign of len.\n\nArguments\n\narr::Vector: The input array to be padded.\nlen::Union{Int, Tuple}: The number of times that val should be added.   If len is negative, the values are added before the existing array. Otherwise, they are added after the existing array.   If len is a tuple, pad_array is called twice which enables padding the array before and after in one function call.\nval: The value to be used for padding.\n\nReturns\n\nVector: Padded vector with the new length length(arr) + sum(abs.(len)).\n\nExamples\n\n# Create an array that will be padded\njulia> my_array = rand(5)\n5-element Vector{Float64}:\n 0.0420017254437951\n 0.19179144973603235\n 0.5388760239550549\n 0.6973699906283798\n 0.9966598131018376\n\n # Pad the array with zeros before the original array\njulia> pad_array(my_array, -2, 0)\n7-element Vector{Float64}:\n 0.0\n 0.0\n 0.0420017254437951\n 0.19179144973603235\n 0.5388760239550549\n 0.6973699906283798\n 0.9966598131018376\n\n# Pad the array with the value 5 before and after the original array\njulia> pad_array(my_array, (-2, 1), 5)\n8-element Vector{Float64}:\n 5.0\n 5.0\n 0.0420017254437951\n 0.19179144973603235\n 0.5388760239550549\n 0.6973699906283798\n 0.9966598131018376\n 5.0\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}","page":"API / Docstrings","title":"UnfoldSim.predef_2x2","text":"predef_2x2(rng::AbstractRNG; <keyword arguments>)\n\nSimulate data for a 2x2 design i.e. a design with two conditions with two levels each.\n\nNote that this function is mainly used for demonstration and internal testing purposes or whenever a quick simulation is needed. \n\nThe most used keyword argument is: return_epoched = true which returns already epoched data. If you want epoched data without overlap, specify onset = NoOnset() and return_epoched = true. \n\nBe careful if you modify n_items with n_subjects = 1, n_items has to be a multiple of 4 (or your equivalent conditions factorial, e.g. all combinations length).\n\nIn difference to predef_EEG, predef_2x2 is sample based (no sampling rate to be specified), and also has a 2x2 design, instead of a 2-categorical, 1-continuous design.\n\nKeyword arguments\n\nDesign\n\nn_items = 100: Number of items.\nn_subjects = 1: Number of subjects.\nconditions = Dict(:A => [\"a_small\",\"a_big\"], :B => [\"b_tiny\",\"b_large\"]): Experimental conditions with their levels.\nevent_order_function = shuffle: Random trial order.\n\nComponent / Signal\n\nsignalsize = 100: Length of simulated hanning window.\nbasis = hanning(signalsize): The actual \"function\". signalsize is only used here.\nβ = [1, -0.5, .5, +1]: The parameters for the fixed effects.\nσs = Dict(:subject => [1, 0.5, 0.5, 0.5],:item => [1]): Only needed in n_subjects >= 2 cases; specifies the random effects.\ncontrasts = Dict(:A => EffectsCoding(), :B => EffectsCoding()): Effect coding by default.\nformula = n_subjects == 1 ? @formula(0 ~ 1 + A*B) : @formula(dv ~ 1 + A*B + (A*B|subject) + (1|item)): Model formula with interaction.\n\nOnset\n\noverlap = (0.5,0.2),\nonset = UniformOnset(; offset = signalsize * overlap[1], width = signalsize * overlap[2]), # Put offset to 1 for no overlap. put width to 0 for no jitter\n\nNoise\n\nnoiselevel = 0.2.\nnoise = PinkNoise(; noiselevel = noiselevel).\n\nOther parameters\n\nreturn_epoched = false: If true, already epoched data is returned. Otherwise, continuous data is returned.\n\nReturns\n\n(data, events)::Tuple{Array, DataFrame}: \ndata contains the simulated EEG data. Its dimensionality depends on the status of return_epoched and whether nsubjects >=2: `continuoustime,continuoustime x nsubjects,times x size(design)[1]ortimes x size(design)[1] x n_subjects`. \nevents contains the event combinations based on the experimental design. Each row corresponds to one combination of condition levels which is often equivalent to one stimulus or trial.\n\nExamples\n\njulia> data, events = UnfoldSim.predef_2x2();\n\njulia> events\n100×3 DataFrame\n Row │ A        B        latency \n     │ String   String   Int64   \n─────┼───────────────────────────\n   1 │ a_small  b_large       62\n   2 │ a_big    b_tiny       132\n  ⋮  │    ⋮        ⋮        ⋮\n  99 │ a_big    b_large     5883\n 100 │ a_big    b_tiny      5935\n                  96 rows omitted\n\njulia> data\n6035-element Vector{Float64}:\n  0.32384561187165956\n  0.4108799249488322\n  0.4715514814540277\n  0.5936253009785152\n  ⋮\n  0.047664408295942984\n  0.051193074728432035\n -0.08951617593287822\n -0.14456000097460356\n\nSee also predef_eeg.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_eeg-Tuple{Any}","page":"API / Docstrings","title":"UnfoldSim.predef_eeg","text":"predef_eeg(; <keyword arguments>)\npredef_eeg(rng; <keyword arguments>)\npredef_eeg(rng, n_subjects; <keyword arguments>)\n\nSimulate data for a P1/N1/P3 component complex.\n\nNote that this function is mainly used for demonstration and internal testing purposes or whenever a quick simulation is needed. \n\nIn case n_subjects is defined - MixedModelComponents are generated (multi-subject simulation), else LinearModelComponents (single-subject simulation). \n\nThe most used keyword argument is: return_epoched = true which returns already epoched data. If you want epoched data without overlap, specify onset = NoOnset() and return_epoched = true.\n\nKeyword arguments\n\nDesign\n\nn_repeats = 100: Number of times the experimental design is repeated. Only used in the single-subject case.\nn_items = 100: Number of items. Only used in the multi-subject case.\nevent_order_function = shuffle: Random trial order. Use event_order_function = (rng, x) -> x to deactivate.\nconditions = Dict(:condition => [\"car\", \"face\"], :continuous => range(-5, 5, length = 10)): Conditions and covariates used in this predefined design.\n\nComponent / Signal\n\nsfreq = 100: Sampling frequency.\np1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()): P1 with amplitude 5; no effects.\nn1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 3], Dict()): N1 with amplitude 5, dummy-coded condition effect (levels \"car\", \"face\") of 3.\np3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5, 1], Dict()): P3 with amplitude 5, continuous effect range [-5,5] with slope 1.\n\nOnset\n\noverlap = (0.5,0.2), # convenient parameterization for the default onset::UniformOnset. (offset, width) in seconds. If you do not want any overlap, either use onset=NoOnset(), or put the offset to a value larger than the maximum used component length, e.g. overlap=(1,0.2). Put the width to 0 to have no jitter between events.\nonset = UniformOnset(; offset = sfreq * 0.5 * overlap[1], width = sfreq * 0.5 * overlap[2]), \n\nNoise\n\nnoiselevel = 0.2.\nnoise = PinkNoise(; noiselevel = noiselevel).\n\nOther parameters\n\nreturn_epoched = false: If true, already epoched data is returned. Otherwise, continuous data is returned.\n\nReturns\n\n(data, events)::Tuple{Array, DataFrame}: \ndata contains the simulated EEG data. Its dimensionality depends on the status of return_epoched and whether it's a single- or multisubject simulation (1D, 2D or 3D array): continuous_time, continuous_time x n_subjects, times x size(design)[1] or times x size(design)[1] x n_subjects. \nevents contains the event combinations based on the experimental design. Each row corresponds to one combination of condition/covariate levels which is often equivalent to one stimulus or trial.\n\nExamples\n\njulia> data, events = UnfoldSim.predef_eeg();\n\njulia> events\n2000×3 DataFrame\n  Row │ continuous  condition  latency \n      │ Float64     String     Int64   \n──────┼────────────────────────────────\n    1 │   2.77778   car             62\n    2 │  -5.0       face           132\n  ⋮   │     ⋮           ⋮         ⋮\n 1999 │  -0.555556  face        120096\n 2000 │  -2.77778   car         120154\n\njulia> data\n120199-element Vector{Float64}:\n  0.31631798033146774\n  0.40338935529989906\n  0.46409775558165056\n  0.5862082040156747\n  ⋮\n -0.1879589005111152\n -0.3163314509311509\n -0.22230944464885682\n -0.01320095208877194\n\nSee also predef_2x2.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate","page":"API / Docstrings","title":"UnfoldSim.simulate","text":"simulate(\nrng::AbstractRNG,\ndesign::AbstractDesign,\ncomponents,\nonset::AbstractOnset,\nnoise::AbstractNoise = NoNoise();\nreturn_epoched = false,\n)\n\nsimulate(\ndesign::AbstractDesign,\ncomponents,\nonset::AbstractOnset,\nnoise::AbstractNoise = NoNoise();\nreturn_epoched = false,\n)\n\nSimulate continuous or epoched signal, given design, [Array of] component, onset and  optional noise and rng. Main simulation function.\n\nArguments\n\nrng::AbstractRNG (optional): Random number generator, important to ensure reproducibility.\ndesign::AbstractDesign: Desired experimental design.\ncomponents: Component(s) for the desired signal.\nonset::AbstractOnset: Desired inter-onset distance distribution.\nnoise::AbstractNoise = NoNoise() (optional): Desired noise.\n\nKeyword arguments\n\nreturn_epoched::Bool = false: If set to true epoched data is returned, otherwise a continuous signal is returned (see also Notes below).\n\nReturns\n\n(signal, events)::Tuple{Array, DataFrame}:\nsignal : Generated signal. Depending on the design, on the components and on    return_epoched, the output can be a 1-D, 2-D, 3-D or 4-D Array.    For example, a 4-D Array would have the dimensions channels x time x trials x subjects.\nevents: Generated events data frame with latencies.\n\nExamples\n\nAdapted from the quickstart tutorial in the UnfoldSim docs.\n\njulia> using Random # to get an RNG\n\njulia> design =\n    SingleSubjectDesign(; conditions = Dict(:cond_A => [\"level_A\", \"level_B\"])) |>\n    x -> RepeatDesign(x, 10);\n\njulia> component = LinearModelComponent(; \n    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + cond_A),\n    β = [1, 0.5],\n);\n\njulia> onset = UniformOnset(; width = 20, offset = 4);\n\njulia> noise = PinkNoise(; noiselevel = 0.2);\n\n# Variant 1: Use a custom RNG.\njulia> data, events = simulate(MersenneTwister(2), design, component, onset, noise);\n\njulia> data\n293-element Vector{Float64}:\n -0.013583193323430123\n  0.09159433856866195\n  ⋮\n -0.25190584567097907\n -0.20179992275876316\n\njulia> events\n20×2 DataFrame\n Row │ cond_A   latency \n     │ String   Int64   \n─────┼──────────────────\n   1 │ level_A        9\n   2 │ level_B       20\n   3 │ level_A       27\n   4 │ level_B       37\n  ⋮  │    ⋮        ⋮\n  18 │ level_B      257\n  19 │ level_A      271\n  20 │ level_B      284\n         13 rows omitted\n\n# Variant 2: Without specifying an RNG, MersenneTwister(1) will be used for the simulation.\njulia> data1, events1 = simulate(design, component, onset, noise);\n┌ Warning: No random generator defined, used the default (`Random.MersenneTwister(1)`) with a fixed seed. This will always return the same results and the user is strongly encouraged to provide their own random generator!\n\nNotes\n\nSome remarks on how the noise is added:\n\nIf return_epoched = true and onset = NoOnset() the noise is added to the epoched data matrix.\nIf onset is not NoOnset, a continuous signal is created and the noise is added to this    i.e. this means that the noise won't be the same as in the onset = NoOnset() case even if return_epoched = true.\nThe case return_epoched = false and onset = NoOnset() is not possible and therefore    covered by an assert statement.\n\nAdditional remarks on the overlap of adjacent signals when return_epoched = true:\n\nIf onset = NoOnset() there will not be any overlapping signals in the data because the onset calculation and conversion to a continuous signal is skipped.\nIf an inter-onset distance distribution is given, a continuous signal(potentially with overlap) is constructed and partitioned into epochs afterwards.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}","page":"API / Docstrings","title":"UnfoldSim.simulate_and_add!","text":"simulate_and_add!(epoch_data::AbstractMatrix, c, simulation, rng)\nsimulate_and_add!(epoch_data::AbstractArray, c, simulation, rng)\n\nHelper function to call simulate_component and add it to a provided Array epoch_data.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::AbstractComponent, simulation::Simulation)\n\nBy default call simulate_component with (rng, c::Abstractcomponent, design::AbstractDesign) instead of the whole simulation. This function exist solely to provide a \"hook\" if for a custom component something else than the design is necessary, e.g. a dependency on the onsets, noise or similar.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::LinearModelComponent, design::AbstractDesign)\n\nGenerate a linear model design matrix, weight it by the coefficients c.β and multiply the result with the given basis vector.\n\nReturns\n\nMatrix{Float64}: Simulated component for each event in the events data frame. The output dimensions are length(c.basis) x length(design).\n\nExamples\n\njulia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c = UnfoldSim.LinearModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond), [1, 2], Dict());\n\njulia> using StableRNGs\n\njulia> simulate_component(StableRNG(1), c, design)\n4×2 Matrix{Float64}:\n 0.0  0.0\n 3.0  1.0\n 3.0  1.0\n 0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::MixedModelComponent, design::AbstractDesign, return_parameters = false)\n\nGenerate a MixedModel and simulate data according to the given parameters c.β and c.σs.\n\nKeyword arguments\n\nreturn_parameters::Bool = false: Can be used to return the per-event parameters used to weight the basis function. Sometimes useful to inspect what is simulated.\n\nReturns\n\nMatrix{Float64}: Simulated component for each event in the events data frame. The output dimensions are length(c.basis) x length(design).\n\nNotes\n\nMixedModels/Sim does not allow simulation of data without white noise of the residuals. Because we want our own noise, we use the following trick to remove the MixedModels-Noise:\n\nPractically, we upscale the specified σs by factor 10000, and request a white-noise-level of σ = 0.0001. Internally in MixedModels/Sim, σs are relative to σ, and thus are normalized correctly, while keeping the noise 10000 times smaller than the random effects\n\nWe cannot exclude that this trick runs into strange numerical issues if the random effect σs are very large compared to the fixed effects.\n\nCurrently, it is not possible to use a different basis for fixed and random effects. If this is needed, some code-scaffold is available but commented out at the moment and requires a bit of implementation work.\n\nExamples\n\njulia> design = MultiSubjectDesign(; n_subjects = 2, n_items = 6, items_between = Dict(:cond => [\"A\", \"B\"]));\n\njulia> c = UnfoldSim.MixedModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond + (1|subject)), [1, 2], Dict(:subject => [2],), Dict());\n\njulia> using StableRNGs\n\njulia> simulate_component(StableRNG(1), c, design)\n4×12 Matrix{Float64}:\n -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0\n -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565\n -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565\n -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0\n\njulia> simulate_component(StableRNG(1), c, design, return_parameters = true)\n1×12 Matrix{Float64}:\n -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::MultichannelComponent, design::AbstractDesign)\n\nReturn the projection of a MultichannelComponent c from \"source\" to \"sensor\" space.\n\nReturns\n\nArray{Float64,3}: Projected simulated component for each event in the events data frame. The output dimensions are length(c.projection) x length(c.basis) x length(design).\n\nExamples\n\njulia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);\njulia> mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1], PinkNoise());\n\njulia> using StableRNGs\n\njulia> simulate_component(StableRNG(1), mc, design)\n7×15×2 Array{Float64, 3}:\n[:, :, 1] =\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662\n  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.7484    3.53412   5.53942   4.0612    2.34858   2.01845   2.19039   1.50932    4.51324\n -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.3742   -1.76706  -2.76971  -2.0306   -1.17429  -1.00922  -1.09519  -0.754659  -2.25662\n  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   4.1226    5.30118   8.30913   6.09179   3.52287   3.02767   3.28558   2.26398    6.76985\n  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.871     8.8353   13.8485   10.153     5.87145   5.04612   5.47597   3.7733    11.2831\n  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.16066   4.06424   6.37033   4.67037   2.70087   2.32121   2.51894   1.73572    5.19022\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662\n\n[:, :, 2] =\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662\n  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.63142   3.12094   4.78942   3.09135   1.37873    1.26845    1.77721    1.39234   4.51324\n -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.31571  -1.56047  -2.39471  -1.54567  -0.689367  -0.634223  -0.888605  -0.69617  -2.25662\n  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   3.94713   4.68142   7.18413   4.63702   2.0681     1.90267    2.66582    2.08851   6.76985\n  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.57855   7.80236  11.9735    7.72837   3.44684    3.17112    4.44303    3.48085  11.2831\n  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.02613   3.58909   5.50783   3.55505   1.58554    1.45871    2.04379    1.60119   5.19022\n  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_interonset_distances","page":"API / Docstrings","title":"UnfoldSim.simulate_interonset_distances","text":"simulate_interonset_distances(rng, onset::AbstractOnset, design::AbstractDesign)\n\nGenerate the inter-onset distance vector by sampling from the respective distribution (in samples).\n\nArguments\n\nrng: Random number generator (RNG) to make the process reproducible.\nonset::AbstractOnset: Inter-onset distance distribution to sample from.\ndesign::AbstractDesign: Experimental design with conditions and covariates.\n\nReturns\n\nVector{Integer}: Inter-onset distances in samples. Note that these are distances between onsets and no latencies.\n\nExamples\n\n# Create an experimental design\njulia> design_single = SingleSubjectDesign(;\n           conditions = Dict(\n               :stimulus_type => [\"natural\", \"artificial\"],\n               :contrast_level => range(0, 1, length = 3),\n           ),\n       );\n\n# Create an inter-onset distance distribution\njulia> onset_distribution = LogNormalOnset(3, 0.5, 5, nothing);\n\njulia> using StableRNGs\n\njulia> simulate_interonset_distances(StableRNG(1), onset_distribution, design_single)\n6-element Vector{Int64}:\n 20\n 26\n 34\n 18\n 12\n 23\n\nSee also simulate_onsets.\n\n\n\n\n\n","category":"function"},{"location":"api/#UnfoldSim.simulate_noise","page":"API / Docstrings","title":"UnfoldSim.simulate_noise","text":"simulate_noise(rng, t::AbstractNoise, n::Int)\n\nGenerate noise samples of the given type t.\n\nFor details, see the documentation of the individual noise types. Use subtypes(AbstractNoise) for a list of the implemented noise types.\n\nArguments\n\nrng::AbstractRNG: Random number generator (RNG) to make the process reproducible.\nt::AbstractNoise: Instance of a noise type e.g. PinkNoise().\nn::Int: The number of noise samples that should be generated.\n\nReturns\n\nVector: Vector of length n containing the noise samples.\n\nExamples\n\n# Here we use White Noise as an example but it works in the same way for the other noise types.\njulia> noise = WhiteNoise()\nWhiteNoise\n  noiselevel: Int64 1\n  imfilter: Int64 0\n\njulia> using StableRNGs\n\njulia> simulate_noise(StableRNG(1), noise, 3)\n3-element Vector{Float64}:\n -0.5325200748641231\n  0.098465514284785\n  0.7528865221245234\n\n\n\n\n\n","category":"function"},{"location":"api/#UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}","page":"API / Docstrings","title":"UnfoldSim.simulate_onsets","text":"simulate_onsets(rng, onset::AbstractOnset, simulation::Simulation)\n\nCall simulate_interonset_distances to generate distances between events and then add them up to generate the actual latencies in samples.\n\nPlease note that this function is mainly for internal use in the context of simulate function calls. \n\nAlso note that the accumulation of onsets starts at 1 to avoid indexing problems in the case that the first sampled onset is 0.\n\nArguments\n\nrng: Random number generator (RNG) to make the process reproducible.\nonset::AbstractOnset: Inter-onset distance distribution which is passed to simulate_interonset_distances.\nsimulation::Simulation: Simulation object which contains design, component(s), inter-onset distance distribution and noise.\n\nReturns\n\nExamples\n\n# Create Simulation object\njulia> design_single = SingleSubjectDesign(;\n           conditions = Dict(\n               :stimulus_type => [\"natural\", \"artificial\"],\n               :contrast_level => range(0, 1, length = 3),\n           ),\n       );\n\njulia> p1_component = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [5]);\n\njulia> simulation = Simulation(design_single, p1_component, UniformOnset(), NoNoise());\n\njulia> using StableRNGs\n\n# Simulate onsets for this simulation\njulia> simulate_onsets(StableRNG(1), simulation.onset, simulation)\n6-element Vector{Int64}:\n  20\n  70\n  97\n 110\n 150\n 182\n\nSee also simulate_interonset_distances.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_responses-Tuple{Any, Vector{<:AbstractComponent}, Simulation}","page":"API / Docstrings","title":"UnfoldSim.simulate_responses","text":"simulate_responses(\n    rng,\n    components::Vector{<:AbstractComponent},\n    simulation::Simulation)\n\nSimulate multiple component responses and accumulate them on a per-event basis.\n\nReturns\n\nepoch_data: Matrix (or Array in the multi-channel case) of combined simulated components.   The output dimensions are maxlength(components) x length(simulation.design) for single-channel components and   n_channels(components) x maxlength(components) x length(simulation.design) for multi-channel components.\n\nExamples\n\njulia> design = SingleSubjectDesign(; conditions = Dict(:cond => [\"natural\", \"artificial\"]));\n\njulia> c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);\njulia> c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [2]);\n\njulia> simulation = Simulation(design, [c1, c2], UniformOnset(; width = 0, offset = 30), PinkNoise());\n\njulia> using StableRNGs\n\njulia> simulate_responses(StableRNG(1), [c1, c2], simulation)\n45×2 Matrix{Float64}:\n 0.0        0.0\n 0.0        0.0\n 0.0        0.0\n 0.0        0.0\n 0.0        0.0\n ⋮          \n 0.352614   0.352614\n 0.203907   0.203907\n 0.0924246  0.0924246\n 0.0233794  0.0233794\n 0.0        0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.weight_σs-Tuple{Dict, Float64, Float64}","page":"API / Docstrings","title":"UnfoldSim.weight_σs","text":"weight_σs(σs::Dict, b_σs::Float64, σ_lmm::Float64)\n\nWeight a σs Dict for MixedModels.jl by b_σs, a scaling factor typically from a basis.\n\nFinally scales it again by σ_lmm, as a trick to simulate noise-free LMMs (see MixedModelsComponent)\n\nIn the future, we anticipate a function     function weight_σs(σs::Dict,b_σs::Dict,σ_lmm::Float64) where each σs entry can be weighted individually by a matching b_σs, but it is not implemented.\n\nArguments\n\nσs::Dict = a Dict of random effects as output of MixedModels.create_re\nb_σs::Float64 = a scaling factor, typically one entry of a basis function from a component\nσ_lmm::Float64 = a scaling factor to simulate near-zero noise LMMs\n\nReturns\n\n`NamedTuple` of the weighted random effects\n\n\n\n\n\n","category":"method"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"EditURL = \"../../../literate/reference/noisetypes.jl\"","category":"page"},{"location":"generated/reference/noisetypes/#Overview:-Noise-types","page":"Overview: Noise types","title":"Overview: Noise types","text":"","category":"section"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"There are different types of noise signals which differ in their power spectra. If you are not familiar with different types/colors of noise yet, have a look at the colors of noise Wikipedia page.","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"There are several noise types directly implemented in UnfoldSim.jl. Here is a comparison:","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"using UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs\nimport StatsBase.autocor\n\nf = Figure()\nax_sig =\n    f[1, 1:3] =\n        Axis(f; title = \"1.000 samples of noise\", xlabel = \"Time\", ylabel = \"Amplitude\")\nax_spec =\n    f[2, 1:2] = Axis(\n        f;\n        title = \"Welch Periodogram\",\n        xlabel = \"Normalized frequency\",\n        ylabel = \"log(Power)\",\n    )\nax_auto =\n    f[2, 3:4] = Axis(\n        f;\n        title = \"Autocorrelogram (every 10th lag)\",\n        xlabel = \"Lag\",\n        ylabel = \"Autocorrelation\",\n    )\nfor n in [PinkNoise RedNoise WhiteNoise NoNoise ExponentialNoise]\n\n    # generate\n    noisevec = simulate_noise(StableRNG(1), n(), 10000)\n\n    # plot 1000 samples\n    lines!(ax_sig, noisevec[1:1000]; label = string(n))\n\n    # calc spectrum\n    perio = welch_pgram(noisevec)\n\n    # plot spectrum\n    lines!(ax_spec, freq(perio), log10.(power(perio)))\n\n    lags = 0:10:500\n    autocor_vec = autocor(noisevec, lags)\n    lines!(ax_auto, lags, autocor_vec)\n\nend\nf[1, 4] = Legend(f, ax_sig, \"Noise type\", tellheight = true)\nf","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"hint: Hint\nWe recommed for smaller signals the ExponentialNoise, maybe with a removed DC offset or a HighPass filter. For long signals, this Noise requires lots of memory though. maybe Pinknoise is a better choice then.","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"EditURL = \"../../../literate/reference/basistypes.jl\"","category":"page"},{"location":"generated/reference/basistypes/#Overview:-Basis-function-(component)-types","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"There are several basis types directly implemented. They can be easily used for the components.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"note: Note\nYou can use any arbitrary shape defined by yourself! We often make use of hanning(50) from the DSP.jl package.","category":"page"},{"location":"generated/reference/basistypes/#Setup","page":"Overview: Basis function (component) types","title":"Setup","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"# Load required packages\nusing UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"</details >","category":"page"},{"location":"generated/reference/basistypes/#EEG","page":"Overview: Basis function (component) types","title":"EEG","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"By default, the EEG bases assume a sampling rate of 100, which can easily be changed by e.g. p100(; sfreq=300)","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"f = Figure()\nax = f[1, 1] = Axis(f)\nfor b in [p100, n170, p300, n400]\n    lines!(ax, b(), label = string(b))\n    scatter!(ax, b(), label = string(b))\nend\naxislegend(ax, merge = true)\nf","category":"page"},{"location":"generated/reference/basistypes/#fMRI","page":"Overview: Basis function (component) types","title":"fMRI","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"default hrf TR is 1. Get to know all your favourite shapes!","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"##--\nf = Figure()\nplotConfig = (\n    :peak => 1:3:10,\n    :post_undershoot => 10:5:30,\n    :amplitude => 2:5,\n    :shift => 0:3:10,\n    :peak_width => 0.1:0.5:1.5,\n    :post_undershoot_width => 0.1:0.5:1.5,\n)\n\nfor (ix, pl) in enumerate(plotConfig)\n    col = (ix - 1) % 3 + 1\n    row = Int(ceil(ix / 3))\n\n    ax = f[row, col] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.hrf(; TR = 0.1, (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/#Pupil","page":"Overview: Basis function (component) types","title":"Pupil","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"We use the simplified PuRF from Hoeks & Levelt, 1993. Note that https://www.science.org/doi/10.1126/sciadv.abi9979 show some evidence in their supplementary material, that the convolution model is not fully applicable.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"f = Figure()\nplotConfig = (:n => 5:3:15, :tmax => 0.5:0.2:1.1)\n\nfor (ix, pl) in enumerate(plotConfig)\n    ax = f[1, ix] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.PuRF(; (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"EditURL = \"../../../literate/tutorials/poweranalysis.jl\"","category":"page"},{"location":"generated/tutorials/poweranalysis/#Power-analysis","page":"Power analysis","title":"Power analysis","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"For a power analysis, we will repeatedly simulate data, and check whether we can find a significant effect. We perform the power analysis on epoched data.","category":"page"},{"location":"generated/tutorials/poweranalysis/#Setup","page":"Power analysis","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"# Load required packages\nusing UnfoldSim\nusing Statistics\nusing HypothesisTests\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"</details >\n<br />","category":"page"},{"location":"generated/tutorials/poweranalysis/#Simulation-loop","page":"Power analysis","title":"Simulation loop","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"pvals = fill(NaN, 100)\n@time for seed in eachindex(pvals)\n    # Simulate data of 30 subjects\n    data, evts = UnfoldSim.predef_2x2(\n        MersenneTwister(seed);\n        n_subjects = 20, ## 30 subjects\n        overlap = (1, 0), ## deactivate overlap\n        noiselevel = 10,  ## add more noise to make it more challenging\n        return_epoched = true, ## saves us the epoching step\n    )\n\n\n    # take the mean over a pre-specified timewindow\n    evts.y = dropdims(mean(data[40:60, :, :], dims = 1), dims = (1))[:]\n\n    # extract the two levels of condition A\n    evts_reduced = combine(groupby(evts, [:subject, :A]), :y => mean)\n    y_big = evts_reduced[evts_reduced.A.==\"a_big\", :y_mean]\n    y_small = evts_reduced[evts_reduced.A.==\"a_small\", :y_mean]\n\n    # calculate a one-sided t-test\n    pvals[seed] = pvalue(OneSampleTTest(y_big, y_small))\nend","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"Let's calculate the power","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"power = mean(pvals .< 0.05) * 100","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"EditURL = \"../../../literate/reference/designtypes.jl\"","category":"page"},{"location":"generated/reference/designtypes/#Overview:-Experimental-design-types","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The experimental design specifies the experimental conditions and other variables that are supposed to have an influence on the simulated data. Currently, there are three types of designs implemented: SingleSubjectDesign, MultiSubjectDesign and RepeatDesign.","category":"page"},{"location":"generated/reference/designtypes/#Setup","page":"Overview: Experimental design types","title":"Setup","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"# Load required packages\nusing UnfoldSim\nusing Random","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >","category":"page"},{"location":"generated/reference/designtypes/#Single-subject-designs","page":"Overview: Experimental design types","title":"Single-subject designs","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"As the name suggests, the SingleSubjectDesign type can be used to specify the experimental design for a single subject. Using the conditions arguments, the user can specify all relevant conditions or predictors and their levels or value range.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The current implementation assumes a full factorial design (also called fully crossed design) in which each level of a factor occurs with each level of the other factors. Moreover, in the current implementation, there is exactly one instance of each of these factor combinations.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"Example:","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_single = SingleSubjectDesign(;\n    conditions = Dict(\n        :stimulus_type => [\"natural\", \"artificial\"],\n        :contrast_level => range(0, 1, length = 3),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"In order to inspect the design, we can use the generate_events function to create an event table based on the design we specified.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_single)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"To change the order of the trials e.g. to sort or shuffle them, one can use the event_order_function argument. Example: Randomize the order of trials","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_single_shuffled = SingleSubjectDesign(;\n    conditions = Dict(\n        :stimulus_type => [\"natural\", \"artificial\"],\n        :contrast_level => range(0, 1, length = 3),\n    ),\n    event_order_function = shuffle,\n);\nnothing #hide","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand event table </summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_single_shuffled)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >","category":"page"},{"location":"generated/reference/designtypes/#Multi-subject-designs","page":"Overview: Experimental design types","title":"Multi-subject designs","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The MultiSubjectDesign type can be used to simulate data for an experiment with multiple subjects. Internally, it uses the MixedModelsSim.jl package. One needs to specify the number of subjects n_subjects and the number of items n_items i.e. stimuli. In addition, one needs to decide for every experimental factor whether it should be between- or within-subject (and item).","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"note: Note\nFor factors that are not listed in items_between it is assumed that they vary within-item (accordingly for subjects_between).","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_multi = MultiSubjectDesign(\n    n_subjects = 6,\n    n_items = 4,\n    items_between = Dict(:colour => [\"red\", \"blue\"]),\n    subjects_between = Dict(:age_group => [\"young\", \"old\"]),\n    both_within = Dict(:luminance => range(0, 1, length = 3)),\n);\nnothing #hide","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand event table </summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_multi)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >\n<br />","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"As with the SingleSubjectDesign one can use the event_order_function argument to determine the order of events/trials.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"important: Important\nThe number of subjects/items has to be a divisor of the number of factor level combinations, i.e. it is assumed that the design is balanced which means that there is an equal number of observations for all possible factor level combinations.","category":"page"},{"location":"generated/reference/designtypes/#Repeat-designs","page":"Overview: Experimental design types","title":"Repeat designs","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The RepeatDesign type is a functionality to encapsulate single- or multi-subject designs. It allows to repeat a generated event table multiple times. In other words, the RepeatDesign type allows to have multiple instances of the same item/subject/factor level combination.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"Example: Assume, we have the following single-subject design from above:","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand event table </summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_single)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >\n<br />","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"But instead of having only one instance of the factor combinations e.g. stimulus_type: natural and contrast_level: 0, we will repeat the design three times such that there are three occurrences of each combination.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_repeated = RepeatDesign(design_single, 3);\ngenerate_events(design_repeated)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"Here one can find another example of how to repeat design entries for multi-subject designs.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"EditURL = \"../../../literate/reference/onsettypes.jl\"","category":"page"},{"location":"generated/reference/onsettypes/#Overview:-Onset-types","page":"Overview: Onset types","title":"Overview: Onset types","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The onset types determine the distances between event onsets in the continuous EEG signal. The distances are sampled from a certain probability distribution. Currently, there are two types of onset distributions implemented: UniformOnset and LogNormalOnset.","category":"page"},{"location":"generated/reference/onsettypes/#Setup","page":"Overview: Onset types","title":"Setup","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"# Load required packages\nusing UnfoldSim\nusing CairoMakie\nusing Random\n\n# Define a simple design and repeat it 10000.\n# This will result in 20000 events i.e. event onsets.\ndesign =\n    SingleSubjectDesign(conditions = Dict(:cond => [\"A\", \"B\"])) |>\n    x -> RepeatDesign(x, 10000);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#UniformOnset","page":"Overview: Onset types","title":"UniformOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The UniformOnset is based on a uniform distribution and has two parameters: width and offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"onset_uniform = UniformOnset(; width = 50, offset = 0);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The width parameter defines the upper bound of the interval of the uniform distribution (its lower bound is 0) i.e. all values between 0 and width are equally probable.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the uniform distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let # hide\n    f = Figure() # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((50, 0), (80, 0)), \"width\"), # hide\n        (((50, 0), (50, 20)), \"offset\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for width and one for offset # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (width, offset) in combinations # hide\n            distances = UnfoldSim.simulate_interonset_distances( # hide\n                MersenneTwister(42), # hide\n                UniformOnset(; width = width, offset = offset), # hide\n                design, # hide\n            ) # hide\n\n            hist!( # hide\n                ax, # hide\n                distances, # hide\n                bins = range(0, 100, step = 1), # hide\n                label = \"($width, $offset)\", # hide\n            ) # hide\n\n            if label == \"offset\" && offset != 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let\n    f = Figure()\n\n    # Define parameter combinations\n    parameters = [(((50, 0), (80, 0)), \"width\"), (((50, 0), (50, 20)), \"offset\")]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for width and one for offset\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (width, offset) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                UniformOnset(; width = width, offset = offset),\n                design,\n            )\n\n            hist!(ax, onsets, bins = range(0, 100, step = 1), label = \"($width, $offset)\")\n\n            if label == \"offset\" && offset != 0\n                vlines!(offset, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#LogNormalOnset","page":"Overview: Onset types","title":"LogNormalOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The LogNormalOnset is based on a log-normal distribution and has four parameters: μ, σ, offset and truncate_upper.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"onset_lognormal = LogNormalOnset(; μ = 3, σ = 0.25, offset = 0, truncate_upper = nothing);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The parameters μ and σ are the location and scale parameter of the log-normal distribution. However, they are not identical to its mean and standard deviation. If a variable X is log-normally distributed then Y = ln(X) is normally distributed with mean μ and standard deviation σ[1].","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the log-normal distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The truncate_upper parameter allows to truncate the distribution at a certain sample value. Its default value is nothing, i.e. no truncation.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let # hide\n    f = Figure(size = (600, 800)) # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (μ, σ, offset, truncate_upper) in combinations # hide\n            onsets = UnfoldSim.simulate_interonset_distances( # hide\n                MersenneTwister(42), # hide\n                LogNormalOnset(; # hide\n                    μ = μ, # hide\n                    σ = σ, # hide\n                    offset = offset, # hide\n                    truncate_upper = truncate_upper, # hide\n                ), # hide\n                design, # hide\n            ) # hide\n\n            hist!( # hide\n                ax, # hide\n                onsets, # hide\n                bins = range(0, 100, step = 1), # hide\n                label = \"($μ,$σ,$offset,$truncate_upper)\", # hide\n            ) # hide\n\n            if label == \"offset\" && offset !== 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing # hide\n                vlines!(truncate_upper, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let\n    f = Figure(size = (600, 800))\n\n    # Define parameter combinations\n    parameters = [\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"),\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"),\n    ]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (μ, σ, offset, truncate_upper) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                LogNormalOnset(;\n                    μ = μ,\n                    σ = σ,\n                    offset = offset,\n                    truncate_upper = truncate_upper,\n                ),\n                design,\n            )\n\n            hist!(\n                ax,\n                onsets,\n                bins = range(0, 100, step = 1),\n                label = \"($μ,$σ,$offset,$truncate_upper)\",\n            )\n\n            if label == \"offset\" && offset !== 0\n                vlines!(offset, color = \"black\")\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing\n                vlines!(truncate_upper, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#Overlap-of-subsequent-events","page":"Overview: Onset types","title":"Overlap of subsequent events","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"note: Note\nThe overlap of subsequent events can be indirectly controlled by setting the offset parameter relative to the length of the component basis.   Assuming that signal is a component e.g. LinearModelComponent,if offset > length(signal.basis) -> no overlap\nif offset < length(signal.basis) -> there might be overlap, depending on the other parameters of the onset distribution","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"[1]: Wikipedia contributors. (2023, December 5). Log-normal distribution. In Wikipedia, The Free Encyclopedia. Retrieved 12:27, December 7, 2023, from https://en.wikipedia.org/w/index.php?title=Log-normal_distribution&oldid=1188400077#","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"EditURL = \"../../../literate/reference/overview.jl\"","category":"page"},{"location":"generated/reference/overview/#Overview-of-functionality","page":"Overview of functionality","title":"Overview of functionality","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"A UnfoldSim simulation has four ingredients: Design, Component, Onset and Noise. Here we provide a short overview of the implemented types.","category":"page"},{"location":"generated/reference/overview/#Setup","page":"Overview of functionality","title":"Setup","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"# Load required packages\nusing UnfoldSim\nusing InteractiveUtils","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"</details>","category":"page"},{"location":"generated/reference/overview/#Design","page":"Overview of functionality","title":"Design","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Designs define the experimental design. They can be nested, e.g. RepeatDesign(SingleSubjectDesign,10) would repeat the generated design-dataframe 10x.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractDesign)","category":"page"},{"location":"generated/reference/overview/#Component","page":"Overview of functionality","title":"Component","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Components define a signal. Some components can be nested, e.g. LinearModelComponent|>MultichannelComponent, see the multi-channel tutorial for more information.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractComponent)","category":"page"},{"location":"generated/reference/overview/#Onsets","page":"Overview of functionality","title":"Onsets","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Onsets define the distance between events in the continuous signal.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractOnset)","category":"page"},{"location":"generated/reference/overview/#Noise","page":"Overview of functionality","title":"Noise","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Choose the noise you need!","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractNoise)","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"EditURL = \"../../../literate/tutorials/quickstart.jl\"","category":"page"},{"location":"generated/tutorials/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"To get started with data simulation, the user needs to provide four ingredients:","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"an experimental design, defining which conditions and how many events/\"trials\" exist\nan event basis function, defining the simulated event-related response for every event (e.g. the ERP shape in EEG)\nan inter-onset event distribution, defining the distances in time of the event sequence\na noise specification, defining the type of noise signal that is added to the simulated signal (e.g. pink noise)","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"tip: Tip\nUse subtypes(AbstractNoise) (or subtypes(AbstractComponent) etc.) to find already implemented building blocks.","category":"page"},{"location":"generated/tutorials/quickstart/#Specify-the-simulation-ingredients","page":"Quickstart","title":"Specify the simulation ingredients","text":"","category":"section"},{"location":"generated/tutorials/quickstart/#Setup","page":"Quickstart","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"# Load required packages\nusing UnfoldSim\nusing Random # to get an RNG\nusing CairoMakie # for plotting","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"</details >","category":"page"},{"location":"generated/tutorials/quickstart/#Experimental-Design","page":"Quickstart","title":"Experimental Design","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a 1 x 2 design with 20 trials. That is, one condition (cond_A) with two levels.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"design =\n    SingleSubjectDesign(; conditions = Dict(:cond_A => [\"level_A\", \"level_B\"])) |>\n    x -> RepeatDesign(x, 10);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Event-basis-function-(Component)","page":"Quickstart","title":"Event basis function (Component)","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a simple component and ground truth simulation formula. Akin to ERP components, we call one simulation signal a component.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nYou could easily specify multiple components by providing a vector of components, which are automatically added at the same onsets. This procedure simplifies to generate some response that is independent of simulated condition, whereas other depends on it.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"signal = LinearModelComponent(;\n    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + cond_A),\n    β = [1, 0.5],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Onsets-and-Noise","page":"Quickstart","title":"Onsets and Noise","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"We will start with a uniform (but overlapping, offset < length(signal.basis)) inter-onset distribution.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"onset = UniformOnset(; width = 20, offset = 4);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"And we will use some noise","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"noise = PinkNoise(; noiselevel = 0.2);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Combine-and-Generate","page":"Quickstart","title":"Combine & Generate","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Finally, we will combine all ingredients and simulate some data.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"data, events = simulate(MersenneTwister(1), design, signal, onset, noise);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"data is a n-sample Vector (but could be a Matrix for e.g. MultiSubjectDesign or epoched data).","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"events is a DataFrame that contains a column latency with the onsets of events (in samples).","category":"page"},{"location":"generated/tutorials/quickstart/#Plot-them!","page":"Quickstart","title":"Plot them!","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"lines(data; color = \"black\")\nvlines!(events.latency; color = [\"orange\", \"teal\"][1 .+ (events.cond_A.==\"level_B\")])\n\ncurrent_axis().title = \"Simulated data\"\ncurrent_axis().xlabel = \"Time [samples]\"\ncurrent_axis().ylabel = \"Amplitude [μV]\"\n\ncurrent_figure()","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"EditURL = \"../../../literate/HowTo/repeatTrials.jl\"","category":"page"},{"location":"generated/HowTo/repeatTrials/#howto_repeat_design","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"","category":"section"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"Sometimes we want to repeat a design, that is, have multiple trials with identical values, but it is not always straight forward to implement. For instance, there is no way to easily modify MultiSubjectDesign to have multiple identical subject/item combinations, without doing awkward repetitions of condition-levels or something.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"If you struggle with this problem RepeatDesign is an easy tool for you:","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"using UnfoldSim\n\ndesignOnce = MultiSubjectDesign(;\n    n_items = 2,\n    n_subjects = 2,\n    subjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n    items_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n);\n\ndesign = RepeatDesign(designOnce, 4);\ngenerate_events(design)","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"As you can see, the design was simply repeated.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"note: Note\nIf you implemented your own AbstractDesign, you need to define the size function accordingly. E.g.:   Base.size(design::RepeatDesign{SingleSubjectDesign}) = size(design.design).*design.repeat","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = UnfoldSim","category":"page"},{"location":"#UnfoldSim.jl-Documentation","page":"Home","title":"UnfoldSim.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to UnfoldSim.jl: a Julia package for simulating multivariate timeseries data with a focus on EEG, especially event-related potentials (ERPs).  The user provides four ingredients: 1) an experimental design, with both categorical and continuous variables, 2) event basis functions specified via linear or hierarchical models, 3) an inter-event onset distribution, and 4) a noise specification.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div style=\"width:60%; margin: auto;\">\n\n<img src=\"https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/assets/docs/src/assets/UnfoldSim_features_animation.gif?raw=true\"/>\n</div>","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modularity: Choose or implement different designs, components, onset distributions or noise types\nMulti-subject & complex experimental designs\nMulti-channel via EEG-forward models\nContinuous or epoched data with potentially overlapping signals\nPotential support for other modalities, e.g. single-voxel fMRI or pupil dilation","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"UnfoldSim\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailed instructions please refer to Installing Julia & UnfoldSim.jl.","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"#Start-simulating-time-series-data","page":"Home","title":"Start simulating time series data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We offer some predefined (EEG) signals, check them out! For instance, a P1/N170/P300 complex (containing three typical ERP components).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnfoldSim\nusing CairoMakie # plotting #hide\ndata, events = UnfoldSim.predef_eeg(; n_repeats = 1, noiselevel = 0.8)\n\nf = Figure(size = (900, 400)) #hide\nax = Axis( #hide\n    f[1, 1], #hide\n    title=\"Simulated EEG data\", #hide\n    titlesize=18, #hide\n    xlabel=\"Time [samples]\", #hide\n    ylabel=\"Amplitude [µV]\", #hide\n    xlabelsize=16, #hide\n    ylabelsize=16, #hide\n    xgridvisible=false, #hide\n    ygridvisible=false, #hide\n) #hide\n\ncolors = ifelse.(events.condition .== \"face\", :orange , :teal) #hide\n\nlines!(data; color=\"black\") #hide\nvlines!(events.latency; color=colors, label=events.condition) #hide\n\nxlims!(current_axis(), [0, 400]) #hide\n\ncurrent_figure() #hide","category":"page"},{"location":"#Or-simulate-epoched-data-directly","page":"Home","title":"Or simulate epoched data directly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\ndata, events = UnfoldSim.predef_eeg(; n_repeats = 20, noiselevel = 0.8, return_epoched = true)\n\nf2 = Figure(size = (900, 400)) #hide\nax = Axis( #hide\n    f2[1, 1], #hide\n    title=\"ERP image\", #hide\n    titlesize=18, #hide\n    xlabel=\"Time [samples]\", #hide\n    ylabel=\"Trials\", #hide\n    xlabelsize=16, #hide\n    ylabelsize=16, #hide\n    xgridvisible=false, #hide\n    ygridvisible=false, #hide\n) #hide\nhm = heatmap!(data[:, sortperm(events, [:condition, :continuous])]) #hide\nColorbar(f2[:, end+1], hm, label = \"Amplitude [µV]\") #hide\n\ncurrent_figure() #hide","category":"page"},{"location":"#Where-to-start:-Learning-roadmap","page":"Home","title":"Where to start: Learning roadmap","text":"","category":"section"},{"location":"#1.-First-steps","page":"Home","title":"1. First steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"📌 Goal: Learn about the simulation workflow and run your first simulation\n🔗 Quickstart | Simulate event-related potentials (ERPs)","category":"page"},{"location":"#2.-Intermediate-topics","page":"Home","title":"2. Intermediate topics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"📌 Goal: Learn about multi-subject and multi-channel simulations \n🔗 Multi-subject simulation | Generate multi channel data","category":"page"},{"location":"#3.-Advanced-topics","page":"Home","title":"3. Advanced topics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"📌 Goal: Learn how to implement your own experimental designs, components, etc.\n🔗 Define a new (imbalanced) design | Define a new component (with variable duration and shift) | Use existing experimental designs & onsets in the simulation","category":"page"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EEG researchers often analyze data containing (temporally) overlapping events (e.g. stimulus onset and button press, or consecutive eye-fixations), non-linear effects, and complex experimental designs. For a multitude of reasons, we often need to simulate such kinds of data: Simulated EEG data is useful to test preprocessing and analysis tools, validate statistical methods, illustrate conceptual issues, test toolbox functionalities, and find limitations of traditional analysis workflows. For instance, such simulation tools allow for testing the assumptions of new analysis algorithms and testing their robustness against any violation of these assumptions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!---\nNote: The statement of need is also used in the `README.md`. Make sure that they are synchronized.\n-->","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"EditURL = \"../../../literate/HowTo/predefinedData.jl\"","category":"page"},{"location":"generated/HowTo/predefinedData/#Use-existing-experimental-designs-and-onsets-in-the-simulation","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Let's say you want to use the events data frame (containing the levels of the experimental variables and the event onsets (latencies)) from a previous study in your simulation.","category":"page"},{"location":"generated/HowTo/predefinedData/#Setup","page":"Use existing experimental designs & onsets in the simulation","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"# Load required packages\nusing UnfoldSim\nusing DataFrames\nusing Random\nusing CairoMakie # for plotting","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"</details >\n<br />","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"From a previous study, we (somehow, e.g. by using pyMNE.jl) imported an event data frame like this:","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"my_events = DataFrame(:condition => [:A, :B, :B, :A, :A], :latency => [7, 13, 22, 35, 41])","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"To use exactly these values, we can generate a new AbstractDesign, which will always return this event dataframe","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"struct MyManualDesign <: AbstractDesign\n    my_events::Any\nend\nUnfoldSim.generate_events(rng, d::MyManualDesign) = deepcopy(d.my_events) ## generate function which is called internally in UnfoldSim\nUnfoldSim.size(d::MyManualDesign) = size(d.my_events, 1); ## necessary function to tell what the dimensionality of the experimental design is\nnothing #hide","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"note: Note\nNote the UnfoldSim.generate_events which tells Julia to \"overload\" the generate_events function as defined in UnfoldSim.","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Next we generate a MyManualDesign","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"mydesign = MyManualDesign(my_events);\nnothing #hide","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"We could already use this \"solo\" and simulate some data, for example:","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"signal = LinearModelComponent(;\n    basis = [1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + condition),\n    β = [1, 0.5],\n);\n\ndata, events =\n    simulate(MersenneTwister(1), mydesign, signal, UniformOnset(; width = 10, offset = 5))\nlines(data) # plotting\nvlines!(my_events.latency; linestyle = :dash)\ncurrent_figure()","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Looks good, but the events don't match our custom onsets yet.","category":"page"},{"location":"generated/HowTo/predefinedData/#Custom-Timings","page":"Use existing experimental designs & onsets in the simulation","title":"Custom Timings","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Finally, we want to use our custom timings as well. For this we define a new AbstractOnset. Again, it simply returns our manually provided latencies","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"struct MyManualOnset <: AbstractOnset end\nUnfoldSim.simulate_onsets(rng, onset::MyManualOnset, simulation::Simulation) =\n    generate_events(rng, simulation.design).latency","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"hint: Hint\nThis is a bit of a trick, it relies that MyManualOnset is always used in combination with MyManualDesign. You could of course repeat the structure from MyManualDesign also for MyManualOnset and have an explicit field in the structure containing the onsets.","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"And that's it","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"data, events = simulate(MersenneTwister(1), mydesign, signal, MyManualOnset())\nlines(data) # plotting\nvlines!(my_events.latency, linestyle = :dash)\ncurrent_figure()","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"now everything matches, lovely!","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"This page was generated using Literate.jl.","category":"page"}]
}
