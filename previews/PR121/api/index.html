<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API / Docstrings · UnfoldSim.jl</title><meta name="title" content="API / Docstrings · UnfoldSim.jl"/><meta property="og:title" content="API / Docstrings · UnfoldSim.jl"/><meta property="twitter:title" content="API / Docstrings · UnfoldSim.jl"/><meta name="description" content="Documentation for UnfoldSim.jl."/><meta property="og:description" content="Documentation for UnfoldSim.jl."/><meta property="twitter:description" content="Documentation for UnfoldSim.jl."/><meta property="og:url" content="https://unfoldtoolbox.github.io/UnfoldSim.jl/api/"/><meta property="twitter:url" content="https://unfoldtoolbox.github.io/UnfoldSim.jl/api/"/><link rel="canonical" href="https://unfoldtoolbox.github.io/UnfoldSim.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="UnfoldSim.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/tutorials/quickstart/">Quickstart</a></li><li><a class="tocitem" href="../generated/tutorials/simulateERP/">Simulate event-related potentials (ERPs)</a></li><li><a class="tocitem" href="../generated/tutorials/poweranalysis/">Power analysis</a></li><li><a class="tocitem" href="../generated/tutorials/multisubject/">Multi-subject simulation</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../generated/reference/overview/">Overview of functionality</a></li><li><a class="tocitem" href="../generated/reference/designtypes/">Overview: Experimental design types</a></li><li><a class="tocitem" href="../generated/reference/basistypes/">Overview: Basis function (component) types</a></li><li><a class="tocitem" href="../generated/reference/onsettypes/">Overview: Onset types</a></li><li><a class="tocitem" href="../generated/reference/noisetypes/">Overview: Noise types</a></li></ul></li><li><span class="tocitem">HowTo</span><ul><li><a class="tocitem" href="../generated/HowTo/newDesign/">Define a new (imbalanced) design</a></li><li><a class="tocitem" href="../generated/HowTo/repeatTrials/">Get multiple trials with identical subject/item combinations</a></li><li><a class="tocitem" href="../generated/HowTo/newComponent/">Define a new component (with variable duration and shift)</a></li><li><a class="tocitem" href="../generated/HowTo/multichannel/">Generate multi channel data</a></li><li><a class="tocitem" href="../generated/HowTo/predefinedData/">Use existing experimental designs &amp; onsets in the simulation</a></li></ul></li><li class="is-active"><a class="tocitem" href>API / Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API / Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API / Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/unfoldtoolbox/UnfoldSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.AutoRegressiveNoise" href="#UnfoldSim.AutoRegressiveNoise"><code>UnfoldSim.AutoRegressiveNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AutoRegressiveNoise &lt;: AbstractNoise</code></pre><p>Not implemented</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L59-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.ExponentialNoise" href="#UnfoldSim.ExponentialNoise"><code>UnfoldSim.ExponentialNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExponentialNoise &lt;: AbstractNoise</code></pre><p>Noise with exponential decay in AR spectrum.</p><p><code>noiselevel</code> is used to scale the noise</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>With the current implementation we try to get exponential decay over the whole autoregressive (AR) spectrum, which is N samples (the total number of samples in the signal) long. This involves the inversion of a Cholesky matrix of size NxN matrix, which will need lots of RAM for non-trivial problems.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L67-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.LinearModelComponent" href="#UnfoldSim.LinearModelComponent"><code>UnfoldSim.LinearModelComponent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearModelComponent &lt;: AbstractComponent</code></pre><p>A multiple regression component for one subject.</p><p>All fields can be named. Works best with <a href="#UnfoldSim.SingleSubjectDesign"><code>SingleSubjectDesign</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>basis::Any</code>: an object, if accessed, provides a &#39;basis function&#39;, e.g. <code>hanning(40)::Vector</code>, this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects</li><li><code>formula::Any</code>: StatsModels <code>formula</code> object, e.g.  <code>@formula 0 ~ 1 + cond</code> (left-hand side must be 0).</li><li><code>β::Vector</code> Vector of betas/coefficients, must fit the formula.</li><li><code>contrasts::Dict</code> (optional): Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding.    For more information see <a href="https://juliastats.org/StatsModels.jl/stable/contrasts">https://juliastats.org/StatsModels.jl/stable/contrasts</a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LinearModelComponent(;
           basis = hanning(40),
           formula = @formula(0 ~ 1 + cond),
           β = [1., 2.],
           contrasts = Dict(:cond =&gt; EffectsCoding())
       )
LinearModelComponent
  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  …  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]
  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term}}
  β: Array{Float64}((2,)) [1.0, 2.0]
  contrasts: Dict{Symbol, EffectsCoding}</code></pre><p>See also <a href="#UnfoldSim.MixedModelComponent"><code>MixedModelComponent</code></a>, <a href="#UnfoldSim.MultichannelComponent"><code>MultichannelComponent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L42-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.LogNormalOnset" href="#UnfoldSim.LogNormalOnset"><code>UnfoldSim.LogNormalOnset</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@with_kw struct LogNormalOnset &lt;: AbstractOnset</code></pre><p>Log-normal inter-event distances using the <code>Distributions.jl</code> truncated LogNormal distribution.</p><p>Be careful with large <code>μ</code> and <code>σ</code> values, as they are on logscale. σ&gt;8 can quickly give you out-of-memory sized signals!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/onset.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.MixedModelComponent" href="#UnfoldSim.MixedModelComponent"><code>UnfoldSim.MixedModelComponent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MixedModelComponent &lt;: AbstractComponent</code></pre><p>A component that adds a hierarchical relation between parameters according to a Linear Mixed Model (LMM) defined via <code>MixedModels.jl</code>.</p><p>All fields can be named. Works best with <a href="#UnfoldSim.MultiSubjectDesign"><code>MultiSubjectDesign</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>basis::Any</code>: an object, if accessed, provides a &#39;basis function&#39;, e.g. <code>hanning(40)::Vector</code>, this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects</li><li><code>formula::Any</code>: Formula-object in the style of MixedModels.jl e.g. <code>@formula 0 ~ 1 + cond + (1|subject)</code>. The left-hand side is ignored.</li><li><code>β::Vector</code> Vector of betas (fixed effects), must fit the formula.</li><li><code>σs::Dict</code> Dict of random effect variances, e.g. <code>Dict(:subject =&gt; [0.5, 0.4])</code> or to specify correlation matrix <code>Dict(:subject=&gt;[0.5,0.4,I(2,2)],...)</code>. Technically, this will be passed to the MixedModels.jl <code>create_re</code> function, which creates the θ matrices.</li><li><code>contrasts::Dict</code> (optional): Dict in the style of MixedModels.jl. Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding. For more information see <a href="https://juliastats.org/StatsModels.jl/stable/contrasts">https://juliastats.org/StatsModels.jl/stable/contrasts</a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; MixedModelComponent(;
           basis = hanning(40),
           formula = @formula(0 ~ 1 + cond + (1 + cond|subject)),
           β = [1., 2.],
           σs= Dict(:subject =&gt; [0.5, 0.4]),
           contrasts=Dict(:cond =&gt; EffectsCoding())
       )
MixedModelComponent
  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  …  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]
  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term, StatsModels.FunctionTerm{typeof(|), Vector{StatsModels.AbstractTerm}}}}
  β: Array{Float64}((2,)) [1.0, 2.0]
  σs: Dict{Symbol, Vector{Float64}}
  contrasts: Dict{Symbol, EffectsCoding}</code></pre><p>See also <a href="#UnfoldSim.LinearModelComponent"><code>LinearModelComponent</code></a>, <a href="#UnfoldSim.MultichannelComponent"><code>MultichannelComponent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.MultiSubjectDesign" href="#UnfoldSim.MultiSubjectDesign"><code>UnfoldSim.MultiSubjectDesign</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiSubjectDesign &lt;: AbstractDesign</code></pre><p>A type for specifying the experimental design for multiple subjects (based on the given random-effects structure).</p><p><strong>Fields</strong></p><ul><li><code>n_subjects</code>::Int -&gt; number of subjects</li><li><code>n_items</code>::Int -&gt; number of items (sometimes ≈trials)</li><li><code>subjects_between</code> = Dict{Symbol,Vector} -&gt; effects between subjects, e.g. young vs old </li><li><code>items_between</code> = Dict{Symbol,Vector} -&gt; effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified also in <code>subjects_between</code>)</li><li><code>both_within</code> = Dict{Symbol,Vector}	-&gt; effects completly crossed</li><li><code>event_order_function = (rng, x) -&gt; x</code>; # can be used to sort, or e.g. <code>(rng, x) -&gt; shuffle(rng, x)</code> (or shorter just <code>event_order_function = shuffle</code>)</li></ul><p>Tip: Check the resulting dataframe using the <a href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}"><code>generate_events</code></a> function.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># declaring same condition both sub-between and item-between results in a full between subject/item design
design = MultiSubjectDesign(;
		n_items = 10,
		n_subjects = 30,
		subjects_between = Dict(:cond =&gt; [&quot;levelA&quot;, &quot;levelB&quot;]),
		items_between = Dict(:cond =&gt; [&quot;levelA&quot;, &quot;levelB&quot;]),
		);</code></pre><p>See also <a href="#UnfoldSim.SingleSubjectDesign"><code>SingleSubjectDesign</code></a>, <a href="#UnfoldSim.RepeatDesign"><code>RepeatDesign</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.MultichannelComponent" href="#UnfoldSim.MultichannelComponent"><code>UnfoldSim.MultichannelComponent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultichannelComponent &lt;: AbstractComponent</code></pre><p>Projects a <code>AbstractComponent</code> to multiple &quot;channels&quot; via the <code>projection</code> vector.</p><p>Optionally, <code>noise</code> can be added to the source prior to projection. By default a <code>MultichannelComponent</code> can be constructed using one of the following options for <code>projection</code>:</p><ul><li><code>projection::AbstractVector</code>: Directly pass a custom projection vector.</li><li><code>projection::Pair{&lt;:AbstractHeadmodel,String}</code>: Generate a projection vector by specifying which headmodel to use and which sources should be active.</li></ul><p><strong>Fields</strong></p><ul><li><code>component::AbstractComponent</code>: The component that should be projected to the sensors.</li><li><code>projection::AbstractVector</code> or <code>projection::Pair{&lt;:AbstractHeadmodel,String}</code>: Vector <code>p</code> that projects the (source) component <code>c[t]</code> (where <code>t</code> is time) to the sensors <code>s</code>.   The length of <code>p</code> equals the number of sensors <code>s</code>. Typically, it is a slice of the leadfield matrix. <code>out[s,t] = p[s]*c[t]</code>.</li><li><code>noise::AbstractNoise</code> (optional): Noise added in the source space. Default is <code>NoNoise</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Variant 1: Specify the projection vector manually
julia&gt; c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [1]);

julia&gt; mc1 = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1])
MultichannelComponent
  component: LinearModelComponent
  projection: Array{Float64}((7,)) [1.0, 2.0, -1.0, 3.0, 5.0, 2.3, 1.0]
  noise: NoNoise NoNoise()

# Variant 2: Use a headmodel and specify a source
julia&gt; c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [1]);

julia&gt; hart = headmodel(type = &quot;hartmut&quot;);
Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce

julia&gt; mc2 = UnfoldSim.MultichannelComponent(c2, hart =&gt; &quot;Right Occipital Pole&quot;)
MultichannelComponent
  component: LinearModelComponent
  projection: Array{Float64}((227,)) [-0.03461859471337842, -0.04321094803502425, 0.0037088347968313525, -0.014722528968861278, -0.0234889834534478, 0.02731807504242923, 0.038863688452528036, 0.1190531258070562, -0.09956890221613562, -0.0867729334438599  …  0.37435404409695094, -0.020863789022627935, 0.25627478723535513, -0.05777985212119245, 0.37104376432271147, -0.19446620423767172, 0.2590764703721097, -0.12923837607416555, 0.1732886690359311, 0.4703016561960567]
  noise: NoNoise NoNoise()</code></pre><p>See also <a href="#UnfoldSim.LinearModelComponent"><code>LinearModelComponent</code></a>, <a href="#UnfoldSim.MixedModelComponent"><code>MixedModelComponent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L81-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.NoNoise" href="#UnfoldSim.NoNoise"><code>UnfoldSim.NoNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoNoise &lt;: AbstractNoise</code></pre><p>Return zeros instead of noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.NoOnset" href="#UnfoldSim.NoOnset"><code>UnfoldSim.NoOnset</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct NoOnset &lt;: AbstractOnset end</code></pre><p>In the case that the user directly wants no overlap to be simulated (=&gt; epoched data).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/onset.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.PinkNoise" href="#UnfoldSim.PinkNoise"><code>UnfoldSim.PinkNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PinkNoise &lt;: AbstractNoise</code></pre><p>Generate Pink Noise using the SignalAnalysis.jl implementation.</p><p><code>noiselevel</code> is used to scale the noise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.RealisticNoise" href="#UnfoldSim.RealisticNoise"><code>UnfoldSim.RealisticNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RealisticNoise &lt;: AbstractNoise</code></pre><p>Not implemented - planned to use Artifacts.jl to provide real EEG data to add.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.RedNoise" href="#UnfoldSim.RedNoise"><code>UnfoldSim.RedNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RedNoise &lt;: AbstractNoise</code></pre><p>Generate Red Noise using the SignalAnalysis.jl implementation.</p><p><code>noiselevel</code> is used to scale the noise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.RepeatDesign" href="#UnfoldSim.RepeatDesign"><code>UnfoldSim.RepeatDesign</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RepeatDesign{T} &lt;: AbstractDesign</code></pre><p>Repeat a design DataFrame multiple times to mimick repeatedly recorded trials.</p><pre><code class="language-julia hljs">designOnce = MultiSubjectDesign(;
		n_items=2,
		n_subjects = 2,
		subjects_between =Dict(:cond=&gt;[&quot;levelA&quot;,&quot;levelB&quot;]),
		items_between =Dict(:cond=&gt;[&quot;levelA&quot;,&quot;levelB&quot;]),
		);

design = RepeatDesign(designOnce,4);</code></pre><p>See also <a href="#UnfoldSim.SingleSubjectDesign"><code>SingleSubjectDesign</code></a>, <a href="#UnfoldSim.MultiSubjectDesign"><code>MultiSubjectDesign</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L172-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.SingleSubjectDesign" href="#UnfoldSim.SingleSubjectDesign"><code>UnfoldSim.SingleSubjectDesign</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SingleSubjectDesign &lt;: AbstractDesign</code></pre><p>A type for specifying the experimental for a single subject (based on the given conditions).</p><p><strong>Fields</strong></p><ul><li><code>conditions = Dict{Symbol,Vector}</code><code>of conditions, e.g.</code>Dict(:A=&gt;[&quot;a<em>small&quot;,&quot;a</em>big&quot;],:B=&gt;[&quot;b<em>tiny&quot;,&quot;b</em>large&quot;])`</li><li><code>event_order_function</code> = (rng::AbstractRNG,x::DataFrame)-&gt;x; # can be used to sort by specifying <code>sort</code>, or shuffling by providing <code>shuffle</code>, or custom functions following the interface <code>(rng,x)-&gt;my_shuffle(rng,x)</code></li></ul><p>Number of trials / rows in <code>generate_events([rng, ]design)</code> depend on the full factorial of your <code>conditions</code>.</p><p>To increase the number of repetitions simply use <code>RepeatDesign(SingleSubjectDesign(...),5)</code></p><p>If conditions are omitted (or set to <code>nothing</code>), a single trial is simulated with a column <code>:dummy</code> and content <code>:dummy</code> - this is for convenience.</p><p>Tip: Check the resulting dataframe using the <a href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}"><code>generate_events</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">design = SingleSubjectDesign(;
    conditions = Dict(
        :stimulus_type =&gt; [&quot;natural&quot;, &quot;artificial&quot;],
        :contrast_level =&gt; range(0, 1, length = 5),
);</code></pre><p>See also <a href="#UnfoldSim.MultiSubjectDesign"><code>MultiSubjectDesign</code></a>, <a href="#UnfoldSim.RepeatDesign"><code>RepeatDesign</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L39-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.UniformOnset" href="#UnfoldSim.UniformOnset"><code>UnfoldSim.UniformOnset</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct UniformOnset &lt;: AbstractOnset</code></pre><p>Provide a Uniform Distribution of the inter-event-distances. <code>width</code>  is the width of the uniform distribution (=&gt; the jitter). Since the lower bound is 0, <code>width</code> is also the upper bound. <code>offset</code> is the minimal distance. The maximal distance is <code>offset + width</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/onset.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.WhiteNoise" href="#UnfoldSim.WhiteNoise"><code>UnfoldSim.WhiteNoise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WhiteNoise &lt;: WhiteNoise
noiselevel = 1
imfilter = 0</code></pre><p>Generate White Noise using <code>randn</code> - thus Gaussian noise. <code>noiselevel</code> is used to scale the noise</p><p>Using <code>imfilter</code> &gt; 0 it is possible to smooth the noise using Image.imfilter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{MultiSubjectDesign}" href="#Base.size-Tuple{MultiSubjectDesign}"><code>Base.size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns dimension of experiment design</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Windows.hanning-Tuple{Any, Any, Any}" href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>DSP.Windows.hanning</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hanning(duration, offset, sfreq)</code></pre><p>Generate a (potentially shifted) hanning window with a certain duration. </p><p>Note: This function extends the <code>DSP.hanning</code> function using multiple dispatch.</p><p><strong>Arguments</strong></p><ul><li><code>duration</code>: in s.</li><li><code>offset</code>: in s, defines hanning peak i.e. shift of the hanning window.</li><li><code>sfreq</code>: Sampling rate in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; UnfoldSim.hanning(0.1, 0.3, 100)
25-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.9698463103929542
 0.75
 0.41317591116653485
 0.11697777844051105
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/bases.jl#L130-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.PuRF-Tuple{}" href="#UnfoldSim.PuRF-Tuple{}"><code>UnfoldSim.PuRF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PuRF(; n = 10.1, tmax = 0.93, sfreq = 100)</code></pre><p>Default generator for PuRF Pupil Response Function. The canonical PRF is a gamma function and implemented according to Denison 2020 equation (2) going back to Hoeks &amp; Levelt, 1993.</p><p>The pupil response is evaluated at t = 0:1/sfreq:3*tmax. The response is normalized by the peak-maximum at tmax, thus typically a pupil-response of 1 is returned (disregarding numerical issues).</p><p><strong>Keyword arguments:</strong></p><ul><li><code>n = 10.1</code>: shape parameter</li><li><code>tmax = 0.93</code>: peak maximum</li><li><code>sfreq = 100</code>: sampling frequency</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: canonical pupil response with length(0:1/sfreq:3*tmax) entries.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PuRF(; n = 5)
280-element Vector{Float64}:
 0.0
 2.0216617815131253e-8
 6.130689396024061e-7
 4.4118063684811444e-6
 1.761817666835793e-5
 ⋮
 0.012726253506722554
 0.012280989091455786
 0.011850525657416842
 0.011434405338911133
 0.011032182932283816</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/bases.jl#L169-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}" href="#UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}"><code>UnfoldSim.add_noise!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_noise!(rng, noisetype::AbstractNoise, signal)</code></pre><p>Generate and add noise to a data matrix. Assumes that the signal can be linearized, that is, that the noise is stationary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}" href="#UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}"><code>UnfoldSim.add_responses!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_responses!(signal, responses::Vector, e, s, tvec, erpvec)
add_responses!(signal, responses::Matrix, e, s, tvec, erpvec)
add_responses!(signal, responses::AbstractArray, e, s, tvec, erpvec)</code></pre><p>Helper function to add inplace the responses to the signal, but for both 2D (1 channel) and 3D (X channel case).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/simulation.jl#L224-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.apply_event_order_function-Tuple{Any, Any, Any}" href="#UnfoldSim.apply_event_order_function-Tuple{Any, Any, Any}"><code>UnfoldSim.apply_event_order_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_event_order_function(fun::Function, rng::AbstractRNG, events::DataFrame)</code></pre><p>apply fun(rng,events), raise an error if function is wrongly defined. Convenience function to not repeat the error handling at multiple places.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.closest_src-Tuple{AbstractVector{&lt;:AbstractVector}, Any}" href="#UnfoldSim.closest_src-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>UnfoldSim.closest_src</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closest_src(coords_list::AbstractVector{&lt;:AbstractVector}, pos)
closest_src(coords::Vector{&lt;:Real}, pos)</code></pre><p>Takes an array of &#39;m&#39; target coordinate vector (size 3) (or vector of vectors) and a matrix (n-by-3) of all available positions, and returns an array of size &#39;m&#39; containing the indices of the respective items in &#39;pos&#39; that are nearest to each of the target coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/helper.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.closest_src-Tuple{Hartmut, String}" href="#UnfoldSim.closest_src-Tuple{Hartmut, String}"><code>UnfoldSim.closest_src</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closest_src(head::Hartmut,label::String)</code></pre><p>Returns src-<code>ix</code> of the Headmodel <code>Hartmut</code> which is closest to the average of the <code>label</code>.</p><div class="admonition is-category-important"><header class="admonition-header">Important</header><div class="admonition-body"><p>We use the average in eucledean space, but the cortex is a curved surface. In most cases they will not overlap. Ideally we would calculate the average on the surface, but this is a bit more complex to do (you&#39;d need to calculate the vertices etc.)</p></div></div><pre><code class="language-julia hljs">hartmut = headmodel()
pos = closest_src(hartmut=&gt;&quot;Left Middle Temporal Gyrus, posterior division&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/helper.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.convert-Tuple{Random.AbstractRNG, Vararg{Any, 4}}" href="#UnfoldSim.convert-Tuple{Random.AbstractRNG, Vararg{Any, 4}}"><code>UnfoldSim.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Obsolete - # TODO: Transfer function to Unfold.jl</p><p>Function to convert output similar to unfold (data, events)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/helper.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}" href="#UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}"><code>UnfoldSim.create_continuous_signal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_continuous_signal(rng, responses, simulation)</code></pre><p>Based on the responses and simulation parameters, simulate onset latencies and add together a continuous signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/simulation.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}" href="#UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}"><code>UnfoldSim.epoch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">epoch(data::AbstractVector, args...; kwargs...)
epoch(
    data::AbstractArray{T,2},
    events,
    τ::Tuple{Number,Number},
    sfreq;
    eventtime::Symbol = :latency,
) where {T&lt;:Union{Missing,Number}}</code></pre><p>Helper function to epoch data.</p><p>Adapted from Unfold.jl: https://github.com/unfoldtoolbox/Unfold.jl/blob/b3a21c2bb7e93d2f45ec64b0197f4663a6d7939a/src/utilities.jl#L40</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/helper.jl#L98-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}" href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}"><code>UnfoldSim.generate_events</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_events([rng::AbstractRNG, ]design::MultiSubjectDesign)</code></pre><p>Generate full factorial Dataframe according to MixedModelsSim.jl &#39;s <code>simdat_crossed</code> function.</p><p>Note: <code>n_items</code> = you can think of it as <code>trials</code> or better, as <code>stimuli</code>. Note: No condition can be named <code>dv</code> which is used internally in MixedModelsSim / MixedModels as a dummy left-side Afterwards applies <code>design.event_order_function</code>. Could be used to duplicate trials, sort, subselect etc. Finally it sorts by <code>:subject</code></p><pre><code class="language-julia hljs">d = MultiSubjectDesign(; n_subjects = 10, n_items = 20, both_within = Dict(:A =&gt; nlevels(5),:B =&gt; nlevels(2)))
generate_events(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L119-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.generate_events-Tuple{Random.AbstractRNG, RepeatDesign}" href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, RepeatDesign}"><code>UnfoldSim.generate_events</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnfoldSim.generate_events([rng::AbstractRNG, ]design::RepeatDesign{T})</code></pre><p>In a repeated design, iteratively calls the underlying {T} design and concatenates. In case of <code>MultiSubjectDesign</code>, sorts by subject.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.generate_events-Tuple{Random.AbstractRNG, SingleSubjectDesign}" href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, SingleSubjectDesign}"><code>UnfoldSim.generate_events</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_events([rng::AbstractRNG, ]design::SingleSubjectDesign)</code></pre><p>Generates full-factorial DataFrame of design.conditions</p><p>Afterwards applies <code>design.event_order_function</code>. If conditions is <code>nothing</code>, a single trial is simulated with a column <code>:dummy</code> and content <code>:dummy</code> - this is for convenience.</p><p>julia&gt; d = SingleSubjectDesign(;conditions= Dict(:A=&gt;nlevels(5),:B=&gt;nlevels(2))) julia&gt; generate_events(d)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/design.jl#L76-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.hartmut_citation-Tuple{}" href="#UnfoldSim.hartmut_citation-Tuple{}"><code>UnfoldSim.hartmut_citation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns citation-string for HArtMuT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/headmodel.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.headmodel-Tuple{}" href="#UnfoldSim.headmodel-Tuple{}"><code>UnfoldSim.headmodel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Load a headmodel, using Artifacts.jl automatically downloads the required files</p><p>Currently only <code>type=&quot;hartmut&quot;</code> is implemented</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/headmodel.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.hrf-Tuple{}" href="#UnfoldSim.hrf-Tuple{}"><code>UnfoldSim.hrf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hrf(;
TR = 1,
peak = 6.0,
post_undershoot = 16,
length = 32.0,
peak_width = 1.0,
post_undershoot_width = 1,
amplitude = 6,
shift = 0)</code></pre><p>Generate a parameterized BOLD haemodynamic response function (HRF) kernel based on gamma-functions.</p><p>Implementation and default parameters were taken from the SPM-toolbox.</p><p>Note: TR = 1/sfreq</p><p><strong>Keyword arguments</strong></p><ul><li><code>TR = 1</code>: repetition time, 1/sfreq.</li><li><code>length = 32.0</code>: total length of the kernel in seconds.</li><li><code>amplitude = 6</code>: maximal amplitude.</li><li><code>peak = 6.0</code>: peak timing.</li><li><code>peak_width = 1.0</code>: width of the peak.</li><li><code>post_undershoot = 16</code>: post-undershoot timing.</li><li><code>post_undershoot_width = 1</code>: post-undershoot width.</li><li><code>shift = 0</code>: shift the whole HRF.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: HRF BOLD response.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hrf()
33-element Vector{Float64}:
  0.0
  0.0007715994433635659
  0.019784004131204957
  0.08202939459091822
  0.158157713522699
  ⋮
 -0.0006784790038792572
 -0.00042675060451877775
 -0.000263494738348278
 -0.00015990722628360688
 -9.548780093799345e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/bases.jl#L213-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.leadfield-Tuple{Hartmut}" href="#UnfoldSim.leadfield-Tuple{Hartmut}"><code>UnfoldSim.leadfield</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the leadfield</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/headmodel.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.magnitude-Tuple{AbstractHeadmodel}" href="#UnfoldSim.magnitude-Tuple{AbstractHeadmodel}"><code>UnfoldSim.magnitude</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Extracts magnitude of the orientation-including leadfield.</p><p>By default uses the orientation specified in the headmodel</p><p>Fallback: along the third dimension using <code>norm</code> - the maximal projection</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/headmodel.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.magnitude-Tuple{Hartmut}" href="#UnfoldSim.magnitude-Tuple{Hartmut}"><code>UnfoldSim.magnitude</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>magnitude(headmodel::Hartmut; type = &quot;perpendicular&quot;) = Extract magnitude of 3-orientation-leadfield,  <code>type</code> (default: &quot;perpendicular&quot;) =&gt; uses the provided source-point orientations - otherwise falls back to <code>norm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/headmodel.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.magnitude-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real" href="#UnfoldSim.magnitude-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T&lt;:Real"><code>UnfoldSim.magnitude</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">magnitude(lf::AbstractArray{T,3}) where {T&lt;:Real}</code></pre><p>If orientation is not specified, returns the maximal magnitude (norm of leadfield).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/headmodel.jl#L112-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T&lt;:Real" href="#UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T&lt;:Real"><code>UnfoldSim.magnitude</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">magnitude(lf::AbstractArray{T,3}, orientation::AbstractArray{T,2}) where {T&lt;:Real}</code></pre><p>Return the magnitude along an orientation of the leadfield.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/headmodel.jl#L97-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.maxlength-Tuple{Vector{&lt;:AbstractComponent}}" href="#UnfoldSim.maxlength-Tuple{Vector{&lt;:AbstractComponent}}"><code>UnfoldSim.maxlength</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maxlength(c::Vector{&lt;:AbstractComponent}) = maximum(length.(c))</code></pre><p>Return the maximum of the individual components&#39; lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n170-Tuple{}" href="#UnfoldSim.n170-Tuple{}"><code>UnfoldSim.n170</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n170(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking an N170 EEG component with a negative (!) peak at 170ms and a width of 150ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n170(; sfreq = 120)
28-element Vector{Float64}:
 -0.0
 -0.0
 -0.0
 -0.0
 -0.0
  ⋮
 -0.45386582026834904
 -0.2771308221117309
 -0.1304955413896705
 -0.03376388529782215
 -0.0</code></pre><p>See also <a href="#UnfoldSim.p100-Tuple{}"><code>p100</code></a>, <a href="#UnfoldSim.p300-Tuple{}"><code>p300</code></a>, <a href="#UnfoldSim.n400-Tuple{}"><code>n400</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/bases.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n400-Tuple{}" href="#UnfoldSim.n400-Tuple{}"><code>UnfoldSim.n400</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n400(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking an N400 EEG component with a negative (!) peak at 400ms and a width of 400ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n400(; sfreq = 250)
150-element Vector{Float64}:
 -0.0
 -0.0
 -0.0
 -0.0
 -0.0
  ⋮
 -0.016025649301821876
 -0.009035651368646647
 -0.00402259358460233
 -0.0010066617640578368
 -0.0</code></pre><p>See also <a href="#UnfoldSim.p100-Tuple{}"><code>p100</code></a>, <a href="#UnfoldSim.p300-Tuple{}"><code>p300</code></a>, <a href="#UnfoldSim.n170-Tuple{}"><code>n170</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/bases.jl#L99-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n_channels-Tuple{AbstractComponent}" href="#UnfoldSim.n_channels-Tuple{AbstractComponent}"><code>UnfoldSim.n_channels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n_channels(c::AbstractComponent)</code></pre><p>Return the number of channels for the given component <code>c</code>. By default = 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n_channels-Tuple{MultichannelComponent}" href="#UnfoldSim.n_channels-Tuple{MultichannelComponent}"><code>UnfoldSim.n_channels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n_channels(c::MultichannelComponent)</code></pre><p>For <code>MultichannelComponent</code> return the length of the projection vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n_channels-Tuple{Vector{&lt;:AbstractComponent}}" href="#UnfoldSim.n_channels-Tuple{Vector{&lt;:AbstractComponent}}"><code>UnfoldSim.n_channels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n_channels(c::Vector{&lt;:AbstractComponent})</code></pre><p>For a vector of <code>MultichannelComponent</code>s, return the number of channels for the first component but assert all are of equal length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.p100-Tuple{}" href="#UnfoldSim.p100-Tuple{}"><code>UnfoldSim.p100</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p100(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking a P100 EEG component with a peak at 100ms and a width of 100ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p100(; sfreq = 200)
30-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.37725725642960045
 0.22652592093878665
 0.10542974530180327
 0.02709137914968268
 0.0</code></pre><p>See also <a href="#UnfoldSim.p300-Tuple{}"><code>p300</code></a>, <a href="#UnfoldSim.n170-Tuple{}"><code>n170</code></a>, <a href="#UnfoldSim.n400-Tuple{}"><code>n400</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/bases.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.p300-Tuple{}" href="#UnfoldSim.p300-Tuple{}"><code>UnfoldSim.p300</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p300(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking a P300 EEG component with a peak at 300ms and a width of 300ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p300(; sfreq = 150)
67-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 ⋮
 0.07937323358440934
 0.04518400232274078
 0.02025351319275137
 0.005089279059533658
 0.0</code></pre><p>See also <a href="#UnfoldSim.p100-Tuple{}"><code>p100</code></a>, <a href="#UnfoldSim.n170-Tuple{}"><code>n170</code></a>, <a href="#UnfoldSim.n400-Tuple{}"><code>n400</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/bases.jl#L36-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}" href="#UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}"><code>UnfoldSim.pad_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Pads array with specified value, length pad_array(arr, len, val)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/helper.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}" href="#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}"><code>UnfoldSim.predef_2x2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predef_2x2(rng::AbstractRNG; kwargs...)</code></pre><p>The most used <code>kwargs</code> is: <code>return_epoched = true</code> which returns already epoched data. If you want epoched data without overlap, specify <code>onset = NoOnset()</code> and <code>return_epoched = true</code></p><p><strong>Design</strong></p><ul><li><code>n_items = 100</code>,</li><li><code>n_subjects = 1</code>,</li><li><code>conditions = Dict(:A =&gt; [&quot;a_small&quot;,&quot;a_big&quot;], :B =&gt; [&quot;b_tiny&quot;,&quot;b_large&quot;])</code>,</li><li><code>event_order_function = shuffle</code>,</li></ul><p><strong>Component / Signal</strong></p><ul><li><code>signalsize = 100</code>, # Length of simulated hanning window</li><li><code>basis = hanning(signalsize)</code>, # The actual &quot;function&quot;, <code>signalsize</code> is only used here</li><li><code>β = [1, -0.5, .5, +1]</code>, # The parameters</li><li><code>σs = Dict(:subject =&gt; [1, 0.5, 0.5, 0.5],:item =&gt; [1])</code>, # Only in n_subjects &gt;= 2 case, specifies the random effects</li><li><code>contrasts = Dict(:A =&gt; EffectsCoding(), :B =&gt; EffectsCoding())</code> # Effect coding by default</li><li><code>formula = n_subjects == 1 ? @formula(0 ~ 1 + A*B) : @formula(dv ~ 1 + A*B + (A*B|subject) + (1|item))</code>,</li></ul><p><strong>Onset</strong></p><ul><li><code>overlap = (0.5,0.2)</code>,</li><li><code>onset = UniformOnset(; offset = signalsize * overlap[1], width = signalsize * overlap[2])</code>, # Put offset to 1 for no overlap. put width to 0 for no jitter</li></ul><p><strong>Noise</strong></p><ul><li><code>noiselevel = 0.2</code>,</li><li><code>noise = PinkNoise(; noiselevel = noiselevel)</code>,</li></ul><p>Be careful if you modify n<em>items with n</em>subjects = 1, n_items has to be a multiple of 4 (or your equivalent conditions factorial, e.g. all combinations length)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/predefinedSimulations.jl#L140-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.predef_eeg-Tuple{Any}" href="#UnfoldSim.predef_eeg-Tuple{Any}"><code>UnfoldSim.predef_eeg</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predef_eeg(; kwargs...)
predef_eeg(rng; kwargs...)
predef_eeg(rng, n_subjects; kwargs...)</code></pre><p>Generate a P1/N1/P3 complex. In case <code>n_subjects</code> is defined - <code>MixedModelComponents</code> are generated, else <code>LinearModelComponents</code>.</p><p>The most used <code>kwargs</code> is: <code>return_epoched=true</code> which returns already epoched data. If you want epoched data without overlap, specify <code>onset = NoOnset()</code> and <code>return_epoched = true</code></p><p><strong>Default parameters:</strong></p><p><strong>Design</strong></p><ul><li><code>n_repeats = 100</code>,</li><li><code>event_order_function = shuffle</code>, # random trial order</li><li><code>conditions = Dict(...)</code>,</li></ul><p><strong>Component / Signal</strong></p><ul><li><code>sfreq = 100</code>,</li><li><code>p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict())</code>, # P1 amp 5, no effects</li><li><code>n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5,-3], Dict())</code>, # N1 amp 5, dummy-coded condition effect (levels &quot;car&quot;, &quot;face&quot;) of -3</li><li><code>p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5,1], Dict())</code>, # P3 amp 5, continuous effect range [-5,5] with slope 1</li></ul><p><strong>Onset</strong></p><ul><li><code>overlap = (0.5,0.2)</code>, # offset + width/length of Uniform noise. put offset to 1 for no overlap. put width to 0 for no jitter</li><li><code>onset = UniformOnset(; offset = sfreq * 0.5 * overlap[1], width = sfreq * 0.5 * overlap[2])</code>, </li></ul><p><strong>Noise</strong></p><ul><li><code>noiselevel = 0.2</code>,</li><li><code>noise = PinkNoise(; noiselevel = noiselevel)</code>,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/predefinedSimulations.jl#L9-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate" href="#UnfoldSim.simulate"><code>UnfoldSim.simulate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(
rng::AbstractRNG,
design::AbstractDesign,
signal,
onset::AbstractOnset,
noise::AbstractNoise = NoNoise();
return_epoched = false,
)

simulate(
design::AbstractDesign,
signal,
onset::AbstractOnset,
noise::AbstractNoise = NoNoise();
return_epoched = false,
)</code></pre><p>Return continuous or epoched signal, given <code>Design</code>, [Array of] <code>Component</code>, <code>Onset</code> and  optional [<code>Noise</code>] and [<code>RNG</code>]. Main simulation function.</p><p><strong>Arguments</strong></p><ul><li><code>design::AbstractDesign</code>: Desired experimental design.</li><li><code>signal</code>: <code>Component</code> for the desired signal.</li><li><code>onset::AbstractOnset</code>: Desired onset.</li><li><code>noise::AbstractNoise = NoNoise()</code> (optional): Desired noise.</li><li><code>rng::AbstractRNG</code> (optional): Random number generator, important to ensure reproducibility.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>return_epoched = false</code>: Skip the Onset-calculation and conversion to continuous data    and return the epoched data directly (see also Notes below).</li></ul><p><strong>Returns</strong></p><ul><li><code>signal</code> : Generated signal. Depending on the design, on the components and on    <code>return_epoched</code>, the output can be a 1-D, 2-D, 3-D or 4-D Array.    For example, a 4-D Array would have the dimensions <code>channels x time x trials x subjects</code>.</li><li><code>events</code>: Generated events.</li></ul><p><strong>Examples</strong></p><p>Adapted from the quickstart tutorial in the UnfoldSim docs.</p><pre><code class="language-julia-repl hljs">julia&gt; using UnfoldSim

julia&gt; using Random # to get an RNG

julia&gt; design =
    SingleSubjectDesign(; conditions = Dict(:cond_A =&gt; [&quot;level_A&quot;, &quot;level_B&quot;])) |&gt;
    x -&gt; RepeatDesign(x, 10);

julia&gt; signal = LinearModelComponent(; 
    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],
    formula = @formula(0 ~ 1 + cond_A),
    β = [1, 0.5],
);

julia&gt; onset = UniformOnset(; width = 20, offset = 4);

julia&gt; noise = PinkNoise(; noiselevel = 0.2);

julia&gt; data, events = simulate(MersenneTwister(1), design, signal, onset, noise)
([-0.045646938524459196, 0.15784406738265955, 0.012640319497460443, 0.026669512219327673, 0.15329144053662508, 0.06412654786607011, -0.16766777448918685, -0.08012027590515228, 0.0020515088981202137, -0.24874482217391175  …  0.24621397283439814, 0.1710771262918883, -0.01527736524528042, 0.7639978745937471, 1.5600315092771557, 1.624219837479329, 1.2889713838347956, 0.26819223928179, 0.16535758767503866, 0.21291936972924855], 20×2 DataFrame
 Row │ cond_A   latency 
     │ String   Int64   
─────┼──────────────────
   1 │ level_A       18
   2 │ level_B       39
   3 │ level_A       45
   4 │ level_B       49
  ⋮  │    ⋮        ⋮
  18 │ level_B      258
  19 │ level_A      281
  20 │ level_B      303

julia&gt; data1, events1 = simulate(design, signal, onset, noise)
┌ Warning: No random generator defined, used the default (`Random.MersenneTwister(1)`) with a fixed seed. This will always return the same results and the user is strongly encouraged to provide their own random generator!</code></pre><p><strong>Notes</strong></p><p>Some remarks to how the noise is added:</p><ul><li>If <code>return_epoched = true</code> and <code>onset = NoOnset()</code> the noise is added to the epoched data matrix.</li><li>If <code>onset</code> is not <code>NoOnset</code>, a continuous signal is created and the noise is added to this    i.e. this means that the noise won&#39;t be the same as in the <code>onset = NoOnset()</code> case even if <code>return_epoched = true</code>.</li><li>The case <code>return_epoched = false</code> and <code>onset = NoOnset()</code> is not possible and therefore    covered by an assert statement.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/simulation.jl#L15-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}" href="#UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}"><code>UnfoldSim.simulate_and_add!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_and_add!(epoch_data::AbstractMatrix, c, simulation, rng)
simulate_and_add!(epoch_data::AbstractArray, c, simulation, rng)</code></pre><p>Helper function to call <code>simulate_component</code> and add it to a provided Array <code>epoch_data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L499-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}" href="#UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}"><code>UnfoldSim.simulate_component</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::AbstractComponent, simulation::Simulation)</code></pre><p>By default call <code>simulate_component</code> with <code>(rng, c::Abstractcomponent, design::AbstractDesign)</code> instead of the whole simulation. This function exist solely to provide a &quot;hook&quot; if for a custom component something else than the design is necessary, e.g. a dependency on the onsets, noise or similar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}" href="#UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}"><code>UnfoldSim.simulate_component</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::LinearModelComponent, design::AbstractDesign)</code></pre><p>Generate a linear model design matrix, weight it by the coefficients <code>c.β</code> and multiply the result with the given basis vector.</p><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Simulated component for each event in the events dataframe. The output dimensions are <code>length(c.basis) x length(design)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = SingleSubjectDesign(; conditions = Dict(:cond =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; c = UnfoldSim.LinearModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond), [1, 2], Dict());

julia&gt; using StableRNGs

julia&gt; simulate_component(StableRNG(1), c, design)
4×2 Matrix{Float64}:
 0.0  0.0
 3.0  1.0
 3.0  1.0
 0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L186-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}" href="#UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}"><code>UnfoldSim.simulate_component</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::MixedModelComponent, design::AbstractDesign, return_parameters = false)</code></pre><p>Generate a MixedModel and simulate data according to the given paraemters <code>c.β</code> and <code>c.σs</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>return_parameters::Bool = false</code>: Can be used to return the per-event parameters used to weight the basis function. Sometimes useful to inspect what is simulated.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Simulated component for each event in the events dataframe. The output dimensions are <code>length(c.basis) x length(design)</code>.</li></ul><p><strong>Notes</strong></p><ol><li>MixedModels/Sim does not allow simulation of data without white noise of the residuals. Because we want our own noise, we use the following trick to remove the MixedModels-Noise:</li></ol><p>Practically, we upscale the specified <code>σs</code> by factor 10<em>000, and request a white-noise-level of <code>σ = 0.0001</code>. Internally in MixedModels/Sim, <code>σs</code> are relative to <code>σ</code>, and thus are normalized correctly, while keeping the noise 10</em>000 times smaller than the random effects</p><p>We cannot exclude that this trick runs into strange numerical issues if the random effect <code>σs</code> are very large compared to the fixed effects.</p><ol><li>Currently, it is not possible to use a different basis for fixed and random effects. If this is needed, some code-scaffold is available but commented out at the moment and requires a bit of implementation work.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = MultiSubjectDesign(; n_subjects = 2, n_items = 6, items_between = Dict(:cond =&gt; [&quot;A&quot;, &quot;B&quot;]));

julia&gt; c = UnfoldSim.MixedModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond + (1|subject)), [1, 2], Dict(:subject =&gt; [2],), Dict());

julia&gt; using StableRNGs

julia&gt; simulate_component(StableRNG(1), c, design)
4×12 Matrix{Float64}:
 -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0
 -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565
 -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565
 -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0

julia&gt; simulate_component(StableRNG(1), c, design, return_parameters = true)
1×12 Matrix{Float64}:
 -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L229-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}" href="#UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}"><code>UnfoldSim.simulate_component</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::MultichannelComponent, design::AbstractDesign)</code></pre><p>Return the projection of a <code>MultichannelComponent c</code> from &quot;source&quot; to &quot;sensor&quot; space.</p><p><strong>Returns</strong></p><ul><li><code>Array{Float64,3}</code>: Projected simulated component for each event in the events dataframe. The output dimensions are <code>length(c.projection) x length(c.basis) x length(design)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = SingleSubjectDesign(; conditions = Dict(:cond =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);
julia&gt; mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1], PinkNoise());

julia&gt; using StableRNGs

julia&gt; simulate_component(StableRNG(1), mc, design)
7×15×2 Array{Float64, 3}:
[:, :, 1] =
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662
  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.7484    3.53412   5.53942   4.0612    2.34858   2.01845   2.19039   1.50932    4.51324
 -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.3742   -1.76706  -2.76971  -2.0306   -1.17429  -1.00922  -1.09519  -0.754659  -2.25662
  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   4.1226    5.30118   8.30913   6.09179   3.52287   3.02767   3.28558   2.26398    6.76985
  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.871     8.8353   13.8485   10.153     5.87145   5.04612   5.47597   3.7733    11.2831
  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.16066   4.06424   6.37033   4.67037   2.70087   2.32121   2.51894   1.73572    5.19022
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662

[:, :, 2] =
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662
  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.63142   3.12094   4.78942   3.09135   1.37873    1.26845    1.77721    1.39234   4.51324
 -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.31571  -1.56047  -2.39471  -1.54567  -0.689367  -0.634223  -0.888605  -0.69617  -2.25662
  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   3.94713   4.68142   7.18413   4.63702   2.0681     1.90267    2.66582    2.08851   6.76985
  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.57855   7.80236  11.9735    7.72837   3.44684    3.17112    4.44303    3.48085  11.2831
  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.02613   3.58909   5.50783   3.55505   1.58554    1.45871    2.04379    1.60119   5.19022
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L345-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_noise-Tuple{Any, NoNoise, Int64}" href="#UnfoldSim.simulate_noise-Tuple{Any, NoNoise, Int64}"><code>UnfoldSim.simulate_noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_noise(rng, t::NoNoise, n::Int)</code></pre><p>Return zeros instead of noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_noise-Tuple{Any, Union{PinkNoise, RedNoise}, Int64}" href="#UnfoldSim.simulate_noise-Tuple{Any, Union{PinkNoise, RedNoise}, Int64}"><code>UnfoldSim.simulate_noise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_noise(rng, t::Union{PinkNoise,RedNoise}, n::Int)</code></pre><p>Generate Pink or Red Noise using the <code>SignalAnalysis.jl</code> implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/noise.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}" href="#UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}"><code>UnfoldSim.simulate_onsets</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_onsets(rng, onset::AbstractOnset, simulation::Simulation)</code></pre><p>Call <code>simulate_interonset_distances</code> to generate distances between events and then add them up to generate the actual latencies in samples.</p><p><strong>main call from <code>simulation</code></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/onset.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_responses-Tuple{Any, Vector{&lt;:AbstractComponent}, Simulation}" href="#UnfoldSim.simulate_responses-Tuple{Any, Vector{&lt;:AbstractComponent}, Simulation}"><code>UnfoldSim.simulate_responses</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_responses(
    rng,
    components::Vector{&lt;:AbstractComponent},
    simulation::Simulation)</code></pre><p>Simulate multiple component responses and accumulate them on a per-event basis.</p><p><strong>Returns</strong></p><ul><li><code>epoch_data</code>: <code>Matrix</code> (or <code>Array</code> in the multi-channel case) of combined simulated components.   The output dimensions are <code>maxlength(components) x length(simulation.design)</code> for single-channel components and   <code>n_channels(components) x maxlength(components) x length(simulation.design)</code> for multi-channel components.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = SingleSubjectDesign(; conditions = Dict(:cond =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), β = [1, 0.5]);
julia&gt; c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [2]);

julia&gt; simulation = Simulation(design, [c1, c2], UniformOnset(; width = 0, offset = 30), PinkNoise());

julia&gt; using StableRNGs

julia&gt; simulate_responses(StableRNG(1), [c1, c2], simulation)
45×2 Matrix{Float64}:
 0.0        0.0
 0.0        0.0
 0.0        0.0
 0.0        0.0
 0.0        0.0
 ⋮          
 0.352614   0.352614
 0.203907   0.203907
 0.0924246  0.0924246
 0.0233794  0.0233794
 0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L441-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.weight_σs-Tuple{Dict, Float64, Float64}" href="#UnfoldSim.weight_σs-Tuple{Dict, Float64, Float64}"><code>UnfoldSim.weight_σs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weight_σs(σs::Dict, b_σs::Float64, σ_lmm::Float64)</code></pre><p>Weight a <code>σs</code> Dict for MixedModels.jl by <code>b_σs</code>, a scaling factor typically from a <code>basis</code>.</p><p>Finally scales it again by <code>σ_lmm</code>, as a trick to simulate noise-free LMMs (see <code>MixedModelsComponent</code>)</p><p>In the future, we anticipate a function     <code>function weight_σs(σs::Dict,b_σs::Dict,σ_lmm::Float64)</code> where each <code>σs</code> entry can be weighted individually by a matching <code>b_σs</code>, but it is not implemented.</p><p><strong>Arguments</strong></p><ul><li><code>σs::Dict</code> = a Dict of random effects as output of MixedModels.create_re</li><li><code>b_σs::Float64</code> = a scaling factor, typically one entry of a basis function from a component</li><li><code>σ_lmm::Float64</code> = a scaling factor to simulate near-zero noise LMMs</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">`NamedTuple` of the weighted random effects</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/049377e558ab0334691d1f625f599bab6b636270/src/component.jl#L394-L412">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/HowTo/predefinedData/">« Use existing experimental designs &amp; onsets in the simulation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 26 November 2024 09:40">Tuesday 26 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
