<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API / Docstrings ¬∑ UnfoldSim.jl</title><meta name="title" content="API / Docstrings ¬∑ UnfoldSim.jl"/><meta property="og:title" content="API / Docstrings ¬∑ UnfoldSim.jl"/><meta property="twitter:title" content="API / Docstrings ¬∑ UnfoldSim.jl"/><meta name="description" content="Documentation for UnfoldSim.jl."/><meta property="og:description" content="Documentation for UnfoldSim.jl."/><meta property="twitter:description" content="Documentation for UnfoldSim.jl."/><meta property="og:url" content="https://unfoldtoolbox.github.io/UnfoldSim.jl/api/"/><meta property="twitter:url" content="https://unfoldtoolbox.github.io/UnfoldSim.jl/api/"/><link rel="canonical" href="https://unfoldtoolbox.github.io/UnfoldSim.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="UnfoldSim.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installing Julia &amp; UnfoldSim.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/tutorials/quickstart/">Quickstart</a></li><li><a class="tocitem" href="../generated/tutorials/simulateERP/">Simulate event-related potentials (ERPs)</a></li><li><a class="tocitem" href="../generated/tutorials/poweranalysis/">Power analysis</a></li><li><a class="tocitem" href="../generated/tutorials/multisubject/">Multi-subject simulation</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../generated/reference/overview/">Overview of functionality</a></li><li><a class="tocitem" href="../generated/reference/designtypes/">Overview: Experimental design types</a></li><li><a class="tocitem" href="../generated/reference/basistypes/">Overview: Basis function (component) types</a></li><li><a class="tocitem" href="../generated/reference/onsettypes/">Overview: Onset types</a></li><li><a class="tocitem" href="../generated/reference/noisetypes/">Overview: Noise types</a></li></ul></li><li><span class="tocitem">HowTo</span><ul><li><a class="tocitem" href="../generated/HowTo/newDesign/">Define a new (imbalanced) design</a></li><li><a class="tocitem" href="../generated/HowTo/repeatTrials/">Get multiple trials with identical subject/item combinations</a></li><li><a class="tocitem" href="../generated/HowTo/newComponent/">Define a new component (with variable duration and shift)</a></li><li><a class="tocitem" href="../generated/HowTo/multichannel/">Generate multi channel data</a></li><li><a class="tocitem" href="../generated/HowTo/predefinedData/">Use existing experimental designs &amp; onsets in the simulation</a></li></ul></li><li><a class="tocitem" href="../developer_docs/">Developer documentation</a></li><li class="is-active"><a class="tocitem" href>API / Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API / Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API / Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/unfoldtoolbox/UnfoldSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.AutoRegressiveNoise" href="#UnfoldSim.AutoRegressiveNoise"><code>UnfoldSim.AutoRegressiveNoise</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AutoRegressiveNoise &lt;: AbstractNoise</code></pre><p>Not implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.ExponentialNoise" href="#UnfoldSim.ExponentialNoise"><code>UnfoldSim.ExponentialNoise</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExponentialNoise &lt;: AbstractNoise</code></pre><p>Type for generating noise with exponential decay in AR spectrum.</p><p>Tip: To manually create noise samples use the <a href="#UnfoldSim.simulate_noise"><code>simulate_noise</code></a> function.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>With the current implementation we try to get exponential decay over the whole autoregressive (AR) spectrum, which is N samples (the total number of samples in the signal) long. This involves the inversion of a Cholesky matrix of size NxN matrix, which will need lots of RAM for non-trivial problems.</p></div></div><p><strong>Fields</strong></p><ul><li><code>noiselevel = 1</code> (optional): Factor that is used to scale the noise.</li><li><code>ŒΩ = 1.5</code> (optional): Exponential factor of AR decay &quot;nu&quot;.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; noise = ExponentialNoise()
ExponentialNoise
  noiselevel: Int64 1
  ŒΩ: Float64 1.5

julia&gt; using StableRNGs

julia&gt; simulate_noise(StableRNG(1), noise, 5)
5-element Vector{Float64}:
  -5.325200748641231
  -3.437402125380177
   2.7852625669058884
  -1.5381022393382109
 -14.818799857226612</code></pre><p>See also <a href="#UnfoldSim.PinkNoise"><code>PinkNoise</code></a>, <a href="#UnfoldSim.RedNoise"><code>RedNoise</code></a>, <a href="#UnfoldSim.NoNoise"><code>NoNoise</code></a>, <a href="#UnfoldSim.WhiteNoise"><code>WhiteNoise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L161-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.Hartmut" href="#UnfoldSim.Hartmut"><code>UnfoldSim.Hartmut</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hartmut &lt;: AbstractHeadmodel</code></pre><p>Type for accessing the HArtMuT model (Harmening et al., 2022), a head model which includes not only brain sources but also muscular and ocular sources.</p><p>Note: Use <code>Hartmut()</code> to create an instance of this head model.</p><p><strong>Fields</strong></p><ul><li><code>artefacual::Any</code>: Dict with artefactual sources (e.g. muscular and ocular) containing label, leadfield, orientation and position.</li><li><code>cortical::Any</code>:  Dict with cortical sources containing label, leadfield, orientation and position.</li><li><code>electrodes::Any</code>: Dict with electrode labels and their positions in 3D space.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = Hartmut()
Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce
HArtMuT-Headmodel
227 electrodes:  (AF3,AF3h...) - hartmut.electrodes
2004 source points: (Left Middle Temporal Gyrus, posterior division,...) - hartmut.cortical
4260 source points: (Muscle_DepressorLabii_left,...) - hartmut.artefactual

In addition to UnfoldSim.jl please cite:
HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce

# Access artefactual sources
julia&gt; h.artefactual
Dict{String, Any} with 4 entries:
  &quot;label&quot;       =&gt; [&quot;Muscle_DepressorLabii_left&quot;, &quot;Muscle_DepressorLabii_left&quot;, &quot;Muscle_DepressorLabii_left&quot;, &quot;Muscle_DepressorLabii_left&quot;, &quot;Muscle_DepressorLabii_left&quot;, &quot;Muscle_DepressorLabii_left&quot;, &quot;Muscle_DepressorLabii_left&quot;, &quot;Mu‚Ä¶
  &quot;leadfield&quot;   =&gt; [-0.00148682 -0.00229078 ‚Ä¶ -0.307231 -0.321305; 0.0141537 0.0134523 ‚Ä¶ -0.141177 -0.140583; ‚Ä¶ ; 0.108747 0.1091 ‚Ä¶ 0.106614 0.117126; 0.0257134 0.0248186 ‚Ä¶ 0.00105064 -0.00433068;;; 0.0898798 0.0891799 ‚Ä¶ 2.02466 1.81‚Ä¶
  &quot;orientation&quot; =&gt; [0.54244 0.482395 -0.687789; 0.546949 0.507161 -0.666059; ‚Ä¶ ; 0.193693 -0.979684 0.0519768; 0.327641 -0.944196 -0.0338583]
  &quot;pos&quot;         =&gt; [-29.3728 58.6061 -120.829; -28.4183 59.0185 -121.448; ‚Ä¶ ; -21.8088 70.5968 -28.7679; -21.1545 70.1282 -31.4184]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/headmodel.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.LinearModelComponent" href="#UnfoldSim.LinearModelComponent"><code>UnfoldSim.LinearModelComponent</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinearModelComponent &lt;: AbstractComponent</code></pre><p>A multiple regression component for one subject.</p><p>All fields can be named. Works best with <a href="#UnfoldSim.SingleSubjectDesign"><code>SingleSubjectDesign</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>basis::Any</code>: an object, if accessed, provides a &#39;basis function&#39;, e.g. <code>hanning(40)::Vector</code>, this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects</li><li><code>formula::Any</code>: StatsModels <code>formula</code> object, e.g.  <code>@formula 0 ~ 1 + cond</code> (left-hand side must be 0).</li><li><code>Œ≤::Vector</code> Vector of betas/coefficients, must fit the formula.</li><li><code>contrasts::Dict</code> (optional): Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding.    For more information see <a href="https://juliastats.org/StatsModels.jl/stable/contrasts">https://juliastats.org/StatsModels.jl/stable/contrasts</a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; LinearModelComponent(;
           basis = hanning(40),
           formula = @formula(0 ~ 1 + cond),
           Œ≤ = [1., 2.],
           contrasts = Dict(:cond =&gt; EffectsCoding())
       )
LinearModelComponent
  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  ‚Ä¶  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]
  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term}}
  Œ≤: Array{Float64}((2,)) [1.0, 2.0]
  contrasts: Dict{Symbol, EffectsCoding}</code></pre><p>See also <a href="#UnfoldSim.MixedModelComponent"><code>MixedModelComponent</code></a>, <a href="#UnfoldSim.MultichannelComponent"><code>MultichannelComponent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L42-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.LogNormalOnset" href="#UnfoldSim.LogNormalOnset"><code>UnfoldSim.LogNormalOnset</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LogNormalOnset &lt;: AbstractOnset</code></pre><p>Log-normal inter-event distances (in samples) using the <code>Distributions.jl</code> truncated LogNormal distribution (<a href="https://juliastats.org/Distributions.jl/stable/univariate/#Distributions.LogNormal">code and mathematical reference</a>).</p><p>Be careful with large <code>Œº</code> and <code>œÉ</code> values, as they are on logscale. œÉ&gt;8 can quickly give you out-of-memory sized signals! <br/>Tip: To manually generate inter-event distance samples use the <a href="#UnfoldSim.simulate_interonset_distances"><code>simulate_interonset_distances</code></a> function.</p><p><strong>Fields</strong></p><ul><li><code>Œº</code>: The mean of the log-transformed variable (the log-normal random variable&#39;s logarithm follows a normal distribution).</li><li><code>œÉ</code>: The standard deviation of the log-transformed variable.</li><li><code>offset = 0</code> (optional): The minimal distance between events.</li><li><code>truncate_upper = nothing</code> (optional): Upper limit (in samples) at which the distribution is truncated.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; onset_distribution = LogNormalOnset(3, 0.25, 10, 25)
LogNormalOnset
  Œº: Int64 3
  œÉ: Float64 0.25
  offset: Int64 10
  truncate_upper: Int64 25</code></pre><p>See also <a href="../generated/reference/onsettypes/#UniformOnset"><code>UniformOnset</code></a>, <a href="#UnfoldSim.NoOnset"><code>NoOnset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/onset.jl#L30-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.MixedModelComponent" href="#UnfoldSim.MixedModelComponent"><code>UnfoldSim.MixedModelComponent</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MixedModelComponent &lt;: AbstractComponent</code></pre><p>A component that adds a hierarchical relation between parameters according to a Linear Mixed Model (LMM) defined via <code>MixedModels.jl</code>.</p><p>All fields can be named. Works best with <a href="#UnfoldSim.MultiSubjectDesign"><code>MultiSubjectDesign</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>basis::Any</code>: an object, if accessed, provides a &#39;basis function&#39;, e.g. <code>hanning(40)::Vector</code>, this defines the response at a single event. It will be weighted by the model prediction. Future versions will allow for functions, as of v0.3 this is restricted to array-like objects</li><li><code>formula::Any</code>: Formula-object in the style of MixedModels.jl e.g. <code>@formula 0 ~ 1 + cond + (1|subject)</code>. The left-hand side is ignored.</li><li><code>Œ≤::Vector</code> Vector of betas (fixed effects), must fit the formula.</li><li><code>œÉs::Dict</code> Dict of random effect variances, e.g. <code>Dict(:subject =&gt; [0.5, 0.4])</code> or to specify correlation matrix <code>Dict(:subject=&gt;[0.5,0.4,I(2,2)],...)</code>. Technically, this will be passed to the MixedModels.jl <code>create_re</code> function, which creates the Œ∏ matrices.</li><li><code>contrasts::Dict</code> (optional): Dict in the style of MixedModels.jl. Determines which coding scheme to use for which categorical variables. Default is empty which corresponds to dummy coding. For more information see <a href="https://juliastats.org/StatsModels.jl/stable/contrasts">https://juliastats.org/StatsModels.jl/stable/contrasts</a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; MixedModelComponent(;
           basis = hanning(40),
           formula = @formula(0 ~ 1 + cond + (1 + cond|subject)),
           Œ≤ = [1., 2.],
           œÉs= Dict(:subject =&gt; [0.5, 0.4]),
           contrasts=Dict(:cond =&gt; EffectsCoding())
       )
MixedModelComponent
  basis: Array{Float64}((40,)) [0.0, 0.006474868681043577, 0.02573177902642726, 0.0572719871733951, 0.10027861829824952, 0.1536378232452003, 0.21596762663442215, 0.28565371929847283, 0.3608912680417737, 0.43973165987233853  ‚Ä¶  0.43973165987233853, 0.3608912680417737, 0.28565371929847283, 0.21596762663442215, 0.1536378232452003, 0.10027861829824952, 0.0572719871733951, 0.02573177902642726, 0.006474868681043577, 0.0]
  formula: StatsModels.FormulaTerm{StatsModels.ConstantTerm{Int64}, Tuple{StatsModels.ConstantTerm{Int64}, StatsModels.Term, StatsModels.FunctionTerm{typeof(|), Vector{StatsModels.AbstractTerm}}}}
  Œ≤: Array{Float64}((2,)) [1.0, 2.0]
  œÉs: Dict{Symbol, Vector{Float64}}
  contrasts: Dict{Symbol, EffectsCoding}</code></pre><p>See also <a href="#UnfoldSim.LinearModelComponent"><code>LinearModelComponent</code></a>, <a href="#UnfoldSim.MultichannelComponent"><code>MultichannelComponent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.MultiSubjectDesign" href="#UnfoldSim.MultiSubjectDesign"><code>UnfoldSim.MultiSubjectDesign</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultiSubjectDesign &lt;: AbstractDesign</code></pre><p>A type for specifying the experimental design for multiple subjects (based on the given random-effects structure).</p><p>Tip: Check the resulting dataframe using the <a href="#UnfoldSim.generate_events"><code>generate_events</code></a> function. <br/>Please note that the number of items <code>n_items</code> has to be a multiple of the number of between-item levels. The sample applies for <code>n_subjects</code> and the number of between-subject levels.</p><p><strong>Fields</strong></p><ul><li><code>n_subjects::Int</code>: Number of subjects.</li><li><code>n_items::Int</code>: Number of items/stimuli (sometimes ‚âà trials).</li><li><code>subjects_between::Dict{Symbol,Vector}</code>: Effects between subjects, e.g. young vs old.</li><li><code>items_between::Dict{Symbol,Vector}</code>: Effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified also in <code>subjects_between</code>).</li><li><code>both_within::Dict{Symbol,Vector}</code>: Effects completely crossed i.e. conditions/covariates that are both within-subject and within-item.</li><li><code>event_order_function = (rng, x) -&gt; x</code>: Can be used to sort, or shuffle the events e.g. <code>(rng, x) -&gt; shuffle(rng, x)</code> (or shorter just <code>event_order_function = shuffle</code>).   The default is the identify function, i.e. not changing the order of the events.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Declaring the same condition both between-subject and between-item results in a full between-subject/item design.
julia&gt; design = MultiSubjectDesign(;
                       n_items = 10,
                       n_subjects = 30,
                       subjects_between = Dict(:cond =&gt; [&quot;levelA&quot;, &quot;levelB&quot;]),
                       items_between = Dict(:cond =&gt; [&quot;levelA&quot;, &quot;levelB&quot;]),
                       )
MultiSubjectDesign
  n_subjects: Int64 30
  n_items: Int64 10
  subjects_between: Dict{Symbol, Vector}
  items_between: Dict{Symbol, Vector}
  both_within: Dict{Symbol, Vector}
  event_order_function: #3 (function of type UnfoldSim.var&quot;#3#7&quot;)

julia&gt; generate_events(StableRNG(1), design)
150√ó3 DataFrame
 Row ‚îÇ subject  cond    item   
     ‚îÇ String   String  String 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ S01      levelA  I01
   2 ‚îÇ S01      levelA  I03
   3 ‚îÇ S01      levelA  I05
  ‚ãÆ  ‚îÇ    ‚ãÆ       ‚ãÆ       ‚ãÆ
 148 ‚îÇ S30      levelB  I06
 149 ‚îÇ S30      levelB  I08
 150 ‚îÇ S30      levelB  I10
               144 rows omitted</code></pre><p>See also <a href="#UnfoldSim.SingleSubjectDesign"><code>SingleSubjectDesign</code></a>, <a href="#UnfoldSim.RepeatDesign"><code>RepeatDesign</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L55-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.MultichannelComponent" href="#UnfoldSim.MultichannelComponent"><code>UnfoldSim.MultichannelComponent</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MultichannelComponent &lt;: AbstractComponent</code></pre><p>Projects a <code>AbstractComponent</code> to multiple &quot;channels&quot; via the <code>projection</code> vector.</p><p>Optionally, <code>noise</code> can be added to the source prior to projection. By default a <code>MultichannelComponent</code> can be constructed using one of the following options for <code>projection</code>:</p><ul><li><code>projection::AbstractVector</code>: Directly pass a custom projection vector.</li><li><code>projection::Pair{&lt;:AbstractHeadmodel,String}</code>: Generate a projection vector by specifying which headmodel to use and which sources should be active.</li></ul><p><strong>Fields</strong></p><ul><li><code>component::AbstractComponent</code>: The component that should be projected to the sensors.</li><li><code>projection::AbstractVector</code> or <code>projection::Pair{&lt;:AbstractHeadmodel,String}</code>: Vector <code>p</code> that projects the (source) component <code>c[t]</code> (where <code>t</code> is time) to the sensors <code>s</code>.   The length of <code>p</code> equals the number of sensors <code>s</code>. Typically, it is a slice of the leadfield matrix. <code>out[s,t] = p[s]*c[t]</code>.</li><li><code>noise::AbstractNoise</code> (optional): Noise added in the source space. Default is <code>NoNoise</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Variant 1: Specify the projection vector manually
julia&gt; c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), Œ≤ = [1]);

julia&gt; mc1 = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1])
MultichannelComponent
  component: LinearModelComponent
  projection: Array{Float64}((7,)) [1.0, 2.0, -1.0, 3.0, 5.0, 2.3, 1.0]
  noise: NoNoise NoNoise()

# Variant 2: Use a headmodel and specify a source
julia&gt; c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), Œ≤ = [1]);

julia&gt; hart = headmodel(type = &quot;hartmut&quot;);
Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce

julia&gt; mc2 = UnfoldSim.MultichannelComponent(c2, hart =&gt; &quot;Right Occipital Pole&quot;)
MultichannelComponent
  component: LinearModelComponent
  projection: Array{Float64}((227,)) [-0.03461859471337842, -0.04321094803502425, 0.0037088347968313525, -0.014722528968861278, -0.0234889834534478, 0.02731807504242923, 0.038863688452528036, 0.1190531258070562, -0.09956890221613562, -0.0867729334438599  ‚Ä¶  0.37435404409695094, -0.020863789022627935, 0.25627478723535513, -0.05777985212119245, 0.37104376432271147, -0.19446620423767172, 0.2590764703721097, -0.12923837607416555, 0.1732886690359311, 0.4703016561960567]
  noise: NoNoise NoNoise()</code></pre><p>See also <a href="#UnfoldSim.LinearModelComponent"><code>LinearModelComponent</code></a>, <a href="#UnfoldSim.MixedModelComponent"><code>MixedModelComponent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L81-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.NoNoise" href="#UnfoldSim.NoNoise"><code>UnfoldSim.NoNoise</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoNoise &lt;: AbstractNoise</code></pre><p>A type for simulations without noise; return zeros instead of noise.</p><p>Tip: To manually create noise samples use the <a href="#UnfoldSim.simulate_noise"><code>simulate_noise</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; noise = NoNoise()
NoNoise()

julia&gt; using StableRNGs

julia&gt; simulate_noise(StableRNG(1), noise, 3)
3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>See also <a href="#UnfoldSim.PinkNoise"><code>PinkNoise</code></a>, <a href="#UnfoldSim.RedNoise"><code>RedNoise</code></a>, <a href="#UnfoldSim.ExponentialNoise"><code>ExponentialNoise</code></a>, <a href="#UnfoldSim.WhiteNoise"><code>WhiteNoise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L130-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.NoOnset" href="#UnfoldSim.NoOnset"><code>UnfoldSim.NoOnset</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoOnset &lt;: AbstractOnset</code></pre><p>For cases where the user wants to simulate epoched data without any overlap between consecutive events.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; onset_distribution = NoOnset()
NoOnset()</code></pre><p>See also <a href="../generated/reference/onsettypes/#UniformOnset"><code>UniformOnset</code></a>, <a href="../generated/reference/onsettypes/#LogNormalOnset"><code>LogNormalOnset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/onset.jl#L63-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.PinkNoise" href="#UnfoldSim.PinkNoise"><code>UnfoldSim.PinkNoise</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PinkNoise &lt;: AbstractNoise</code></pre><p>A type for generating Pink Noise using the <code>SignalAnalysis.jl</code> implementation.</p><p>The noise values are sampled from a standard normal distribution ùí©(Œº=0, œÉ=1). That means that ~95% of the values are between ~-2 and ~2 (with <code>noiselevel = 1</code>).<br/>Tip: To manually create noise samples use the <a href="#UnfoldSim.simulate_noise"><code>simulate_noise</code></a> function.</p><p><strong>Fields</strong></p><ul><li><code>noiselevel = 1</code> (optional): Factor that is used to scale the noise.</li><li><code>func = SignalAnalysis.PinkGaussian</code> (optional): Function that is used to create the noise samples.   This field is for internal use and should not typically be modified directly by the user.   Changes to this field may result in unexpected behavior.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; noise = PinkNoise(noiselevel = 3)
PinkNoise
  noiselevel: Int64 3
  func: UnionAll

julia&gt; using StableRNGs

julia&gt; simulate_noise(StableRNG(1), noise, 5)
5-element Vector{Float64}:
 2.578878369756878
 3.4972108606501786
 2.878568584946028
 2.2725654770788384
 3.5291669151888683</code></pre><p>See also <a href="#UnfoldSim.RedNoise"><code>RedNoise</code></a>, <a href="#UnfoldSim.WhiteNoise"><code>WhiteNoise</code></a>, <a href="#UnfoldSim.ExponentialNoise"><code>ExponentialNoise</code></a>, <a href="#UnfoldSim.NoNoise"><code>NoNoise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L5-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.RealisticNoise" href="#UnfoldSim.RealisticNoise"><code>UnfoldSim.RealisticNoise</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RealisticNoise &lt;: AbstractNoise</code></pre><p>Not implemented - planned to use Artifacts.jl to provide real EEG data to add.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.RedNoise" href="#UnfoldSim.RedNoise"><code>UnfoldSim.RedNoise</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RedNoise &lt;: AbstractNoise</code></pre><p>A type for generating Red Noise using the <code>SignalAnalysis.jl</code> implementation.</p><p>The noise values are sampled from a standard normal distribution ùí©(Œº=0, œÉ=1). That means that ~95% of the values are between ~-2 and ~2 (with <code>noiselevel = 1</code>).<br/>Tip: To manually create noise samples use the <a href="#UnfoldSim.simulate_noise"><code>simulate_noise</code></a> function.</p><p><strong>Fields</strong></p><ul><li><code>noiselevel = 1</code> (optional): Factor that is used to scale the noise.</li><li><code>func = SignalAnalysis.RedGaussian</code> (optional): Function that is used to create the noise samples.   This field is for internal use and should not typically be modified directly by the user.   Changes to this field may result in unexpected behavior.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; noise = RedNoise(noiselevel = 2)
RedNoise
  noiselevel: Int64 2
  func: UnionAll

julia&gt; using StableRNGs

julia&gt; simulate_noise(StableRNG(2), noise, 3)
3-element Vector{Float64}:
 -0.34153942884005967
 -0.4651387715669636
 -0.4951538876376382</code></pre><p>See also <a href="#UnfoldSim.PinkNoise"><code>PinkNoise</code></a>, <a href="#UnfoldSim.WhiteNoise"><code>WhiteNoise</code></a>, <a href="#UnfoldSim.ExponentialNoise"><code>ExponentialNoise</code></a>, <a href="#UnfoldSim.NoNoise"><code>NoNoise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L46-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.RepeatDesign" href="#UnfoldSim.RepeatDesign"><code>UnfoldSim.RepeatDesign</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RepeatDesign{T} &lt;: AbstractDesign</code></pre><p>Repeat a design (and the corresponding events DataFrame) multiple times to mimick repeatedly recorded trials.</p><p>Tip: Check the resulting dataframe using the <a href="#UnfoldSim.generate_events"><code>generate_events</code></a> function. Please note that when using an <code>event_order_function</code>(e.g. <code>shuffle</code>) in a <code>RepeatDesign</code>, the corresponding RNG is shared across repetitions and not deep-copied for each repetition. As a result, the order of events will differ for each repetition.</p><p><strong>Fields</strong></p><ul><li><code>design::T</code>: The experimental design that should be repeated.</li><li><code>repeat::Int = 1</code>: The number of repetitions.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs # For using the `generate_events` function in a reproducible way

julia&gt; design_once =
           SingleSubjectDesign(;
               conditions = Dict(
                   :stimulus_type =&gt; [&quot;natural&quot;, &quot;artificial&quot;],
                   :contrast_level =&gt; range(0, 1, length = 2),
               ),
               event_order_function = shuffle,
           );

julia&gt; generate_events(StableRNG(1), design_once)
4√ó2 DataFrame
 Row ‚îÇ contrast_level  stimulus_type 
     ‚îÇ Float64         String        
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ            1.0  natural
   2 ‚îÇ            1.0  artificial
   3 ‚îÇ            0.0  natural
   4 ‚îÇ            0.0  artificial

julia&gt; design = RepeatDesign(design_once, 2)
RepeatDesign{SingleSubjectDesign}
  design: SingleSubjectDesign
  repeat: Int64 2

julia&gt; generate_events(StableRNG(1), design)
8√ó2 DataFrame
 Row ‚îÇ contrast_level  stimulus_type 
     ‚îÇ Float64         String        
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ            1.0  natural
   2 ‚îÇ            1.0  artificial
   3 ‚îÇ            0.0  natural
   4 ‚îÇ            0.0  artificial
   5 ‚îÇ            1.0  artificial
   6 ‚îÇ            0.0  natural
   7 ‚îÇ            1.0  natural
   8 ‚îÇ            0.0  artificial</code></pre><p>See also <a href="#UnfoldSim.SingleSubjectDesign"><code>SingleSubjectDesign</code></a>, <a href="#UnfoldSim.MultiSubjectDesign"><code>MultiSubjectDesign</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L115-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.Simulation" href="#UnfoldSim.Simulation"><code>UnfoldSim.Simulation</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Simulation</code></pre><p>A type to store all &quot;ingredients&quot; for a simulation including their parameters.</p><p>Can either be created by the user or will be created automatically when calling the <a href="#UnfoldSim.simulate"><code>simulate</code></a> function with the required &quot;ingredients&quot;. Tip: Use the <code>subtypes</code> function to get an overview of the implemented &quot;ingredients&quot;, e.g. <code>subtypes(AbstractDesign)</code>.</p><p><strong>Fields</strong></p><ul><li><code>design::AbstractDesign</code>: Experimental design.</li><li><code>components::Vector{AbstractComponent}</code>: Response function(s) for the events (e.g. the ERP shape in EEG).</li><li><code>onset::AbstractOnset</code>: Inter-onset distance distribution.</li><li><code>noisetype::AbstractNoise</code>: Noise type.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = SingleSubjectDesign(; conditions = Dict(:stimulus_type =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; component = LinearModelComponent(;
           basis = p100(),
           formula = @formula(0 ~ 1 + stimulus_type),
           Œ≤ = [2, 3],
       );

julia&gt; onset = UniformOnset();

julia&gt; noise = PinkNoise();

julia&gt; simulation = Simulation(design, component, onset, noise);

julia&gt; using StableRNGs

julia&gt; data, events = simulate(StableRNG(1), simulation);

julia&gt; events
2√ó2 DataFrame
 Row ‚îÇ stimulus_type  latency 
     ‚îÇ String         Int64   
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ natural             20
   2 ‚îÇ artificial          70

julia&gt; data
85-element Vector{Float64}:
  0.8596261232522926
  1.1657369535500595
  0.9595228616486761
  ‚ãÆ
  0.9925202143746904
  0.2390652543395527
 -0.11672523788068771</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/types.jl#L13-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.SingleSubjectDesign" href="#UnfoldSim.SingleSubjectDesign"><code>UnfoldSim.SingleSubjectDesign</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SingleSubjectDesign &lt;: AbstractDesign</code></pre><p>A type for specifying the experimental design for a single subject (based on the given conditions).</p><p>Tip: Check the resulting dataframe using the <a href="#UnfoldSim.generate_events"><code>generate_events</code></a> function. <br/>The number of trials/rows in the output of <code>generate_events([rng, ]design)</code> depends on the full factorial of your <code>conditions</code>. <br/>To increase the number of repetitions, e.g. by 5, simply use <code>RepeatDesign(SingleSubjectDesign(...), 5)</code>. <br/>If conditions are omitted (or set to <code>nothing</code>), a single trial is simulated with a column <code>:dummy</code> and content <code>:dummy</code> - this is for convenience.</p><p><strong>Fields</strong></p><ul><li><code>conditions::Dict{Symbol,Vector}</code>: Experimental conditions, e.g. <code>Dict(:A =&gt; [&quot;a_small&quot;,&quot;a_big&quot;], :B =&gt; [&quot;b_tiny&quot;,&quot;b_large&quot;])</code>.</li><li><code>event_order_function = (rng, x) -&gt; x</code>: Can be used to sort by specifying <code>sort</code>, or shuffling by providing <code>shuffle</code>, or custom functions following the interface <code>(rng, x) -&gt; my_shuffle(rng,x)</code>.   The default is the identify function, i.e. not changing the order of the events.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs # For using the `generate_events` function in a reproducible way

julia&gt; design =
           SingleSubjectDesign(;
               conditions = Dict(
                   :stimulus_type =&gt; [&quot;natural&quot;, &quot;artificial&quot;],
                   :contrast_level =&gt; range(0, 1, length = 5),
               ),
           )
SingleSubjectDesign
  conditions: Dict{Symbol, Vector}
  event_order_function: #10 (function of type UnfoldSim.var&quot;#10#14&quot;)

julia&gt; generate_events(StableRNG(1), design)
10√ó2 DataFrame
 Row ‚îÇ contrast_level  stimulus_type 
     ‚îÇ Float64         String        
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ           0.0   natural
   2 ‚îÇ           0.25  natural
   3 ‚îÇ           0.5   natural
  ‚ãÆ  ‚îÇ       ‚ãÆ               ‚ãÆ
   8 ‚îÇ           0.5   artificial
   9 ‚îÇ           0.75  artificial
  10 ‚îÇ           1.0   artificial
                       4 rows omitted</code></pre><p>See also <a href="#UnfoldSim.MultiSubjectDesign"><code>MultiSubjectDesign</code></a>, <a href="#UnfoldSim.RepeatDesign"><code>RepeatDesign</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L3-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.UniformOnset" href="#UnfoldSim.UniformOnset"><code>UnfoldSim.UniformOnset</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UniformOnset &lt;: AbstractOnset</code></pre><p>Provide a Uniform Distribution for the inter-event distances (in samples).</p><p>Tip: To manually generate inter-event distance samples use the <a href="#UnfoldSim.simulate_interonset_distances"><code>simulate_interonset_distances</code></a> function.</p><p><strong>Fields</strong></p><ul><li><code>width = 50</code> (optional): Width of the uniform distribution (=&gt; the &quot;jitter&quot;). Since the lower bound is 0, <code>width</code> is also the upper bound.</li><li><code>offset = 0</code> (optional): The minimal distance between events. The maximal distance is <code>offset + width</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; onset_distribution = UniformOnset(width = 25, offset = 5)
UniformOnset
  width: Int64 25
  offset: Int64 5</code></pre><p>See also <a href="../generated/reference/onsettypes/#LogNormalOnset"><code>LogNormalOnset</code></a>, <a href="#UnfoldSim.NoOnset"><code>NoOnset</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/onset.jl#L5-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.WhiteNoise" href="#UnfoldSim.WhiteNoise"><code>UnfoldSim.WhiteNoise</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WhiteNoise &lt;: AbstractNoise</code></pre><p>A type for generating White Noise using <code>randn</code> - thus Gaussian noise.</p><p>The noise values are sampled from a standard normal distribution ùí©(Œº=0, œÉ=1). That means that ~95% of the values are between ~-2 and ~2 (with <code>noiselevel = 1</code>).<br/>Tip: To manually create noise samples use the <a href="#UnfoldSim.simulate_noise"><code>simulate_noise</code></a> function.</p><p><strong>Fields</strong></p><ul><li><code>noiselevel = 1</code> (optional): Factor that is used to scale the noise.</li><li><code>imfilter = nothing</code> (optional): Use <code>imfilter &gt; 0</code> to smooth the noise using <code>Image.imfilter</code> with a Gaussian kernel with <code>œÉ = imfilter</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; noise = WhiteNoise()
WhiteNoise
  noiselevel: Int64 1
  imfilter: Nothing nothing

julia&gt; using StableRNGs

julia&gt; simulate_noise(StableRNG(1), noise, 3)
3-element Vector{Float64}:
 -0.5325200748641231
  0.098465514284785
  0.7528865221245234</code></pre><p>See also <a href="#UnfoldSim.PinkNoise"><code>PinkNoise</code></a>, <a href="#UnfoldSim.RedNoise"><code>RedNoise</code></a>, <a href="#UnfoldSim.ExponentialNoise"><code>ExponentialNoise</code></a>, <a href="#UnfoldSim.NoNoise"><code>NoNoise</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L85-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.length-Tuple{AbstractDesign}" href="#Base.length-Tuple{AbstractDesign}"><code>Base.length</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Length is the product of all dimensions and equals the number of events in the corresponding events dataframe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.size-Tuple{MultiSubjectDesign}" href="#Base.size-Tuple{MultiSubjectDesign}"><code>Base.size</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Return the dimensions of the experiment design.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DSP.Windows.hanning-Tuple{Any, Any, Any}" href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>DSP.Windows.hanning</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hanning(duration, offset, sfreq)</code></pre><p>Generate a (potentially shifted) hanning window with a certain duration. </p><p>Note: This function extends the <code>DSP.hanning</code> function using multiple dispatch.</p><p><strong>Arguments</strong></p><ul><li><code>duration</code>: in s.</li><li><code>offset</code>: in s, defines hanning peak i.e. shift of the hanning window.</li><li><code>sfreq</code>: Sampling rate in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; UnfoldSim.hanning(0.1, 0.3, 100)
25-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 ‚ãÆ
 0.9698463103929542
 0.75
 0.41317591116653485
 0.11697777844051105
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/bases.jl#L130-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.PuRF-Tuple{}" href="#UnfoldSim.PuRF-Tuple{}"><code>UnfoldSim.PuRF</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PuRF(; n = 10.1, tmax = 0.93, sfreq = 100)</code></pre><p>Default generator for PuRF Pupil Response Function. The canonical PRF is a gamma function and implemented according to Denison 2020 equation (2) going back to Hoeks &amp; Levelt, 1993.</p><p>The pupil response is evaluated at t = 0:1/sfreq:3*tmax. The response is normalized by the peak-maximum at tmax, thus typically a pupil-response of 1 is returned (disregarding numerical issues).</p><p><strong>Keyword arguments:</strong></p><ul><li><code>n = 10.1</code>: shape parameter</li><li><code>tmax = 0.93</code>: peak maximum</li><li><code>sfreq = 100</code>: sampling frequency</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: canonical pupil response with length(0:1/sfreq:3*tmax) entries.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PuRF(; n = 5)
280-element Vector{Float64}:
 0.0
 2.0216617815131253e-8
 6.130689396024061e-7
 4.4118063684811444e-6
 1.761817666835793e-5
 ‚ãÆ
 0.012726253506722554
 0.012280989091455786
 0.011850525657416842
 0.011434405338911133
 0.011032182932283816</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/bases.jl#L169-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}" href="#UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}"><code>UnfoldSim.add_noise!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_noise!(rng, noisetype::AbstractNoise, signal)</code></pre><p>Generate and add noise to a signal.</p><p>Assumes that the signal can be linearized, that is, that the noise is stationary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L280-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}" href="#UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}"><code>UnfoldSim.add_responses!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_responses!(signal, responses::Vector, e, s, tvec, trial_idx)
add_responses!(signal, responses::Matrix, e, s, tvec, trial_idx)
add_responses!(signal, responses::AbstractArray, e, s, tvec, trial_idx)</code></pre><p>Add (in-place) the given <code>responses</code> to the <code>signal</code>, for both 2D (1 channel) and 3D (X channel case). Helper function.</p><p><strong>Arguments</strong></p><ul><li><code>signal</code>: Continuous EEG signal to be modified in place. Has the dimensions <code>channels x continuous_time x subjects</code>.</li><li><code>responses::Union{Vector, Matrix, AbstractArray}</code>: Responses to be added. In the multi-channel case, the dimensions are <code>channels x maxlength(components) x length(simulation.design)</code>, else <code>maxlength(components) x length(simulation.design)</code>.  The data for all the subjects and their respective trials is concatenated.</li><li><code>e</code>: Index of the channel (in <code>signal</code>) for which to add the response.</li><li><code>s</code>: Index of the subject (in <code>signal</code>) for which to add the response.</li><li><code>tvec</code>: Time points (indices in <code>signal</code>) at which to add the response.</li><li><code>trial_idx</code>: Index of the particular trial (in <code>responses</code>) from where the response is to be added.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: <code>signal</code> is modified in-place.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; signal, responses, tvec = zeros(5,15,2), ones(5,6), 1:5;

julia&gt; UnfoldSim.add_responses!(signal, responses, 1, 2, tvec, 5);

julia&gt; signal
5√ó15√ó2 Array{Float64, 3}:
[:, :, 1] =
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0

[:, :, 2] =
 1.0  1.0  1.0  1.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/simulation.jl#L292-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.apply_event_order_function-Tuple{Any, Any, Any}" href="#UnfoldSim.apply_event_order_function-Tuple{Any, Any, Any}"><code>UnfoldSim.apply_event_order_function</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_event_order_function(fun, rng, events)</code></pre><p>Apply <code>fun(rng, events)</code>, raise an error if function <code>fun</code> is wrongly defined. Convenience function to not repeat the error handling at multiple places.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.closest_src-Tuple{AbstractVector{&lt;:AbstractVector}, Any}" href="#UnfoldSim.closest_src-Tuple{AbstractVector{&lt;:AbstractVector}, Any}"><code>UnfoldSim.closest_src</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closest_src(coords_list::AbstractVector{&lt;:AbstractVector}, pos)</code></pre><p>When applied to a vector of target coordinate vectors, return the index of the closest position in <code>pos</code> for each of the targets. </p><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Index of the closest position in <code>pos</code> for each vector in <code>coords_list</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; positions = [0 0 0; 2 2 2; 3 3 3; 4 4 4];
julia&gt; target_coordinate_vectors = [[0.5, 0, 0.5], [10, 1, 8]];

julia&gt; UnfoldSim.closest_src(target_coordinate_vectors, positions)
2-element Vector{Int64}:
 1
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/helper.jl#L109-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.closest_src-Tuple{Hartmut, String}" href="#UnfoldSim.closest_src-Tuple{Hartmut, String}"><code>UnfoldSim.closest_src</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closest_src(head::Hartmut, label::String)</code></pre><p>Return the index of the Harmut model source point that is closest (using Euclidean distance) to the mean position of the source points matching the given <code>label</code>.</p><div class="admonition is-category-important"><header class="admonition-header">Important</header><div class="admonition-body"><p>We use the average in Euclidean space, but the cortex is a curved surface. In most cases they will not overlap. Ideally we would calculate the average on the surface, but this is a bit more complex to do (you&#39;d need to calculate the vertices etc.).</p></div></div><p><strong>Arguments</strong></p><ul><li><code>head::Hartmut</code>: Headmodel of type <code>Hartmut</code>.</li><li><code>label::String</code>: Label of the source point(s) of interest.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Index of the closest Hartmut source point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hartmut = Hartmut();
Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce

julia&gt; label = &quot;Right Cingulate Gyrus, posterior division&quot;;

julia&gt; UnfoldSim.closest_src(hartmut, label)
1875</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/helper.jl#L131-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.closest_src-Tuple{Vector{&lt;:Real}, Any}" href="#UnfoldSim.closest_src-Tuple{Vector{&lt;:Real}, Any}"><code>UnfoldSim.closest_src</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">closest_src(coords::Vector{&lt;:Real}, pos)</code></pre><p>Return the index of the position that is closest to the target coordinates (using the Euclidean distance).</p><p><strong>Arguments</strong></p><ul><li><code>coords::Vector{&lt;:Real}</code>: Target coordinate vector (typically with length 3).</li><li><code>pos</code>: Matrix that contains all possible positions.   Its dimensions are the number of positions <code>n</code> times number of entries in the position coordinate vectors (usually 3) i.e. <code>n x 3</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Row index of the position in <code>pos</code> that is closest to <code>coords</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; positions = [0 0 0; 2 2 2; 3 3 3; 4 4 4]
4√ó3 Matrix{Int64}:
 0  0  0
 2  2  2
 3  3  3
 4  4  4

julia&gt; target_coordinates = [0.5, 0, 0.5]
3-element Vector{Float64}:
 0.5
 0.0
 0.5

 julia&gt; UnfoldSim.closest_src(target_coordinates, positions)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/helper.jl#L62-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}" href="#UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}"><code>UnfoldSim.create_continuous_signal</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_continuous_signal(rng, responses, simulation)</code></pre><p>Simulate onset latencies and add together a continuous signal, based on the given responses and simulation parameters. Helper function.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator, important to ensure reproducibility.</li><li><code>responses</code>: Responses to be combined with the given onsets.</li><li><code>simulation</code>: Simulation parameters, including design, components, onsets, and noisetype.</li></ul><p><strong>Returns</strong></p><ul><li><code>(signal, latencies)::Tuple{Array, Array}</code>:<ul><li><code>signal</code> contains the generated signal. Has the dimensions <code>channels x continuous_time x subjects</code>.</li><li><code>latencies</code> contains the onset latencies.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs # to get an RNG

julia&gt; design = SingleSubjectDesign(; conditions = Dict(:cond =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), Œ≤ = [1, 0.5]);

julia&gt; c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), Œ≤ = [2]);

julia&gt; simulation = Simulation(design, [c1, c2], UniformOnset(; width = 0, offset = 30), PinkNoise());

julia&gt; responses = simulate_responses(StableRNG(1), [c1, c2], simulation)
45√ó2 Matrix{Float64}:
 0.0        0.0
 0.0        0.0
 ‚ãÆ          
 0.0233794  0.0233794
 0.0        0.0

julia&gt; signal, latencies = UnfoldSim.create_continuous_signal(StableRNG(1), responses, simulation);

julia&gt; signal
106-element Vector{Float64}:
 0.0
 0.0
 0.0
 ‚ãÆ
 0.023379444289913343
 0.0
 0.0

 julia&gt; latencies
2-element Vector{Int64}:
 31
 61</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/simulation.jl#L187-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}" href="#UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}"><code>UnfoldSim.epoch</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>epoch(data::AbstractVector, args...; kwargs...)</p><p>One channel case. The data is reshaped and then passed to the multi-channel epoch method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/helper.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.epoch-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Tuple{Number, Number}, Any}} where T&lt;:Union{Missing, Number}" href="#UnfoldSim.epoch-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any, Tuple{Number, Number}, Any}} where T&lt;:Union{Missing, Number}"><code>UnfoldSim.epoch</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">epoch(
    data::AbstractArray{T,2},
    events,
    œÑ::Tuple{Number,Number},
    sfreq;
    eventtime::Symbol = :latency,
) where {T&lt;:Union{Missing,Number}}</code></pre><p>Helper function to segment continuous <code>data</code> into epochs based on the given <code>events</code> and the time window <code>œÑ</code>.</p><p>Adapted from Unfold.jl: https://github.com/unfoldtoolbox/Unfold.jl/blob/b3  a21c2bb7e93d2f45ec64b0197f4663a6d7939a/src/utilities.jl#L40</p><p><strong>Arguments</strong></p><ul><li><code>data::AbstractArray{T,2}</code>: Continuous data with the dimensions <code>channels x continuous_time</code>.</li><li><code>events</code>: Events data frame (based on the design) with latencies.</li><li><code>œÑ::Tuple{Number,Number}</code>: Time window for epoching in s.</li><li><code>sfreq</code>: Sampling frequency in Hz.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>eventtime::Symbol = :latency</code>: The name of the column in <code>events</code> that contains the latencies.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array</code>: Epoched data with the dimensions <code>channels x times x event</code> (or <code>times x event</code> for the single channel case).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># One channel example
julia&gt; data, events = UnfoldSim.predef_eeg();

julia&gt; size(data), size(events)
((120199,), (2000, 3))

julia&gt; UnfoldSim.epoch(data, events, (-0.2, 1), 100)
121√ó2000 Matrix{Float64}:
  0.114127   -0.105347     ‚Ä¶  -0.125485   1.6383
  0.128198    0.0474874        0.0112935  1.28122
  0.0547917  -0.0832977       -0.126181   0.850062
  0.0992842  -0.230224        -0.0449072  0.496583
  0.024461   -0.175023        -0.0223837  0.170389
  0.165133   -0.000793527  ‚Ä¶  -0.0278197  0.104454
  ‚ãÆ                        ‚ã±              
 -0.362249    2.91297          0.546699   0.0
 -0.199265    2.58394          0.171159   0.0
 -0.184075    2.34611         -0.0269841  0.0
 -0.13901     2.11971         -0.0552873  0.0
 -0.0674085   1.74561      ‚Ä¶  -0.187959   0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/helper.jl#L168-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.generate_events" href="#UnfoldSim.generate_events"><code>UnfoldSim.generate_events</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_events(design::AbstractDesign)
generate_events(rng::AbstractRNG, design::AbstractDesign)</code></pre><p>Generate a full-factorial events DataFrame based on the experimental conditions and covariates defined in the design.</p><p><strong>Arguments</strong></p><ul><li><code>design::AbstractDesign</code>: Experimental design for which the events DataFrame should be created.</li><li><code>rng::AbstractRNG</code> (optional): Random number generator (RNG) to make the process reproducible. If none is given, <code>MersenneTwister(1)</code> will be used.</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Each row corresponds to one combination of condition/covariate levels which is often equivalent to one stimulus or trial.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L211-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}" href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}"><code>UnfoldSim.generate_events</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_events(design::MultiSubjectDesign)
generate_events(rng::AbstractRNG, design::MultiSubjectDesign)</code></pre><p>Generate the events Dataframe according to <code>MixedModelsSim.jl</code>&#39;s <code>simdat_crossed</code> function.</p><p>Afterwards apply <code>design.event_order_function</code> and finally sort by <code>:subject</code>. <br/>Note: No condition can be named <code>dv</code> which is used internally in MixedModelsSim / MixedModels as a dummy left-side</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random # for shuffling
julia&gt; using StableRNGs

julia&gt; design = MultiSubjectDesign(;
                       n_items = 4,
                       n_subjects = 5,
                       both_within = Dict(:condition =&gt; [&quot;red&quot;, &quot;green&quot;]),
                       event_order_function = shuffle,
                       );

julia&gt; generate_events(StableRNG(1), design)
40√ó3 DataFrame
 Row ‚îÇ subject  item    condition 
     ‚îÇ String   String  String    
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ S1       I2      red
   2 ‚îÇ S1       I2      green
   3 ‚îÇ S1       I3      green
  ‚ãÆ  ‚îÇ    ‚ãÆ       ‚ãÆ         ‚ãÆ
  38 ‚îÇ S5       I3      red
  39 ‚îÇ S5       I2      red
  40 ‚îÇ S5       I4      green
                   34 rows omitted</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L289-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.generate_events-Tuple{Random.AbstractRNG, RepeatDesign}" href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, RepeatDesign}"><code>UnfoldSim.generate_events</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnfoldSim.generate_events([rng::AbstractRNG, ]design::RepeatDesign{T})</code></pre><p>For a <code>RepeatDesign</code>, iteratively call <code>generate_events</code> for the underlying {T} design and concatenate the results.</p><p>In case of <code>MultiSubjectDesign</code>, sort by subject. <br/>Please note that when using an <code>event_order_function</code>(e.g. <code>shuffle</code>) in a <code>RepeatDesign</code>, the corresponding RNG is shared across repetitions and not deep-copied for each repetition. As a result, the order of events will differ for each repetition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L355-L363">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.generate_events-Tuple{Random.AbstractRNG, SingleSubjectDesign}" href="#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, SingleSubjectDesign}"><code>UnfoldSim.generate_events</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_events(design::SingleSubjectDesign)
generate_events(rng::AbstractRNG, design::SingleSubjectDesign)</code></pre><p>Generate the events DataFrame based on <code>design.conditions</code> and afterwards apply <code>design.event_order_function</code>.</p><p>If <code>design.conditions</code> is <code>nothing</code>, a single trial is simulated with a column <code>:dummy</code> and content <code>:dummy</code> - this is for convenience.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random # for shuffling
julia&gt; using StableRNGs

julia&gt; design = SingleSubjectDesign(;
           conditions = Dict(:A =&gt; [&quot;small&quot;, &quot;large&quot;], :B =&gt; range(1, 5, length = 3)),
           event_order_function = shuffle,
       );

# Variant 1: Without specifying an RNG, MersenneTwister(1) will be used for the shuffling specified as `event_order_function`.
julia&gt; generate_events(design)
6√ó2 DataFrame
 Row ‚îÇ A       B       
     ‚îÇ String  Float64 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ large       5.0
   2 ‚îÇ large       1.0
   3 ‚îÇ large       3.0
   4 ‚îÇ small       1.0
   5 ‚îÇ small       3.0
   6 ‚îÇ small       5.0

# Variant 2: Use a custom RNG.
julia&gt; generate_events(StableRNG(1), design)
6√ó2 DataFrame
 Row ‚îÇ A       B       
     ‚îÇ String  Float64 
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ large       5.0
   2 ‚îÇ large       3.0
   3 ‚îÇ small       1.0
   4 ‚îÇ small       3.0
   5 ‚îÇ large       1.0
   6 ‚îÇ small       5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/design.jl#L229-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.hartmut_citation-Tuple{}" href="#UnfoldSim.hartmut_citation-Tuple{}"><code>UnfoldSim.hartmut_citation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Return the citation string for HArtMuT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/headmodel.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.hrf-Tuple{}" href="#UnfoldSim.hrf-Tuple{}"><code>UnfoldSim.hrf</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hrf(;
TR = 1,
peak = 6.0,
post_undershoot = 16,
length = 32.0,
peak_width = 1.0,
post_undershoot_width = 1,
amplitude = 6,
shift = 0)</code></pre><p>Generate a parameterized BOLD haemodynamic response function (HRF) kernel based on gamma-functions.</p><p>Implementation and default parameters were taken from the SPM-toolbox.</p><p>Note: TR = 1/sfreq</p><p><strong>Keyword arguments</strong></p><ul><li><code>TR = 1</code>: repetition time, 1/sfreq.</li><li><code>length = 32.0</code>: total length of the kernel in seconds.</li><li><code>amplitude = 6</code>: maximal amplitude.</li><li><code>peak = 6.0</code>: peak timing.</li><li><code>peak_width = 1.0</code>: width of the peak.</li><li><code>post_undershoot = 16</code>: post-undershoot timing.</li><li><code>post_undershoot_width = 1</code>: post-undershoot width.</li><li><code>shift = 0</code>: shift the whole HRF.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: HRF BOLD response.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hrf()
33-element Vector{Float64}:
  0.0
  0.0007715994433635659
  0.019784004131204957
  0.08202939459091822
  0.158157713522699
  ‚ãÆ
 -0.0006784790038792572
 -0.00042675060451877775
 -0.000263494738348278
 -0.00015990722628360688
 -9.548780093799345e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/bases.jl#L213-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.leadfield-Tuple{Hartmut}" href="#UnfoldSim.leadfield-Tuple{Hartmut}"><code>UnfoldSim.leadfield</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leadfield(hart::Hartmut; type = &quot;cortical&quot;)</code></pre><p>Return the leadfield for the (cortical or artefacual) sources of the HArtMuT model.</p><p><strong>Keyword arguments</strong></p><ul><li><code>type = &quot;cortical&quot;</code>: Defines whether the &quot;cortical&quot; or &quot;artefactual&quot; leadfield should be returned.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float64, 3}</code>: Leadfield values i.e. how much each source contributes to the potential measured at each electrode.   The output dimensions are <code>electrodes x sources x spatial dimension</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = Hartmut();
Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce

julia&gt; lf = leadfield(h);

julia&gt; size(lf)
(227, 2004, 3)

# Access the leadfield for one spatial dimension
julia&gt; lf[:,:,1]
227√ó2004 Matrix{Float64}:
  0.151429    0.0284341  ‚Ä¶  -0.119927     -0.158114
  0.1732      0.0441432     -0.110515     -0.165316
  0.249592    0.10857       -0.000593027  -0.0206122
  0.245206    0.104854      -0.0200251    -0.055392
  0.126496    0.0118467     -0.128248     -0.146107
  0.253092    0.111688   ‚Ä¶   0.02277       0.0184387
  ‚ãÆ                      ‚ã±                
  0.20306     0.138837       0.133486      0.18334
 -0.689154   -1.00904       -0.108276     -0.105398
  0.192729    0.148448       0.0924756     0.142322
 -1.26181    -1.59936       -0.140598     -0.133054
  0.213982    0.145953   ‚Ä¶   0.115515      0.170698
  0.0731569   0.0794415      0.0485819     0.107929</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/headmodel.jl#L91-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.magnitude-Tuple{AbstractHeadmodel}" href="#UnfoldSim.magnitude-Tuple{AbstractHeadmodel}"><code>UnfoldSim.magnitude</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">magnitude(headmodel::AbstractHeadmodel)</code></pre><p>Return the magnitude for the given <code>headmodel</code> based on the leadfield (and potentially the source orientations) specified in the <code>headmodel</code>.</p><p>If the <code>headmodel</code> includes source orientations these are used in the calculations, otherwise the <code>leadfield</code> is returned assuming that the source orientations are already included. Please note that (at least in the case of the HArtMuT model) the leadfield for the cortical sources is used.</p><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Contribution of each source to the potential measured at each electrode taking into account the orientation of the sources.   The output dimensions are <code>electrodes x sources</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Using the HArtMut model as an example
julia&gt; h = Hartmut();
Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce

julia&gt; magnitude(h)
227√ó2004 Matrix{Float64}:
  0.111706   ‚Ä¶   0.301065
  0.0774359      0.332934
  ‚ãÆ          ‚ã±  
 -0.164539      -0.246555</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/headmodel.jl#L173-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T&lt;:Real" href="#UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T&lt;:Real"><code>UnfoldSim.magnitude</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">magnitude(lf::AbstractArray{T,3}, orientation::AbstractArray{T,2}) where {T&lt;:Real}</code></pre><p>Return the magnitude of the leadfield <code>lf</code> along the given <code>orientation</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lf::AbstractArray{T,3}</code>: Leadfield with the dimensions <code>electrodes x sources x spatial dimension</code>.</li><li><code>orientation::AbstractArray{T,2}</code>: Source orientations with the dimensions <code>sources x spatial dimensions</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Specify the leadfield (often given by a headmodel)
julia&gt; lf = cat([1 0; 0 1; 0 0], [1 1; 0 0; 0.5 0.5], dims=3);

# Specify the source orientations
julia&gt; ori = [1.0 0; 0 1]

# Calculate the magnitude
julia&gt; magnitude(lf, ori)
3√ó2 Matrix{Float64}:
 1.0  1.0
 0.0  0.0
 0.0  0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/headmodel.jl#L202-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.maxlength-Tuple{Vector{&lt;:AbstractComponent}}" href="#UnfoldSim.maxlength-Tuple{Vector{&lt;:AbstractComponent}}"><code>UnfoldSim.maxlength</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maxlength(c::Vector{&lt;:AbstractComponent}) = maximum(length.(c))</code></pre><p>Return the maximum of the individual components&#39; lengths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n170-Tuple{}" href="#UnfoldSim.n170-Tuple{}"><code>UnfoldSim.n170</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n170(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking an N170 EEG component with a negative (!) peak at 170ms and a width of 150ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n170(; sfreq = 120)
28-element Vector{Float64}:
 -0.0
 -0.0
 -0.0
 -0.0
 -0.0
  ‚ãÆ
 -0.45386582026834904
 -0.2771308221117309
 -0.1304955413896705
 -0.03376388529782215
 -0.0</code></pre><p>See also <a href="#UnfoldSim.p100-Tuple{}"><code>p100</code></a>, <a href="#UnfoldSim.p300-Tuple{}"><code>p300</code></a>, <a href="#UnfoldSim.n400-Tuple{}"><code>n400</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/bases.jl#L68-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n400-Tuple{}" href="#UnfoldSim.n400-Tuple{}"><code>UnfoldSim.n400</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n400(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking an N400 EEG component with a negative (!) peak at 400ms and a width of 400ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n400(; sfreq = 250)
150-element Vector{Float64}:
 -0.0
 -0.0
 -0.0
 -0.0
 -0.0
  ‚ãÆ
 -0.016025649301821876
 -0.009035651368646647
 -0.00402259358460233
 -0.0010066617640578368
 -0.0</code></pre><p>See also <a href="#UnfoldSim.p100-Tuple{}"><code>p100</code></a>, <a href="#UnfoldSim.p300-Tuple{}"><code>p300</code></a>, <a href="#UnfoldSim.n170-Tuple{}"><code>n170</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/bases.jl#L99-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n_channels-Tuple{AbstractComponent}" href="#UnfoldSim.n_channels-Tuple{AbstractComponent}"><code>UnfoldSim.n_channels</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n_channels(c::AbstractComponent)</code></pre><p>Return the number of channels for the given component <code>c</code>. By default = 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n_channels-Tuple{MultichannelComponent}" href="#UnfoldSim.n_channels-Tuple{MultichannelComponent}"><code>UnfoldSim.n_channels</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n_channels(c::MultichannelComponent)</code></pre><p>For <code>MultichannelComponent</code> return the length of the projection vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.n_channels-Tuple{Vector{&lt;:AbstractComponent}}" href="#UnfoldSim.n_channels-Tuple{Vector{&lt;:AbstractComponent}}"><code>UnfoldSim.n_channels</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">n_channels(c::Vector{&lt;:AbstractComponent})</code></pre><p>For a vector of <code>MultichannelComponent</code>s, return the number of channels for the first component but assert all are of equal length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.orientation-Tuple{Hartmut}" href="#UnfoldSim.orientation-Tuple{Hartmut}"><code>UnfoldSim.orientation</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orientation(hart::Hartmut; type = &quot;cortical&quot;)</code></pre><p>Return the orientations of the (cortical or artefacual) sources of the HArtMuT model. </p><p>The norm of the orientation vectors is 1 and the values are between -1 and 1.</p><p><strong>Keyword arguments</strong></p><ul><li><code>type = &quot;cortical&quot;</code>: Defines whether the &quot;cortical&quot; or &quot;artefactual&quot; orientations should be returned.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Orientations in 3D space. The output dimensions are <code>sources x spatial dimensions</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = Hartmut();
Please cite: HArtMuT: Harmening Nils, Klug Marius, Gramann Klaus and Miklody Daniel - 10.1088/1741-2552/aca8ce

julia&gt; orientation(h)
2004√ó3 Matrix{Float64}:
 -0.921919   0.364292   0.131744
 -0.900757  -0.415843  -0.125345
 -0.954087   0.117479  -0.27553
 -0.814613  -0.55344    0.17352
 -0.790526   0.276849  -0.546281
  ‚ãÆ                    
 -0.962905   0.20498   -0.17549
 -0.828358   0.557468  -0.0552498
 -0.963785  -0.265607  -0.0239074
 -0.953909   0.203615   0.22045
 -0.75762    0.128027   0.640016</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/headmodel.jl#L134-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.p100-Tuple{}" href="#UnfoldSim.p100-Tuple{}"><code>UnfoldSim.p100</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p100(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking a P100 EEG component with a peak at 100ms and a width of 100ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p100(; sfreq = 200)
30-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 ‚ãÆ
 0.37725725642960045
 0.22652592093878665
 0.10542974530180327
 0.02709137914968268
 0.0</code></pre><p>See also <a href="#UnfoldSim.p300-Tuple{}"><code>p300</code></a>, <a href="#UnfoldSim.n170-Tuple{}"><code>n170</code></a>, <a href="#UnfoldSim.n400-Tuple{}"><code>n400</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/bases.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.p300-Tuple{}" href="#UnfoldSim.p300-Tuple{}"><code>UnfoldSim.p300</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">p300(; sfreq = 100)</code></pre><p>Generate a Hanning window mimicking a P300 EEG component with a peak at 300ms and a width of 300ms.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency in Hz.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Contains a shifted (i.e. zero-padded) hanning window.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; p300(; sfreq = 150)
67-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 ‚ãÆ
 0.07937323358440934
 0.04518400232274078
 0.02025351319275137
 0.005089279059533658
 0.0</code></pre><p>See also <a href="#UnfoldSim.p100-Tuple{}"><code>p100</code></a>, <a href="#UnfoldSim.n170-Tuple{}"><code>n170</code></a>, <a href="#UnfoldSim.n400-Tuple{}"><code>n400</code></a>, <a href="#DSP.Windows.hanning-Tuple{Any, Any, Any}"><code>hanning</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/bases.jl#L36-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}" href="#UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}"><code>UnfoldSim.pad_array</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pad_array(arr::Vector, len::Int, val)    
pad_array(arr::Vector, len::Tuple, val)</code></pre><p>Pads the input array <code>arr</code> with a specified value <code>val</code> either before or after the existing elements, based on the sign of <code>len</code>.</p><p><strong>Arguments</strong></p><ul><li><code>arr::Vector</code>: The input array to be padded.</li><li><code>len::Union{Int, Tuple}</code>: The number of times that <code>val</code> should be added.   If <code>len</code> is negative, the values are added before the existing array. Otherwise, they are added after the existing array.   If <code>len</code> is a tuple, <code>pad_array</code> is called twice which enables padding the array before and after in one function call.</li><li><code>val</code>: The value to be used for padding.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Padded vector with the new length <code>length(arr) + sum(abs.(len))</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Create an array that will be padded
julia&gt; my_array = rand(5)
5-element Vector{Float64}:
 0.0420017254437951
 0.19179144973603235
 0.5388760239550549
 0.6973699906283798
 0.9966598131018376

 # Pad the array with zeros before the original array
julia&gt; pad_array(my_array, -2, 0)
7-element Vector{Float64}:
 0.0
 0.0
 0.0420017254437951
 0.19179144973603235
 0.5388760239550549
 0.6973699906283798
 0.9966598131018376

# Pad the array with the value 5 before and after the original array
julia&gt; pad_array(my_array, (-2, 1), 5)
8-element Vector{Float64}:
 5.0
 5.0
 0.0420017254437951
 0.19179144973603235
 0.5388760239550549
 0.6973699906283798
 0.9966598131018376
 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/helper.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}" href="#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}"><code>UnfoldSim.predef_2x2</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predef_2x2(rng::AbstractRNG; &lt;keyword arguments&gt;)</code></pre><p>Simulate data for a 2x2 design i.e. a design with two conditions with two levels each.</p><p>Note that this function is mainly used for demonstration and internal testing purposes or whenever a quick simulation is needed. </p><p>The most used keyword argument is: <code>return_epoched = true</code> which returns already epoched data. If you want epoched data without overlap, specify <code>onset = NoOnset()</code> and <code>return_epoched = true</code>. </p><p>Be careful if you modify <code>n_items</code> with <code>n_subjects = 1</code>, <code>n_items</code> has to be a multiple of 4 (or your equivalent conditions factorial, e.g. all combinations length).</p><p>In difference to <code>predef_EEG</code>, <code>predef_2x2</code> is sample based (no sampling rate to be specified), and also has a 2x2 design, instead of a 2-categorical, 1-continuous design.</p><p><strong>Keyword arguments</strong></p><p><strong>Design</strong></p><ul><li><code>n_items = 100</code>: Number of items.</li><li><code>n_subjects = 1</code>: Number of subjects.</li><li><code>conditions = Dict(:A =&gt; [&quot;a_small&quot;,&quot;a_big&quot;], :B =&gt; [&quot;b_tiny&quot;,&quot;b_large&quot;])</code>: Experimental conditions with their levels.</li><li><code>event_order_function = shuffle</code>: Random trial order.</li></ul><p><strong>Component / Signal</strong></p><ul><li><code>signalsize = 100</code>: Length of simulated hanning window.</li><li><code>basis = hanning(signalsize)</code>: The actual &quot;function&quot;. <code>signalsize</code> is only used here.</li><li><code>Œ≤ = [1, -0.5, .5, +1]</code>: The parameters for the fixed effects.</li><li><code>œÉs = Dict(:subject =&gt; [1, 0.5, 0.5, 0.5],:item =&gt; [1])</code>: Only needed in n_subjects &gt;= 2 cases; specifies the random effects.</li><li><code>contrasts = Dict(:A =&gt; EffectsCoding(), :B =&gt; EffectsCoding())</code>: Effect coding by default.</li><li><code>formula = n_subjects == 1 ? @formula(0 ~ 1 + A*B) : @formula(dv ~ 1 + A*B + (A*B|subject) + (1|item))</code>: Model formula with interaction.</li></ul><p><strong>Onset</strong></p><ul><li><code>overlap = (0.5,0.2)</code>,</li><li><code>onset = UniformOnset(; offset = signalsize * overlap[1], width = signalsize * overlap[2])</code>, # Put offset to 1 for no overlap. put width to 0 for no jitter</li></ul><p><strong>Noise</strong></p><ul><li><code>noiselevel = 0.2</code>.</li><li><code>noise = PinkNoise(; noiselevel = noiselevel)</code>.</li></ul><p><strong>Other parameters</strong></p><ul><li><code>return_epoched = false</code>: If true, already epoched data is returned. Otherwise, continuous data is returned.</li></ul><p><strong>Returns</strong></p><ul><li><p><code>(data, events)::Tuple{Array, DataFrame}</code>: </p><ul><li><p><code>data</code> contains the simulated EEG data. Its dimensionality depends on the status of <code>return_epoched</code> and whether n<em>subjects &gt;=2: `continuous</em>time<code>,</code>continuous<em>time x n</em>subjects<code>,</code>times x size(design)[1]<code>or</code>times x size(design)[1] x n_subjects`. </p></li><li><p><code>events</code> contains the event combinations based on the experimental design. Each row corresponds to one combination of condition levels which is often equivalent to one stimulus or trial.</p></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data, events = UnfoldSim.predef_2x2();

julia&gt; events
100√ó3 DataFrame
 Row ‚îÇ A        B        latency 
     ‚îÇ String   String   Int64   
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ a_small  b_large       62
   2 ‚îÇ a_big    b_tiny       132
  ‚ãÆ  ‚îÇ    ‚ãÆ        ‚ãÆ        ‚ãÆ
  99 ‚îÇ a_big    b_large     5883
 100 ‚îÇ a_big    b_tiny      5935
                  96 rows omitted

julia&gt; data
6035-element Vector{Float64}:
  0.32384561187165956
  0.4108799249488322
  0.4715514814540277
  0.5936253009785152
  ‚ãÆ
  0.047664408295942984
  0.051193074728432035
 -0.08951617593287822
 -0.14456000097460356</code></pre><p>See also <a href="#UnfoldSim.predef_eeg-Tuple{Any}"><code>predef_eeg</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/predefinedSimulations.jl#L185-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.predef_eeg-Tuple{Any}" href="#UnfoldSim.predef_eeg-Tuple{Any}"><code>UnfoldSim.predef_eeg</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predef_eeg(; &lt;keyword arguments&gt;)
predef_eeg(rng; &lt;keyword arguments&gt;)
predef_eeg(rng, n_subjects; &lt;keyword arguments&gt;)</code></pre><p>Simulate data for a P1/N1/P3 component complex.</p><p>Note that this function is mainly used for demonstration and internal testing purposes or whenever a quick simulation is needed. </p><p>In case <code>n_subjects</code> is defined - <code>MixedModelComponents</code> are generated (multi-subject simulation), else <code>LinearModelComponents</code> (single-subject simulation). </p><p>The most used keyword argument is: <code>return_epoched = true</code> which returns already epoched data. If you want epoched data without overlap, specify <code>onset = NoOnset()</code> and <code>return_epoched = true</code>.</p><p><strong>Keyword arguments</strong></p><p><strong>Design</strong></p><ul><li><code>n_repeats = 100</code>: Number of times the experimental design is repeated. Only used in the single-subject case.</li><li><code>n_items = 100</code>: Number of items. Only used in the multi-subject case.</li><li><code>event_order_function = shuffle</code>: Random trial order. Use <code>event_order_function = (rng, x) -&gt; x</code> to deactivate.</li><li><code>conditions = Dict(:condition =&gt; [&quot;car&quot;, &quot;face&quot;], :continuous =&gt; range(-5, 5, length = 10))</code>: Conditions and covariates used in this predefined design.</li></ul><p><strong>Component / Signal</strong></p><ul><li><code>sfreq = 100</code>: Sampling frequency.</li><li><code>p1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict())</code>: P1 with amplitude 5; no effects.</li><li><code>n1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5, 3], Dict())</code>: N1 with amplitude 5, dummy-coded condition effect (levels &quot;car&quot;, &quot;face&quot;) of 3.</li><li><code>p3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5, 1], Dict())</code>: P3 with amplitude 5, continuous effect range [-5,5] with slope 1.</li></ul><p><strong>Onset</strong></p><ul><li><code>overlap = (0.5,0.2)</code>, # convenient parameterization for the default <code>onset::UniformOnset</code>. (<code>offset</code>, <code>width</code>) in seconds. If you do not want any overlap, either use <code>onset=NoOnset()</code>, or put the offset to a value larger than the maximum used component length, e.g. <code>overlap=(1,0.2)</code>. Put the <code>width</code> to <code>0</code> to have no jitter between events.</li><li><code>onset = UniformOnset(; offset = sfreq * 0.5 * overlap[1], width = sfreq * 0.5 * overlap[2])</code>, </li></ul><p><strong>Noise</strong></p><ul><li><code>noiselevel = 0.2</code>.</li><li><code>noise = PinkNoise(; noiselevel = noiselevel)</code>.</li></ul><p><strong>Other parameters</strong></p><ul><li><code>return_epoched = false</code>: If true, already epoched data is returned. Otherwise, continuous data is returned.</li></ul><p><strong>Returns</strong></p><ul><li><p><code>(data, events)::Tuple{Array, DataFrame}</code>: </p><ul><li><p><code>data</code> contains the simulated EEG data. Its dimensionality depends on the status of <code>return_epoched</code> and whether it&#39;s a single- or multisubject simulation (1D, 2D or 3D array): <code>continuous_time</code>, <code>continuous_time x n_subjects</code>, <code>times x size(design)[1]</code> or <code>times x size(design)[1] x n_subjects</code>. </p></li><li><p><code>events</code> contains the event combinations based on the experimental design. Each row corresponds to one combination of condition/covariate levels which is often equivalent to one stimulus or trial.</p></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data, events = UnfoldSim.predef_eeg();

julia&gt; events
2000√ó3 DataFrame
  Row ‚îÇ continuous  condition  latency 
      ‚îÇ Float64     String     Int64   
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    1 ‚îÇ   2.77778   car             62
    2 ‚îÇ  -5.0       face           132
  ‚ãÆ   ‚îÇ     ‚ãÆ           ‚ãÆ         ‚ãÆ
 1999 ‚îÇ  -0.555556  face        120096
 2000 ‚îÇ  -2.77778   car         120154

julia&gt; data
120199-element Vector{Float64}:
  0.31631798033146774
  0.40338935529989906
  0.46409775558165056
  0.5862082040156747
  ‚ãÆ
 -0.1879589005111152
 -0.3163314509311509
 -0.22230944464885682
 -0.01320095208877194</code></pre><p>See also <a href="#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}"><code>predef_2x2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/predefinedSimulations.jl#L9-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate" href="#UnfoldSim.simulate"><code>UnfoldSim.simulate</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate(
rng::AbstractRNG,
design::AbstractDesign,
components,
onset::AbstractOnset,
noise::AbstractNoise = NoNoise();
return_epoched = false,
)

simulate(
design::AbstractDesign,
components,
onset::AbstractOnset,
noise::AbstractNoise = NoNoise();
return_epoched = false,
)</code></pre><p>Simulate continuous or epoched signal, given <code>design</code>, [Array of] <code>component</code>, <code>onset</code> and  optional <code>noise</code> and <code>rng</code>. Main simulation function.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code> (optional): Random number generator, important to ensure reproducibility.</li><li><code>design::AbstractDesign</code>: Desired experimental design.</li><li><code>components</code>: <code>Component</code>(s) for the desired signal.</li><li><code>onset::AbstractOnset</code>: Desired inter-onset distance distribution.</li><li><code>noise::AbstractNoise = NoNoise()</code> (optional): Desired noise.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>return_epoched::Bool = false</code>: If set to <code>true</code> epoched data is returned, otherwise a continuous signal is returned (see also Notes below).</li></ul><p><strong>Returns</strong></p><ul><li><code>(signal, events)::Tuple{Array, DataFrame}</code>:<ul><li><code>signal</code> : Generated signal. Depending on the design, on the components and on    <code>return_epoched</code>, the output can be a 1-D, 2-D, 3-D or 4-D Array.    For example, a 4-D Array would have the dimensions <code>channels x time x trials x subjects</code>.</li><li><code>events</code>: Generated events data frame with latencies.</li></ul></li></ul><p><strong>Examples</strong></p><p>Adapted from the <a href="https://unfoldtoolbox.github.io/UnfoldSim.jl/stable/generated/tutorials/quickstart/">quickstart tutorial</a> in the UnfoldSim docs.</p><pre><code class="language-julia-repl hljs">julia&gt; using Random # to get an RNG

julia&gt; design =
    SingleSubjectDesign(; conditions = Dict(:cond_A =&gt; [&quot;level_A&quot;, &quot;level_B&quot;])) |&gt;
    x -&gt; RepeatDesign(x, 10);

julia&gt; component = LinearModelComponent(; 
    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],
    formula = @formula(0 ~ 1 + cond_A),
    Œ≤ = [1, 0.5],
);

julia&gt; onset = UniformOnset(; width = 20, offset = 4);

julia&gt; noise = PinkNoise(; noiselevel = 0.2);

# Variant 1: Use a custom RNG.
julia&gt; data, events = simulate(MersenneTwister(2), design, component, onset, noise);

julia&gt; data
293-element Vector{Float64}:
 -0.013583193323430123
  0.09159433856866195
  ‚ãÆ
 -0.25190584567097907
 -0.20179992275876316

julia&gt; events
20√ó2 DataFrame
 Row ‚îÇ cond_A   latency 
     ‚îÇ String   Int64   
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1 ‚îÇ level_A        9
   2 ‚îÇ level_B       20
   3 ‚îÇ level_A       27
   4 ‚îÇ level_B       37
  ‚ãÆ  ‚îÇ    ‚ãÆ        ‚ãÆ
  18 ‚îÇ level_B      257
  19 ‚îÇ level_A      271
  20 ‚îÇ level_B      284
         13 rows omitted

# Variant 2: Without specifying an RNG, MersenneTwister(1) will be used for the simulation.
julia&gt; data1, events1 = simulate(design, component, onset, noise);
‚îå Warning: No random generator defined, used the default (`Random.MersenneTwister(1)`) with a fixed seed. This will always return the same results and the user is strongly encouraged to provide their own random generator!</code></pre><p><strong>Notes</strong></p><p>Some remarks on how the noise is added:</p><ul><li>If <code>return_epoched = true</code> and <code>onset = NoOnset()</code> the noise is added to the epoched data matrix.</li><li>If <code>onset</code> is not <code>NoOnset</code>, a continuous signal is created and the noise is added to this    i.e. this means that the noise won&#39;t be the same as in the <code>onset = NoOnset()</code> case even if <code>return_epoched = true</code>.</li><li>The case <code>return_epoched = false</code> and <code>onset = NoOnset()</code> is not possible and therefore    covered by an assert statement.</li></ul><p>Additional remarks on the overlap of adjacent signals when <code>return_epoched = true</code>:</p><ul><li>If <code>onset = NoOnset()</code> there will not be any overlapping signals in the data because the onset calculation and conversion to a continuous signal is skipped.</li><li>If an inter-onset distance distribution is given, a continuous signal(potentially with overlap) is constructed and partitioned into epochs afterwards.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/simulation.jl#L21-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}" href="#UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}"><code>UnfoldSim.simulate_and_add!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_and_add!(epoch_data::AbstractMatrix, c, simulation, rng)
simulate_and_add!(epoch_data::AbstractArray, c, simulation, rng)</code></pre><p>Helper function to call <code>simulate_component</code> and add it to a provided Array <code>epoch_data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L499-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}" href="#UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}"><code>UnfoldSim.simulate_component</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::AbstractComponent, simulation::Simulation)</code></pre><p>By default call <code>simulate_component</code> with <code>(rng, c::Abstractcomponent, design::AbstractDesign)</code> instead of the whole simulation. This function exist solely to provide a &quot;hook&quot; if for a custom component something else than the design is necessary, e.g. a dependency on the onsets, noise or similar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}" href="#UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}"><code>UnfoldSim.simulate_component</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::LinearModelComponent, design::AbstractDesign)</code></pre><p>Generate a linear model design matrix, weight it by the coefficients <code>c.Œ≤</code> and multiply the result with the given basis vector.</p><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Simulated component for each event in the events data frame. The output dimensions are <code>length(c.basis) x length(design)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = SingleSubjectDesign(; conditions = Dict(:cond =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; c = UnfoldSim.LinearModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond), [1, 2], Dict());

julia&gt; using StableRNGs

julia&gt; simulate_component(StableRNG(1), c, design)
4√ó2 Matrix{Float64}:
 0.0  0.0
 3.0  1.0
 3.0  1.0
 0.0  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L186-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}" href="#UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}"><code>UnfoldSim.simulate_component</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::MixedModelComponent, design::AbstractDesign, return_parameters = false)</code></pre><p>Generate a MixedModel and simulate data according to the given parameters <code>c.Œ≤</code> and <code>c.œÉs</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>return_parameters::Bool = false</code>: Can be used to return the per-event parameters used to weight the basis function. Sometimes useful to inspect what is simulated.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Simulated component for each event in the events data frame. The output dimensions are <code>length(c.basis) x length(design)</code>.</li></ul><p><strong>Notes</strong></p><ol><li>MixedModels/Sim does not allow simulation of data without white noise of the residuals. Because we want our own noise, we use the following trick to remove the MixedModels-Noise:</li></ol><p>Practically, we upscale the specified <code>œÉs</code> by factor 10<em>000, and request a white-noise-level of <code>œÉ = 0.0001</code>. Internally in MixedModels/Sim, <code>œÉs</code> are relative to <code>œÉ</code>, and thus are normalized correctly, while keeping the noise 10</em>000 times smaller than the random effects</p><p>We cannot exclude that this trick runs into strange numerical issues if the random effect <code>œÉs</code> are very large compared to the fixed effects.</p><ol><li>Currently, it is not possible to use a different basis for fixed and random effects. If this is needed, some code-scaffold is available but commented out at the moment and requires a bit of implementation work.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = MultiSubjectDesign(; n_subjects = 2, n_items = 6, items_between = Dict(:cond =&gt; [&quot;A&quot;, &quot;B&quot;]));

julia&gt; c = UnfoldSim.MixedModelComponent([0, 1, 1, 0], @formula(0 ~ 1 + cond + (1|subject)), [1, 2], Dict(:subject =&gt; [2],), Dict());

julia&gt; using StableRNGs

julia&gt; simulate_component(StableRNG(1), c, design)
4√ó12 Matrix{Float64}:
 -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0
 -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565
 -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565
 -0.0      -0.0       -0.0      -0.0       -0.0     -0.0       0.0       0.0      0.0       0.0      0.0       0.0

julia&gt; simulate_component(StableRNG(1), c, design, return_parameters = true)
1√ó12 Matrix{Float64}:
 -2.70645  -0.706388  -2.70632  -0.706482  -2.7066  -0.706424  0.325722  2.32569  0.325627  2.32564  0.325468  2.32565</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L229-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}" href="#UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}"><code>UnfoldSim.simulate_component</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_component(rng, c::MultichannelComponent, design::AbstractDesign)</code></pre><p>Return the projection of a <code>MultichannelComponent c</code> from &quot;source&quot; to &quot;sensor&quot; space.</p><p><strong>Returns</strong></p><ul><li><code>Array{Float64,3}</code>: Projected simulated component for each event in the events data frame. The output dimensions are <code>length(c.projection) x length(c.basis) x length(design)</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = SingleSubjectDesign(; conditions = Dict(:cond =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), Œ≤ = [1, 0.5]);
julia&gt; mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1], PinkNoise());

julia&gt; using StableRNGs

julia&gt; simulate_component(StableRNG(1), mc, design)
7√ó15√ó2 Array{Float64, 3}:
[:, :, 1] =
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662
  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.7484    3.53412   5.53942   4.0612    2.34858   2.01845   2.19039   1.50932    4.51324
 -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.3742   -1.76706  -2.76971  -2.0306   -1.17429  -1.00922  -1.09519  -0.754659  -2.25662
  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   4.1226    5.30118   8.30913   6.09179   3.52287   3.02767   3.28558   2.26398    6.76985
  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.871     8.8353   13.8485   10.153     5.87145   5.04612   5.47597   3.7733    11.2831
  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.16066   4.06424   6.37033   4.67037   2.70087   2.32121   2.51894   1.73572    5.19022
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.3742    1.76706   2.76971   2.0306    1.17429   1.00922   1.09519   0.754659   2.25662

[:, :, 2] =
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662
  1.71925    2.33147   1.91905    1.51504    2.35278   3.30312   2.63142   3.12094   4.78942   3.09135   1.37873    1.26845    1.77721    1.39234   4.51324
 -0.859626  -1.16574  -0.959523  -0.757522  -1.17639  -1.65156  -1.31571  -1.56047  -2.39471  -1.54567  -0.689367  -0.634223  -0.888605  -0.69617  -2.25662
  2.57888    3.49721   2.87857    2.27257    3.52917   4.95469   3.94713   4.68142   7.18413   4.63702   2.0681     1.90267    2.66582    2.08851   6.76985
  4.29813    5.82868   4.79761    3.78761    5.88194   8.25781   6.57855   7.80236  11.9735    7.72837   3.44684    3.17112    4.44303    3.48085  11.2831
  1.97714    2.68119   2.2069     1.7423     2.70569   3.79859   3.02613   3.58909   5.50783   3.55505   1.58554    1.45871    2.04379    1.60119   5.19022
  0.859626   1.16574   0.959523   0.757522   1.17639   1.65156   1.31571   1.56047   2.39471   1.54567   0.689367   0.634223   0.888605   0.69617   2.25662</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L345-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_interonset_distances" href="#UnfoldSim.simulate_interonset_distances"><code>UnfoldSim.simulate_interonset_distances</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_interonset_distances(rng, onset::AbstractOnset, design::AbstractDesign)</code></pre><p>Generate the inter-onset distance vector by sampling from the respective distribution (in samples).</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator (RNG) to make the process reproducible.</li><li><code>onset::AbstractOnset</code>: Inter-onset distance distribution to sample from.</li><li><code>design::AbstractDesign</code>: Experimental design with conditions and covariates.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Integer}</code>: Inter-onset distances in samples. Note that these are distances between onsets and no latencies.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Create an experimental design
julia&gt; design_single = SingleSubjectDesign(;
           conditions = Dict(
               :stimulus_type =&gt; [&quot;natural&quot;, &quot;artificial&quot;],
               :contrast_level =&gt; range(0, 1, length = 3),
           ),
       );

# Create an inter-onset distance distribution
julia&gt; onset_distribution = LogNormalOnset(3, 0.5, 5, nothing);

julia&gt; using StableRNGs

julia&gt; simulate_interonset_distances(StableRNG(1), onset_distribution, design_single)
6-element Vector{Int64}:
 20
 26
 34
 18
 12
 23</code></pre><p>See also <a href="#UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}"><code>simulate_onsets</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/onset.jl#L83-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_noise" href="#UnfoldSim.simulate_noise"><code>UnfoldSim.simulate_noise</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_noise(rng, t::AbstractNoise, n::Int)</code></pre><p>Generate noise samples of the given type <code>t</code>.</p><p>For details, see the documentation of the individual noise types. Use <code>subtypes(AbstractNoise)</code> for a list of the implemented noise types.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: Random number generator (RNG) to make the process reproducible.</li><li><code>t::AbstractNoise</code>: Instance of a noise type e.g. <code>PinkNoise()</code>.</li><li><code>n::Int</code>: The number of noise samples that should be generated.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: Vector of length <code>n</code> containing the noise samples.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Here we use White Noise as an example but it works in the same way for the other noise types.
julia&gt; noise = WhiteNoise()
WhiteNoise
  noiselevel: Int64 1
  imfilter: Int64 0

julia&gt; using StableRNGs

julia&gt; simulate_noise(StableRNG(1), noise, 3)
3-element Vector{Float64}:
 -0.5325200748641231
  0.098465514284785
  0.7528865221245234</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/noise.jl#L203-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}" href="#UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}"><code>UnfoldSim.simulate_onsets</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_onsets(rng, onset::AbstractOnset, simulation::Simulation)</code></pre><p>Call <code>simulate_interonset_distances</code> to generate distances between events and then add them up to generate the actual latencies in samples.</p><p>Please note that this function is mainly for internal use in the context of <code>simulate</code> function calls. </p><p>Also note that the accumulation of onsets starts at 1 to avoid indexing problems in the case that the first sampled onset is 0.</p><p><strong>Arguments</strong></p><ul><li><code>rng</code>: Random number generator (RNG) to make the process reproducible.</li><li><code>onset::AbstractOnset</code>: Inter-onset distance distribution which is passed to <code>simulate_interonset_distances</code>.</li><li><code>simulation::Simulation</code>: Simulation object which contains design, component(s), inter-onset distance distribution and noise.</li></ul><p><strong>Returns</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># Create Simulation object
julia&gt; design_single = SingleSubjectDesign(;
           conditions = Dict(
               :stimulus_type =&gt; [&quot;natural&quot;, &quot;artificial&quot;],
               :contrast_level =&gt; range(0, 1, length = 3),
           ),
       );

julia&gt; p1_component = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), Œ≤ = [5]);

julia&gt; simulation = Simulation(design_single, p1_component, UniformOnset(), NoNoise());

julia&gt; using StableRNGs

# Simulate onsets for this simulation
julia&gt; simulate_onsets(StableRNG(1), simulation.onset, simulation)
6-element Vector{Int64}:
  20
  70
  97
 110
 150
 182</code></pre><p>See also <a href="#UnfoldSim.simulate_interonset_distances"><code>simulate_interonset_distances</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/onset.jl#L143-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.simulate_responses-Tuple{Any, Vector{&lt;:AbstractComponent}, Simulation}" href="#UnfoldSim.simulate_responses-Tuple{Any, Vector{&lt;:AbstractComponent}, Simulation}"><code>UnfoldSim.simulate_responses</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simulate_responses(
    rng,
    components::Vector{&lt;:AbstractComponent},
    simulation::Simulation)</code></pre><p>Simulate multiple component responses and accumulate them on a per-event basis.</p><p><strong>Returns</strong></p><ul><li><code>epoch_data</code>: <code>Matrix</code> (or <code>Array</code> in the multi-channel case) of combined simulated components.   The output dimensions are <code>maxlength(components) x length(simulation.design)</code> for single-channel components and   <code>n_channels(components) x maxlength(components) x length(simulation.design)</code> for multi-channel components.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; design = SingleSubjectDesign(; conditions = Dict(:cond =&gt; [&quot;natural&quot;, &quot;artificial&quot;]));

julia&gt; c1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1 + cond), Œ≤ = [1, 0.5]);
julia&gt; c2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), Œ≤ = [2]);

julia&gt; simulation = Simulation(design, [c1, c2], UniformOnset(; width = 0, offset = 30), PinkNoise());

julia&gt; using StableRNGs

julia&gt; simulate_responses(StableRNG(1), [c1, c2], simulation)
45√ó2 Matrix{Float64}:
 0.0        0.0
 0.0        0.0
 0.0        0.0
 0.0        0.0
 0.0        0.0
 ‚ãÆ          
 0.352614   0.352614
 0.203907   0.203907
 0.0924246  0.0924246
 0.0233794  0.0233794
 0.0        0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L441-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="UnfoldSim.weight_œÉs-Tuple{Dict, Float64, Float64}" href="#UnfoldSim.weight_œÉs-Tuple{Dict, Float64, Float64}"><code>UnfoldSim.weight_œÉs</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weight_œÉs(œÉs::Dict, b_œÉs::Float64, œÉ_lmm::Float64)</code></pre><p>Weight a <code>œÉs</code> Dict for MixedModels.jl by <code>b_œÉs</code>, a scaling factor typically from a <code>basis</code>.</p><p>Finally scales it again by <code>œÉ_lmm</code>, as a trick to simulate noise-free LMMs (see <code>MixedModelsComponent</code>)</p><p>In the future, we anticipate a function     <code>function weight_œÉs(œÉs::Dict,b_œÉs::Dict,œÉ_lmm::Float64)</code> where each <code>œÉs</code> entry can be weighted individually by a matching <code>b_œÉs</code>, but it is not implemented.</p><p><strong>Arguments</strong></p><ul><li><code>œÉs::Dict</code> = a Dict of random effects as output of MixedModels.create_re</li><li><code>b_œÉs::Float64</code> = a scaling factor, typically one entry of a basis function from a component</li><li><code>œÉ_lmm::Float64</code> = a scaling factor to simulate near-zero noise LMMs</li></ul><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">`NamedTuple` of the weighted random effects</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/unfoldtoolbox/UnfoldSim.jl/blob/2650de364cc704411d5de09a0365203921830de4/src/component.jl#L394-L412">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developer_docs/">¬´ Developer documentation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 19 February 2025 17:39">Wednesday 19 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
