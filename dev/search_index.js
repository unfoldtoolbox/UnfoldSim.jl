var documenterSearchIndex = {"docs":
[{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"EditURL = \"../../../literate/HowTo/newComponent.jl\"","category":"page"},{"location":"generated/HowTo/newComponent/#New-component:-Duration-Shift","page":"Define a new duration & jitter component","title":"New component: Duration + Shift","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"We want a new component that changes its duration and shift depending on a column in the event-design. This is somewhat already implemented in the HRF + Pupil bases","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"using UnfoldSim\nusing Unfold\nusing Random\nusing DSP\nusing CairoMakie, UnfoldMakie\n\nsfreq = 100;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newComponent/#Design","page":"Define a new duration & jitter component","title":"Design","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"Let's generate a design with two columns, shift + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"design = UnfoldSim.SingleSubjectDesign(;conditions= Dict(\n            :shift => rand(100).*sfreq/5,\n            :duration=>20 .+rand(100).*sfreq/5))","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"We also need a new AbstractComponent","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"struct TimeVaryingComponent <: AbstractComponent\n    basisfunction\n    maxlength\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"We have to define the length of a component","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"Base.length(c::TimeVaryingComponent) = length(c.maxlength)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"While we could have put the TimeVaryingComponent.basisfunction directly into the simulate function, I thought this is a bit more modular","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"function UnfoldSim.simulate(rng,c::TimeVaryingComponent,design::AbstractDesign)\n    evts = generate(design)\n    return c.basisfunction(evts,c.maxlength)\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"finally, the actual function that does the shifting + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"function basis_shiftduration(evts,maxlength)\n    basis = hanning.(Int.(round.(evts.duration))) ## hanning as long as duration\n    if \"shift\" ∈ names(evts)\n        basis = padarray.(basis,Int.(round.(.-evts.shift)),0) ## shift by adding 0 in front\n    end\n    # we should make sure that all bases have maxlength by appending / truncating\n    difftomax = maxlength .- length.(basis)\n    if any(difftomax.<0)\n        @warn \"basis longer than max length in at least one case. either increase maxlength or redefine function. Trying to truncate the basis\"\n        basis[difftomax .>0] = padarray.(basis[difftomax .> 0],difftomax[difftomax .> 0],0)\n        return [b[1:maxlength] for b in basis]\n    else\n        return padarray.(basis,difftomax,0)\n    end\nend\n\n\nerp = UnfoldSim.simulate(MersenneTwister(1),TimeVaryingComponent(basis_shiftduration,50),design)\nplot_erpimage(hcat(erp...),sortvalues=generate(design).shift)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new duration & jitter component","title":"Define a new duration & jitter component","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"EditURL = \"../../../literate/tutorials/simulateERP.jl\"","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"using UnfoldSim\nusing CairoMakie\nusing Random\nusing Unfold\nusing UnfoldMakie","category":"page"},{"location":"generated/tutorials/simulateERP/#ERP-Complex","page":"Simulate ERPs","title":"ERP Complex","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Here we will learn how to simulate a typical ERP complex with P100, N170, P300.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Let's grab a SingleSubjectDesign and add a continuous predictor","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"design = SingleSubjectDesign(;\n        conditions=Dict(:condition=>[\"car\",\"face\"],:continuous=>range(-5,5,length=10))\n        ) |> x->RepeatDesign(x,100);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Let's make use of the prespecified basis functions, but use different formulas + parameters for each!","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p100 is unaffected by our design and has amplitude of 5","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p1 =  LinearModelComponent(;\n        basis = p100(),\n        formula = @formula(0~1),\n        β = [5]\n        );\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"n170 has a condition effect, faces are more negative than cars","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"n1 =  LinearModelComponent(;\n        basis = n170(),\n        formula = @formula(0~1+condition),\n        β = [5,-3]\n        );\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p300 has a continuous effect, higher continuous values will result in larger P300's","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"p3 =  LinearModelComponent(;\n        basis = p300(),\n        formula = @formula(0~1+continuous),\n        β = [5,1]\n        );\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Now we can simply combine the components and simulate","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"components = [p1,n1,p3]\ndata,evts = simulate(MersenneTwister(1),design,[p1,n1,p3],UniformOnset(;width=0,offset=1000),PinkNoise());\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#Analysis","page":"Simulate ERPs","title":"Analysis","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"Let's check that everything worked out well, by using Unfold","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"m = fit(UnfoldModel,Dict(Any=>(@formula(0~1+condition+continuous),firbasis(τ=[-0.1,1],sfreq=100,name=\"basis\"))),evts,data);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"first the \"pure\" beta/linear regression parameters","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"plot_erp(coeftable(m))","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"and now beautifully visualized as marginal betas / predicted ERPs","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"plot_erp(effects(Dict(:condition=>[\"car\",\"face\"],:continuous=>-5:5),m);\n        mapping=(:color=>:continuous,linestyle=:condition,group=:continuous),\n        categorical_color=false)","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate ERPs","title":"Simulate ERPs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"EditURL = \"../../../literate/HowTo/newDesign.jl\"","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"using UnfoldSim\nusing StableRNGs\nusing DataFrames\nusing Parameters","category":"page"},{"location":"generated/HowTo/newDesign/#Define-a-new-Design","page":"Define a new, (imbalanced) design","title":"Define a new Design","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"A design specifies how much data is generated, and how the event-table(s) should be generated. Already implemented examples are MultiSubjectDesign and SingleSubjectDesign","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"We need 3 things for a new design: a struct<:AbstractDesign, a size and a generate function","category":"page"},{"location":"generated/HowTo/newDesign/#1)-type","page":"Define a new, (imbalanced) design","title":"1) type","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"We need a ImbalanceSubjectDesign struct. You are free to implement it as you wish, as long as the other two functions are implemented","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"@with_kw struct ImbalanceSubjectDesign <: UnfoldSim.AbstractDesign\n    nTrials::Int\n    balance::Float64 = 0.5 # default balanced\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#2)-size","page":"Define a new, (imbalanced) design","title":"2) size","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"we need a size(design::ImbalanceSubjectDesign) function to tell how many events we will have. This is used at different places, e.g. in the Default onset implementation","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"# note the trailing , to make it a Tuple\nsize(design::ImbalanceSubjectDesign) = (design.nTrials,);\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#3)-generate","page":"Define a new, (imbalanced) design","title":"3) generate","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"We need a type generate(design::ImbalanceSubjectDesign) function. This function should return the actual table as a DataFrame","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"function generate(design::ImbalanceSubjectDesign)\n    nA = Int(round.(design.nTrials .* design.balance))\n    nB = Int(round.(design.nTrials .* (1-design.balance)))\n    @assert nA + nB  ≈ design.nTrials\n    levels = vcat(repeat([\"levelA\"],nA),repeat([\"levelB\"],nB))\n    return DataFrame(Dict(:condition=>levels))\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"Finally, we can test the function and see whether it returns a Design-DataFrame as we requested","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"design = ImbalanceSubjectDesign(;nTrials=6,balance=0.2)\ngenerate(design)","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"warning: Important\nIt is the users task to ensure that each run is reproducible. So if you have a random process (e.g. shuffling), be sure to   safe a RNG object in your struct and use it in your generate function.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new, (imbalanced) design","title":"Define a new, (imbalanced) design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"EditURL = \"../../../literate/HowTo/multichannel.jl\"","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"using UnfoldSim\nusing UnfoldMakie\nusing CairoMakie\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/HowTo/multichannel/#Specifying-a-design","page":"Generate multi channel data","title":"Specifying a design","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"We are using a one-level design for testing here.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"design = SingleSubjectDesign(conditions=Dict(:condA=>[\"levelA\"]))","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Next we generate two simple components at two different times without any formula attached (we have a single condition anyway)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"c = LinearModelComponent(;basis=p100(),formula = @formula(0~1),β = [1]);\nc2 = LinearModelComponent(;basis=p300(),formula = @formula(0~1),β = [1]);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#The-multichannel-component","page":"Generate multi channel data","title":"The multichannel component","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"next similar to the nested design above, we can nest the component in a MultichannelComponent. We could either provide the projection marix manually, e.g.:","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"mc = UnfoldSim.MultichannelComponent(c, [1,2,-1,3,5,2.3,1])","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"or maybe more convenient: use the pair-syntax: Headmodel=>Label which makes use of a headmodel (HaRTmuT is currently easily available in UnfoldSim)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hart = headmodel(type=\"hartmut\")\nmc = UnfoldSim.MultichannelComponent(c, hart=>\"Left Postcentral Gyrus\")\nmc2 = UnfoldSim.MultichannelComponent(c2, hart=>\"Right Occipital Pole\")","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nYou could also specify a noise-specific component which is applied prior to projection & summing with other components","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"finally we need to define the onsets of the signal","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"onset = UniformOnset(;width=20,offset=4);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#Simulation","page":"Generate multi channel data","title":"Simulation","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Now as usual we simulate data. Inspecting data shows our result is now indeed ~230 Electrodes large! Nice!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"data,events = simulate(MersenneTwister(1),design, [mc,mc2],  onset, PinkNoise(noiselevel=0.05))\nsize(data)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nThe noise declared in the simulate function is added after mixing to channels, each channel receives independent noise. It is also possible to add noise to each individual component+source prior to projection. This would introduce correlated noise.","category":"page"},{"location":"generated/HowTo/multichannel/#Plotting","page":"Generate multi channel data","title":"Plotting","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Let's plot using Butterfly & Topoplot first we convert the electrodes to positions usable in TopoPlots.jl","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"pos3d = hart.electrodes[\"pos\"];\npos2d = to_positions(pos3d')\npos2d = [Point2f(p[1]+0.5,p[2]+0.5) for p in pos2d];\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"now plot!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"f = Figure()\ndf = DataFrame(:estimate => data[:],:channel => repeat(1:size(data,1),outer=size(data,2)),:time => repeat(1:size(data,2),inner=size(data,1)))\nplot_butterfly!(f[1,1:2],df;positions=pos2d)\nplot_topoplot!(f[2,1],df[df.time .== 28,:];positions=pos2d,visual=(;enlarge=0.5,label_scatter=false),axis=(;limits=((0,1),(0,0.9))))\nplot_topoplot!(f[2,2],df[df.time .== 48,:];positions=pos2d,visual=(;enlarge=0.5,label_scatter=false),axis=(;limits=((0,1),(0,0.9))))\nf","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"DocStrings","title":"DocStrings","text":"Modules = [UnfoldSim]","category":"page"},{"location":"api/#UnfoldSim.LinearModelComponent","page":"DocStrings","title":"UnfoldSim.LinearModelComponent","text":"A multiple regression component for one subject\n\nbasis: an object, if accessed, provides a 'basis-function', e.g. hanning(40), this defines the response at a single event. It will be weighted by the model-prediction\nformula: StatsModels Formula-Object  @formula 0~1+cond (left side must be 0)\nβ Vector of betas, must fit the formula\ncontrasts: Dict. Default is empty, e.g. Dict(:condA=>EffectsCoding())\n\nAll arguments can be named, in that case contrasts is optional\n\nWorks best with SingleSubjectDesign\n\nLinearModelComponent(;\n    basis=hanning(40),\n    formula=@formula(0~1+cond),\n    β = [1.,2.],\n    contrasts=Dict(:cond=>EffectsCoding())\n)\n\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MixedModelComponent","page":"DocStrings","title":"UnfoldSim.MixedModelComponent","text":"A component that adds a hierarchical relation between parameters according to a LMM defined via MixedModels.jl\n\nbasis: an object, if accessed, provides a 'basis-function', e.g. hanning(40), this defines the response at a single event. It will be weighted by the model-prediction\nformula: Formula-Object in the style of MixedModels.jl e.g. @formula 0~1+cond + (1|subject) - left-handside is ignored\nβ Vector of betas, must fit the formula\nσs Dict of random effect variances, e.g. Dict(:subject=>[0.5,0.4]) or to specify correlationmatrix Dict(:subject=>[0.5,0.4,I(2,2)],...). Technically, this will be passed to MixedModels.jl create_re function, which creates the θ matrices.\ncontrasts: Dict in the style of MixedModels.jl. Default is empty.\n\nAll arguments can be named, in that case contrasts is optional\n\nWorks best with MultiSubjectDesign\n\nMixedModelComponent(;\n    basis=hanning(40),\n    formula=@formula(0~1+cond+(1+cond|subject)),\n    β = [1.,2.],\n    σs= Dict(:subject=>[0.5,0.4]),\n    contrasts=Dict(:cond=>EffectsCoding())\n)\n\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultiSubjectDesign","page":"DocStrings","title":"UnfoldSim.MultiSubjectDesign","text":"n_subjects::Int -> number of subjects\nn_items::Int -> number of items (sometimes ≈trials)\nsubjects_between = nothing -> effects between subjects, e.g. young vs old \nitems_between = nothing -> effects between items, e.g. natural vs artificial images, but shown to all subjects\nboth_within = nothing\t-> effects completly crossed\ntableModifyFun = x->x; # can be used to sort, or x->shuffle(MersenneTwister(42),x) - be sure to fix/update the rng accordingly!!\n\ntipp: check the resulting dataframe using generate(design)\n\n# declaring same condition both sub-between and item-between results in a full between subject/item design\ndesign = MultiSubjectDesignjectDesign(;\n        n_items=10,\n\t\tn_subjects = 30,\n        subjects_between=Dict(:cond=>[\"levelA\",\"levelB\"]),\n\t\titems_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n        );\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultichannelComponent","page":"DocStrings","title":"UnfoldSim.MultichannelComponent","text":"Wrapper for an AbstractComponent to project it to multiple target-channels via projection. optional adds noise to the source prior to projection.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RepeatDesign","page":"DocStrings","title":"UnfoldSim.RepeatDesign","text":"repeat a design DataFrame multiple times to mimick repeatedly recorded trials\n\ndesignOnce = MultiSubjectDesign(;\n        n_items=2,\n\t\tn_subjects = 2,\n        subjects_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n\t\titems_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n        );\n\ndesign = RepeatDesign(designOnce,4);\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.SingleSubjectDesign","page":"DocStrings","title":"UnfoldSim.SingleSubjectDesign","text":"conditions = Dict of conditions, e.g. Dict(:A=>[\"a_small\",\"a_big\"],:B=>[\"b_tiny\",\"b_large\"])\ntableModifyFun = x->x; # can be used to sort, or x->shuffle(MersenneTwister(42),x) - be sure to fix/update the rng accordingly!!\n\nNumber of trials / rows in generate(design) depend on the full factorial of your conditions.\n\nTo increase the number of repetitions simply use RepeatDesign(SingleSubjectDesign(...),5)\n\ntipp: check the resulting dataframe using generate(design)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.size-Tuple{MultiSubjectDesign}","page":"DocStrings","title":"Base.size","text":"Returns dimension of experiment design\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Windows.hanning-Tuple{Any, Any, Any}","page":"DocStrings","title":"DSP.Windows.hanning","text":"generate a hanning window\n\nduration: in s offset: in s, defines hanning peak sfreq: sampling rate in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.adderp!-Tuple{Any, Vector, Vararg{Any, 4}}","page":"DocStrings","title":"UnfoldSim.adderp!","text":"Helper function to add inplace the erps to the EEG, but for both 2D (1 channel) and 3D (X channel case)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{AbstractVector{<:AbstractVector}, Any}","page":"DocStrings","title":"UnfoldSim.closest_src","text":"closest_src(coords_list::AbstractVector{<:AbstractVector}, pos)\nclosest_src(coords::Vector{<:Real}, pos)\n\nTakes an array of 'm' target coordinate vector (size 3) (or vector of vectors) and a matrix (n-by-3) of all available positions, and returns an array of size 'm' containing the indices of the respective items in 'pos' that are nearest to each of the target coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{Hartmut, String}","page":"DocStrings","title":"UnfoldSim.closest_src","text":"closest_src(head::Hartmut,label::String)\n\nReturns src-ix of the Headmodel Hartmut which is closest to the average of the label.\n\nimportant: Important\nWe use the average in eucledean space, but the cortex is a curved surface. In most cases they will not overlap. Ideally we would calculate the average on the surface, but this is a bit more complex to do (you'd need to calculate the vertices etc.)\n\nhartmut = headmodel()\npos = closest_src(hartmut=>\"Left Middle Temporal Gyrus, posterior division\")\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.convert-NTuple{4, Any}","page":"DocStrings","title":"UnfoldSim.convert","text":"Function to convert output similar to unfold (data, evts)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.gen_noise-Tuple{Any, UnfoldSim.RealisticNoise, Int64}","page":"DocStrings","title":"UnfoldSim.gen_noise","text":"gen_noise(t::RealisticNoise, n::Int)\n\nGenerate noise of a given type t and length n\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.gen_noise-Tuple{Any, Union{PinkNoise, RedNoise}, Int64}","page":"DocStrings","title":"UnfoldSim.gen_noise","text":"gen_noise(t::Union{PinkNoise, RedNoise}, n::Int)\n\nGenerate noise of a given type t and length n\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.gen_noise-Tuple{Any, WhiteNoise, Int64}","page":"DocStrings","title":"UnfoldSim.gen_noise","text":"gen_noise(t::WhiteNoise, n::Int)\n\nGenerate noise of a given type t and length n\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate-Tuple{MultiSubjectDesign}","page":"DocStrings","title":"UnfoldSim.generate","text":"Generates full factorial Dataframe according to MixedModelsSim.jl 's simdatcrossed function Note: nitems = you can think of it as trials or better, as stimuli\n\nNote: No condition can be named dv which is used internally in MixedModelsSim / MixedModels as a dummy left-side\n\nAfterwards applies expdesign.tableModifyFun.  Could be used to duplicate trials, sort, subselect etc.\n\nFinally it sorts by :subject\n\njulia> d = MultiSubjectDesign(;nsubjects = 10,nitems=20,both_within= Dict(:A=>nlevels(5),:B=>nlevels(2))) julia> generate(d)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate-Tuple{SingleSubjectDesign}","page":"DocStrings","title":"UnfoldSim.generate","text":"Generates full-factorial DataFrame of expdesign.conditions\n\nAfterwards applies expdesign.tableModifyFun.\n\njulia> d = SingleSubjectDesign(;conditions= Dict(:A=>nlevels(5),:B=>nlevels(2))) julia> generate(d)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hartmut_citation-Tuple{}","page":"DocStrings","title":"UnfoldSim.hartmut_citation","text":"Returns citation-string for HArtMuT\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.headmodel-Tuple{}","page":"DocStrings","title":"UnfoldSim.headmodel","text":"Load a headmodel, using Artifacts.jl automatically downloads the required files\n\nCurrently only type=\"hartmut\" is implemented\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hrf-Tuple{}","page":"DocStrings","title":"UnfoldSim.hrf","text":"Generate a HRF kernel. \n\nTR = 1/sfreq default parameters taken from SPM\n\nCode adapted from Unfold.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.leadfield-Tuple{Hartmut}","page":"DocStrings","title":"UnfoldSim.leadfield","text":"Returns the leadfield\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Tuple{AbstractHeadmodel}","page":"DocStrings","title":"UnfoldSim.magnitude","text":"Extracts magnitude of the orientation-including leadfield.\n\nBy default uses the orientation specified in the headmodel\n\nFallback: along the third dimension using norm - the maximal projection\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Tuple{Hartmut}","page":"DocStrings","title":"UnfoldSim.magnitude","text":"Extract magnitude of 3-orientation-leadfield,  type (default: \"perpendicular\") => uses the provided source-point orientations - otherwise falls back to norm\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{AbstractComponent}","page":"DocStrings","title":"UnfoldSim.n_channels","text":"Returns the number of channels. By default = 1\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{MultichannelComponent}","page":"DocStrings","title":"UnfoldSim.n_channels","text":"for MultichannelComponent returns the length of the projection vector\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.padarray-Tuple{Vector, Tuple, Any}","page":"DocStrings","title":"UnfoldSim.padarray","text":"Pads array with specified value, length padarray(arr, len, val)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}","page":"DocStrings","title":"UnfoldSim.predef_2x2","text":"predef_2x2(rng::AbstractRNG;kwargs...)\n\nMost used kwargs is: return_epoched=true to ignore the overlap/onset bits and return already epoched data\n\ndesign\n\nn_items=100,\nn_subjects=1,\nconditions = Dict(:A=>[\"asmall\",\"abig\"],:B=>[\"btiny\",\"blarge\"]),\ntableModifyFun = x->shuffle(deepcopy(rng),x),\n\ncomponent / signal\n\nsignalsize = 100, length of simulated hanning window\nbasis= hanning(signalsize), the actual \"function\",signalsize` is only used here\nβ = [1,-0.5,.5,+1], the parameters\nσs = Dict(:subject=>[1,0.5,0.5,0.5],:item=>[1]), - only in n_subjects>=2 case, specifies the random effects\ncontrasts = Dict(:A=>EffectsCoding(),:B=>EffectsCoding()) - effect coding by default\nformula = n_subjects==1 ? @formula(0~1+AB) : @formula(dv~1+AB+(A*B|subject)+(1|item)),\n\nnoise\n\nnoiselevel = 0.2,\nnoise = PinkNoise(;noiselevel=noiselevel),\n\nonset\n\noverlap = (0.5,0.2),\nonset=UniformOnset(;offset=signalsizeoverlap[1],width=signalsizeoverlap[2]), #put offset to 1 for no overlap. put width to 0 for no jitter\n\nCareful if you modify nitems with nsubjects = 1, n_items has to be a multiple of 4 (or your equivalent conditions factorial, e.g. all combinations length)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_eeg-Tuple{Any}","page":"DocStrings","title":"UnfoldSim.predef_eeg","text":"predefeeg(;kwargs...) predefeeg(rng;kwargs...) predefeeg(rng,nsubjects;kwargs...)\n\nGene rates a P1/N1/P3 complex. In case n_subjects is defined - MixedModelComponentsare generated, elseLinearModelComponents`\n\nMost used kwargs is: return_epoched=true to ignore the overlap/onset bits and return already epoched data\n\nDefault params:\n\n. n_repeats=100\n\ntableModifyFun = x->shuffle(deepcopy(rng),x # random trial order\nconditions = Dict(...),\n\ncomponent / signal\n\nsfreq = 100,\np1 = (p100(;sfreq=sfreq), @formula(0~1),[5],Dict()), # P1 amp 5, no effects\nn1 = (n170(;sfreq=sfreq), @formula(0~1+condition),[5,-3],Dict()), # N1 amp 5, dummycoded condition effect (levels \"car\", \"face\") of -3\np3 = (p300(;sfreq=sfreq), @formula(0~1+continuous),[5,1],Dict()), # P3 amp 5, continuous effect range [-5,5] with slope 1\n\nnoise\n\nnoiselevel = 0.2,\nnoise = PinkNoise(;noiselevel=noiselevel),\n\nonset\n\noverlap = (0.5,0.2), # offset + width/length of Uniform noise. put offset to 1 for no overlap. put width to 0 for no jitter\nonset=UniformOnset(;offset=sfreq0.5overlap[1],width=sfreq0.5overlap[2]), \n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate-Tuple{Any, AbstractComponent, Simulation}","page":"DocStrings","title":"UnfoldSim.simulate","text":"by default call simulate with ::Abstractcomponent,::AbstractDesign`, but allow for custom types\n\nmaking use of other information in simulation\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate-Tuple{Any, LinearModelComponent, AbstractDesign}","page":"DocStrings","title":"UnfoldSim.simulate","text":"simulate a linearModel\n\njulia> c = UnfoldSim.LinearModelComponent([0,1,1,0],@formula(0~1+cond),[1,2],Dict()) julia> design = MultiSubjectDesign(;nsubjects=2,nitems=50,item_between=(;:cond=>[\"A\",\"B\"])) julia> simulate(StableRNG(1),c,design)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate-Tuple{Any, MixedModelComponent, AbstractDesign}","page":"DocStrings","title":"UnfoldSim.simulate","text":"simulate MixedModelComponent\n\njulia> design = MultiSubjectDesign(;nsubjects=2,nitems=50,item_between=(;:cond=>[\"A\",\"B\"])) julia> c = UnfoldSim.MixedModelComponent([0.,1,1,0],@formula(0~1+cond+(1|subject)),[1,2],Dict(:subject=>[2],),Dict()) julia> simulate(StableRNG(1),c,design)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate-Tuple{Any, Vector{<:AbstractComponent}, Simulation}","page":"DocStrings","title":"UnfoldSim.simulate","text":"Simulates erp data given the specified parameters \n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.weight_σs-Tuple{Dict, Float64, Float64}","page":"DocStrings","title":"UnfoldSim.weight_σs","text":"Weights a σs Dict for MixedModels.jl by a Float64\n\nFinally sales it by σ_lmm, as a trick to simulate noise-free LMMs\n\nI anticipate a function     function weight_σs(σs::Dict,b_σs::Dict,σ_lmm::Float64) where each σs entry can be weighted individually\n\n\n\n\n\n","category":"method"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"EditURL = \"../../../literate/reference/noisetypes.jl\"","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"using UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs\nimport StatsBase.autocor","category":"page"},{"location":"generated/reference/noisetypes/#What's-the-noise?","page":"Overview: NoiseTypes","title":"What's the noise?","text":"","category":"section"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"There are several noise-types directly implemented. Here is a comparison:","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"f = Figure()\nax_sig = f[1,1:2] = Axis(f;title=\"1.000 samples of noise\")\nax_spec = f[2,1] = Axis(f;title=\"Welch Periodigram\")\nax_auto = f[2,2] = Axis(f;title=\"Autocorrelogram (every 10th lag)\")\nfor n = [PinkNoise RedNoise WhiteNoise NoNoise ExponentialNoise]\n\n    # generate\n    noisevec = gen_noise(StableRNG(1),n(),10000)\n\n    # plot 1000 samples\n    lines!(ax_sig,noisevec[1:1000];label=string(n))\n\n    # calc spectrum\n    perio = welch_pgram(noisevec)\n\n    # plot spectrum\n    lines!(ax_spec,freq(perio),log10.(power(perio)))\n\n    lags = 0:10:500\n    autocor_vec = autocor(noisevec,lags)\n    lines!(ax_auto,lags,autocor_vec)\n\nend\nf[1:2,3] = Legend(f,ax_sig,\"NoiseType\")\nf","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"hint: Hint\n","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"We recommed for smaller signals the ExponentialNoise, maybe with a removed DC offset or a HighPass filter. For long signals, this Noise requires lot's of memory though. maybe Pinknoise is a better choice then.","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: NoiseTypes","title":"Overview: NoiseTypes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"EditURL = \"../../../literate/reference/basistypes.jl\"","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"using UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs","category":"page"},{"location":"generated/reference/basistypes/#Basistypes","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Basistypes","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"There are several basis types directly implemented. They can be easily used for the components.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"note: Note\nYou can use any arbitrary shape defined by yourself! We often make use of hanning(50) from the DSP.jl package.","category":"page"},{"location":"generated/reference/basistypes/#EEG","page":"Overview: Components (EEG, fMRI, Pupil)","title":"EEG","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"By default, the EEG bases assume a sampling rate of 100, which can easily be changed by e.g. p100(;sfreq=300)","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"f = Figure()\nax = f[1,1] = Axis(f)\nfor b in [p100,n170,p300,n400]\n    lines!(ax,b(),label=string(b))\n    scatter!(ax,b(),label=string(b))\nend\naxislegend(ax,merge=true)\nf","category":"page"},{"location":"generated/reference/basistypes/#fMRI","page":"Overview: Components (EEG, fMRI, Pupil)","title":"fMRI","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"default hrf TR is 1. Get to know all your favourite shapes!","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"##--\nf = Figure()\nplotConfig = (:peak=>1:3:10,\n             :psUnder=>10:5:30,\n             :amplitude=>2:5,\n             :shift=>0:3:10,\n             :peak_width => 0.1:0.5:1.5,\n             :psUnder_width => 0.1:0.5:1.5,\n             )\n\nfor (ix,pl) = enumerate(plotConfig)\n    col = (ix-1)%3 +1\n    row = Int(ceil(ix/3))\n\n    ax = f[row,col] = Axis(f)\n    cfg = collect(pl)\n    for k = cfg[2]\n        lines!(ax,UnfoldSim.hrf(;TR=0.1,(cfg[1]=>k,)...),label=string(k))\n    end\n\n    axislegend(string(cfg[1]);merge=true,)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/#Pupil","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Pupil","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"We use the simplified PuRF from Hoeks & Levelt, 1993. Note that https://www.science.org/doi/10.1126/sciadv.abi9979 show some evidence in their supplementary material, that the convolution model is not fully applicable.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"f = Figure()\nplotConfig = (:n=>5:3:15,\n             :tmax=>0.5:0.2:1.1,\n             )\n\nfor (ix,pl) = enumerate(plotConfig)\n    ax = f[1,ix] = Axis(f)\n    cfg = collect(pl)\n    for k = cfg[2]\n        lines!(ax,UnfoldSim.PuRF(;(cfg[1]=>k,)...),label=string(k))\n    end\n\n    axislegend(string(cfg[1]);merge=true,)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Components (EEG, fMRI, Pupil)","title":"Overview: Components (EEG, fMRI, Pupil)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"EditURL = \"../../../literate/tutorials/poweranalysis.jl\"","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"using UnfoldSim\nusing Unfold\nusing Statistics\nusing HypothesisTests\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/tutorials/poweranalysis/#Simple-Poweranalysis-Script","page":"Poweranalysis","title":"Simple Poweranalysis Script","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"For a power analysis, we will repeatedly simulate data, and check whether we can find a significant effect.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"We perform the power analysis on epoched data.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"pvals = fill(NaN,100)\n@time for seed = eachindex(pvals)\n    # Simulate data of 30 subjects\n    data,evts = UnfoldSim.predef_2x2(MersenneTwister(seed);\n                n_subjects=20, ## 30 subjects\n                overlap=(1,0), ## deactivate overlap\n                noiselevel=10,  ## add more noise to make it more challenging\n                return_epoched=true, ## saves us the epoching step\n                )\n\n\n    # take the mean over a pre-specified timewindow\n    evts.y = dropdims(mean(data[40:60,:],dims=1),dims=(1))\n\n    # extract the two levels of condition A\n    evts_reduced = combine(groupby(evts,[:subject,:A]),:y=>mean)\n    y_big = evts_reduced[evts_reduced.A .==\"a_big\",:y_mean]\n    y_small = evts_reduced[evts_reduced.A .==\"a_small\",:y_mean]\n\n    # calculate a one-sided t-test\n    pvals[seed] = pvalue(OneSampleTTest(y_big,y_small))\nend","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"let's calculate the power","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"power = mean(pvals .<0.05)*100","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Poweranalysis","title":"Poweranalysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"EditURL = \"../../../literate/reference/onsettypes.jl\"","category":"page"},{"location":"generated/reference/onsettypes/#Onset-types","page":"Overview: OnsetTypes","title":"Onset types","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The onset types determine the distances between event onsets in the continuous EEG signal. The distances are sampled from a certain probability distribution. Currently, there are two types of onset distributions implemented: UniformOnset and LogNormalOnset.","category":"page"},{"location":"generated/reference/onsettypes/#Setup","page":"Overview: OnsetTypes","title":"Setup","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"using UnfoldSim\nusing CairoMakie\nusing Random\n\n# Define a simple design and repeat it 10000.\n# This will result in 20000 events i.e. event onsets.\ndesign =\n    SingleSubjectDesign(conditions = Dict(:cond => [\"A\", \"B\"])) |>\n    x -> RepeatDesign(x, 10000);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#UniformOnset","page":"Overview: OnsetTypes","title":"UniformOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The UniformOnset is based on a uniform distribution and has two parameters: width and offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"onset_uniform = UniformOnset(; width = 50, offset = 0);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The width parameter defines the upper bound of the interval of the uniform distribution (its lower bound is 0) i.e. all values between 0 and width are equally probable.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the uniform distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let # hide\n    f = Figure(title = \"Event onsets (Uniform distribution)\") # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((50, 0), (80, 0)), \"width\"), # hide\n        (((50, 0), (50, 20)), \"offset\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for width and one for offset # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (width, offset) in combinations # hide\n            onsets = UnfoldSim.rand_onsets( # hide\n                MersenneTwister(42), # hide\n                UniformOnset(; width = width, offset = offset), # hide\n                design, # hide\n            ) # hide\n\n            hist!(ax, onsets, bins = range(0, 100, step = 1), label = \"($width, $offset)\") # hide\n\n            if label == \"offset\" && offset != 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let\n    f = Figure(title = \"Event onsets (Uniform distribution)\")\n\n    # Define parameter combinations\n    parameters = [(((50, 0), (80, 0)), \"width\"), (((50, 0), (50, 20)), \"offset\")]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for width and one for offset\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (width, offset) in combinations\n            onsets = UnfoldSim.rand_onsets(\n                MersenneTwister(42),\n                UniformOnset(; width = width, offset = offset),\n                design,\n            )\n\n            hist!(ax, onsets, bins = range(0, 100, step = 1), label = \"($width, $offset)\")\n\n            if label == \"offset\" && offset != 0\n                vlines!(offset, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#LogNormalOnset","page":"Overview: OnsetTypes","title":"LogNormalOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The LogNormalOnset is based on a log-normal distribution and has four parameters: μ, σ, offset and truncate_upper.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"onset_lognormal = LogNormalOnset(; μ = 3, σ = 0.25, offset = 0, truncate_upper = nothing);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The parameters μ and σ are the location and scale parameter of the log-normal distribution. However, they are not identical to its mean and standard deviation. If a variable X is log-normally distributed then Y = ln(X) is normally distributed with mean μ and standard deviation σ[1].","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the log-normal distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"The truncate_upper parameter allows to truncate the distribution at a certain sample value. Its default value is nothing, i.e. no truncation.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let # hide\n    f = Figure(title = \"Event onsets (Lognormal distribution)\", size = (600, 800)) # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (μ, σ, offset, truncate_upper) in combinations # hide\n            onsets = UnfoldSim.rand_onsets( # hide\n                MersenneTwister(42), # hide\n                LogNormalOnset(; # hide\n                    μ = μ, # hide\n                    σ = σ, # hide\n                    offset = offset, # hide\n                    truncate_upper = truncate_upper, # hide\n                ), # hide\n                design, # hide\n            ) # hide\n\n            hist!( # hide\n                ax, # hide\n                onsets, # hide\n                bins = range(0, 100, step = 1), # hide\n                label = \"($μ,$σ,$offset,$truncate_upper)\", # hide\n            ) # hide\n\n            if label == \"offset\" && offset !== 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing # hide\n                vlines!(truncate_upper, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"let\n    f = Figure(title = \"Event onsets (Lognormal distribution)\", size = (600, 800))\n\n    # Define parameter combinations\n    parameters = [\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"),\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"),\n    ]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (μ, σ, offset, truncate_upper) in combinations\n            onsets = UnfoldSim.rand_onsets(\n                MersenneTwister(42),\n                LogNormalOnset(;\n                    μ = μ,\n                    σ = σ,\n                    offset = offset,\n                    truncate_upper = truncate_upper,\n                ),\n                design,\n            )\n\n            hist!(\n                ax,\n                onsets,\n                bins = range(0, 100, step = 1),\n                label = \"($μ,$σ,$offset,$truncate_upper)\",\n            )\n\n            if label == \"offset\" && offset !== 0\n                vlines!(offset, color = \"black\")\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing\n                vlines!(truncate_upper, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#Overlap-of-subsequent-events","page":"Overview: OnsetTypes","title":"Overlap of subsequent events","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"note: Note\nThe overlap of subsequent events can be indirectly controlled by setting the offset parameter relative to the length of the component basis.   Assuming that signal is a component e.g. LinearModelComponent,if offset > length(signal.basis) -> no overlap\nif offset < length(signal.basis) -> there might be overlap, depending on the other parameters of the onset distribution","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"# Footnotes # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"[1]: Wikipedia contributors. (2023, December 5). Log-normal distribution. In Wikipedia, The Free Encyclopedia. Retrieved 12:27, December 7, 2023, from https://en.wikipedia.org/w/index.php?title=Log-normal_distribution&oldid=1188400077#","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: OnsetTypes","title":"Overview: OnsetTypes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"EditURL = \"../../../literate/reference/overview.jl\"","category":"page"},{"location":"generated/reference/overview/#Overview-of-functionality","page":"Overview: Toolbox Functions","title":"Overview of functionality","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"UnfoldSim has many modules, here we try to collect them to provide you with an overview.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"using UnfoldSim\nusing InteractiveUtils","category":"page"},{"location":"generated/reference/overview/#Design","page":"Overview: Toolbox Functions","title":"Design","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Designs define the experimental design. They can be nested, e.g. RepeatDesign(SingleSubjectDesign,10) would repeat the generated design-dataframe 10x.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractDesign)","category":"page"},{"location":"generated/reference/overview/#Component","page":"Overview: Toolbox Functions","title":"Component","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Components define a signal. Some components can be nested, e.g. LinearModelComponent|>MultichannelComponent, see the multi-channel tutorial for more information.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractComponent)","category":"page"},{"location":"generated/reference/overview/#Onsets","page":"Overview: Toolbox Functions","title":"Onsets","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Onsets define the distance between events in the continuous signal.","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractOnset)","category":"page"},{"location":"generated/reference/overview/#Noise","page":"Overview: Toolbox Functions","title":"Noise","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"Choose the noise you need!","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"subtypes(AbstractNoise)","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"","category":"page"},{"location":"generated/reference/overview/","page":"Overview: Toolbox Functions","title":"Overview: Toolbox Functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"EditURL = \"../../../literate/tutorials/quickstart.jl\"","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"using UnfoldSim\nusing Random\nusing CairoMakie","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"tip: Tip\nUse subtypes(AbstractNoise) (or subtypes(AbstractComponent) etc.) to find already implemented building blocks.","category":"page"},{"location":"generated/tutorials/quickstart/#\"Experimental\"-Design","page":"Quickstart","title":"\"Experimental\" Design","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a 1 x 2 design with 20 trials. That is, one condition (condaA) with two levels.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"design = SingleSubjectDesign(;\n        conditions=Dict(:condA=>[\"levelA\",\"levelB\"])\n        ) |> x->RepeatDesign(x,10);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Component-/-Signal","page":"Quickstart","title":"Component / Signal","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a simple component and ground truth simulation formula. Akin to ERP components, we call one simulation signal a component.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nYou could easily specify multiple components by providing a vector of components, which are automatically added at the same onsets. This procedure simplifies to generate some response that is independent of simulated condition, whereas other depends on it.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"signal = LinearModelComponent(;\n        basis=[0,0,0,0.5,1,1,0.5,0,0],\n        formula = @formula(0~1+condA),\n        β = [1,0.5]\n        );\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Onsets-and-Noise","page":"Quickstart","title":"Onsets and Noise","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"We will start with a uniform (but overlapping, offset < length(signal.basis)) onset-distribution","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"onset = UniformOnset(;width=20,offset=4);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"And we will use some noise","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"noise = PinkNoise(;noiselevel=0.2);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Combine-and-Generate","page":"Quickstart","title":"Combine & Generate","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"We will put it all together in one Simulation type","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"simulation = Simulation(design, signal,  onset, noise);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"finally, we will simulate some data","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"data,events = simulate(MersenneTwister(1),simulation);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Data is a n-sample Vector (but could be a Matrix for e.g. MultiSubjectDesign).","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"events is a DataFrame that contains a column latency with the onsets of events.","category":"page"},{"location":"generated/tutorials/quickstart/#Plot-them!","page":"Quickstart","title":"Plot them!","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"lines(data;color=\"black\")\nvlines!(events.latency;color=[\"orange\",\"teal\"][1 .+ (events.condA.==\"levelB\")])\ncurrent_figure()","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"EditURL = \"../../../literate/HowTo/repeatTrials.jl\"","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"using UnfoldSim","category":"page"},{"location":"generated/HowTo/repeatTrials/#Repeating-Design-entries","page":"Repeating a design","title":"Repeating Design entries","text":"","category":"section"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"Sometimes we want to repeat a design, that is, have multiple trials with identical values, but it is not always straight forward to implement. For instance, there is no way to easily modify MultiSubjectDesign to have multiple identical subject/item combinations, without doing awkward repetitions of condition-levels or something.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"If you struggle with this problem RepeatDesign is an easy tool for you:","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"designOnce = MultiSubjectDesign(;\n    n_items=2,\n    n_subjects = 2,\n    subjects_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n    items_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n);\n\ndesign = RepeatDesign(designOnce,4);\ngenerate(design)","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"As you can see, the design was simply repeated. As always, you can ignore the dv column, it is for internal consistency with MixedModelsSim.jl","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"note: Note\nIf you implemented your own AbstractDesign, you need to define the size function accordingly. E.g.:   Base.size(design::RepeatDesign{SingleSubjectDesign}) = size(design.design).*design.repeat","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Repeating a design","title":"Repeating a design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = UnfoldSim","category":"page"},{"location":"#UnfoldSim","page":"Home","title":"UnfoldSim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for UnfoldSim.","category":"page"},{"location":"#Start-simulating-timeseries","page":"Home","title":"Start simulating timeseries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We offer some predefined signals, check them out!","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance an P1/N170/P300 complex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnfoldSim\nusing CairoMakie\ndata,evts = UnfoldSim.predef_eeg(;n_repeats=1,noiselevel=0.8)\n\nlines(data;color=\"black\")\nvlines!(evts.latency;color=[\"orange\",\"teal\"][1 .+ (evts.condition .==\"car\")])\n\ncurrent_figure()","category":"page"},{"location":"#Or-simulate-epoched-data-directly","page":"Home","title":"Or simulate epoched data directly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\ndata,evts = UnfoldSim.predef_eeg(;n_repeats=20,noiselevel=0.8,return_epoched=true)\nheatmap(data[:,sortperm(evts,[:condition,:continuous])])\n","category":"page"}]
}
