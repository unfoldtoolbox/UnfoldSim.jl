var documenterSearchIndex = {"docs":
[{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"EditURL = \"../../../literate/HowTo/newComponent.jl\"","category":"page"},{"location":"generated/HowTo/newComponent/#Define-a-new-component-(with-variable-duration-and-shift)","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"We want a new component that changes its duration and shift depending on a column in the event design. This is somewhat already implemented in the HRF + Pupil bases.","category":"page"},{"location":"generated/HowTo/newComponent/#Setup","page":"Define a new component (with variable duration and shift)","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"using UnfoldSim\nusing Unfold\nusing Random\nusing DSP\nusing CairoMakie, UnfoldMakie\n\nsfreq = 100;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"</details >","category":"page"},{"location":"generated/HowTo/newComponent/#Design","page":"Define a new component (with variable duration and shift)","title":"Design","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"Let's generate a design with two columns, shift + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"design = UnfoldSim.SingleSubjectDesign(;\n    conditions = Dict(\n        :shift => rand(100) .* sfreq / 5,\n        :duration => 20 .+ rand(100) .* sfreq / 5,\n    ),\n)","category":"page"},{"location":"generated/HowTo/newComponent/#Implement-a-new-AbstractComponent","page":"Define a new component (with variable duration and shift)","title":"Implement a new AbstractComponent","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"We also need a new AbstractComponent","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"struct TimeVaryingComponent <: AbstractComponent\n    basisfunction::Any\n    maxlength::Any\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"We have to define the length of a component","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"Base.length(c::TimeVaryingComponent) = length(c.maxlength)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"While we could have put the TimeVaryingComponent.basisfunction directly into the simulate function, I thought this is a bit more modular","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"function UnfoldSim.simulate(rng, c::TimeVaryingComponent, design::AbstractDesign)\n    evts = generate_events(design)\n    return c.basisfunction(evts, c.maxlength)\nend","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"finally, the actual function that does the shifting + duration","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"function basis_shiftduration(evts, maxlength)\n    basis = hanning.(Int.(round.(evts.duration))) ## hanning as long as duration\n    if \"shift\" ∈ names(evts)\n        basis = pad_array.(basis, Int.(round.(.-evts.shift)), 0) ## shift by adding 0 in front\n    end\n    # we should make sure that all bases have maxlength by appending / truncating\n    difftomax = maxlength .- length.(basis)\n    if any(difftomax .< 0)\n        @warn \"basis longer than max length in at least one case. either increase maxlength or redefine function. Trying to truncate the basis\"\n        basis[difftomax.>0] = pad_array.(basis[difftomax.>0], difftomax[difftomax.>0], 0)\n        return [b[1:maxlength] for b in basis]\n    else\n        return pad_array.(basis, difftomax, 0)\n    end\nend","category":"page"},{"location":"generated/HowTo/newComponent/#Simulate-data-with-the-new-component-type","page":"Define a new component (with variable duration and shift)","title":"Simulate data with the new component type","text":"","category":"section"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"erp = UnfoldSim.simulate(\n    MersenneTwister(1),\n    TimeVaryingComponent(basis_shiftduration, 50),\n    design,\n)\nplot_erpimage(hcat(erp...), sortvalues = generate_events(design).shift)","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"","category":"page"},{"location":"generated/HowTo/newComponent/","page":"Define a new component (with variable duration and shift)","title":"Define a new component (with variable duration and shift)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"EditURL = \"../../../literate/tutorials/simulateERP.jl\"","category":"page"},{"location":"generated/tutorials/simulateERP/#Simulate-event-related-potentials-(ERPs)","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"One subfield of EEG research focuses on so-called event-related potentials (ERPs) which are defined as brain responses time-locked to a certain event e.g. stimulus onset. The waveform of an ERP usually consists of multiple ERP components which denote the peaks and troughs of the waveform.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"ERP components are characterized (and named) by their timing relative to the event, their polarity (positive or negative) and their scalp topography. For example, the N170 describes a negative deflection which occurrs roughly 170 ms after the onset of (certain) visual stimuli. Often, researchers are interested how a component (e.g. its amplitude or timing) changes depending on certain experimental factors. For example, N170 has been shown to be related to face processing and its amplitude is modulated by whether the stimulus is a face or an object e.g. a car. (Source)","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Here we will learn how to simulate a typical ERP complex with P100, N170, P300.","category":"page"},{"location":"generated/tutorials/simulateERP/#Setup","page":"Simulate event-related potentials (ERPs)","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"# Load required packages\nusing UnfoldSim # For simulation\nusing Random # For randomization\nusing StableRNGs # To get an RNG\nusing Unfold # For analysis\nusing CairoMakie # For plotting\nusing UnfoldMakie # For plotting","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"</details >","category":"page"},{"location":"generated/tutorials/simulateERP/#Specify-the-simulation-\"ingredients\"","page":"Simulate event-related potentials (ERPs)","title":"Specify the simulation \"ingredients\"","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/#1.-Experimental-design","page":"Simulate event-related potentials (ERPs)","title":"1. Experimental design","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"We specify an experimental design with one subject in two experimental conditions including a continuous variable with 10 values. To mimic randomization in an experiment, we shuffle the trials using the event_order_function argument. To generate more trials we repeat the design 100 times which results in 2000 trials in total.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"design =\n    SingleSubjectDesign(;\n        conditions = Dict(\n            :condition => [\"car\", \"face\"],\n            :continuous => range(0, 5, length = 10),\n        ),\n        event_order_function = shuffle,\n    ) |> x -> RepeatDesign(x, 100);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"The generate_events function can be used to create an events data frame from the specified experimental design.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"events_df = generate_events(StableRNG(1), design);\nfirst(events_df, 5)","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Above you can see the first five rows extracted from the events data frame representing the experimental design. Each row corresponds to one event. The columns continuous and condition display the levels of the predictor variables for the specific event.","category":"page"},{"location":"generated/tutorials/simulateERP/#2.-Event-basis-functions-(Components)","page":"Simulate event-related potentials (ERPs)","title":"2. Event basis functions (Components)","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Next, we create a signal consisting of three different components.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"For the first component, we use the prespecified P100 base which will be unaffected by our design and has an amplitude of 5 µV.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"p1 = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [5]);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"For the second component, we use the prespecified N170 base with an intercept of 5 µV and a condition effect of 3 µV for the “face/car” condition i.e. faces will have a more negative signal than cars.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"n1 = LinearModelComponent(;\n    basis = n170(),\n    formula = @formula(0 ~ 1 + condition),\n    β = [5, 3],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"For the third component, we use the prespecified P300 base and include a linear and a quadratic effect of the continuous variable: the larger the value of the continuous variable, the larger the simulated potential.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"p3 = LinearModelComponent(;\n    basis = p300(),\n    formula = @formula(0 ~ 1 + continuous + continuous^2),\n    β = [5, 1, 0.2],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#3.-Inter-onset-distribution","page":"Simulate event-related potentials (ERPs)","title":"3. Inter-onset distribution","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"In the next step, we specify an inter-onset distribution, in this case, a uniform distribution with an inter-event distance of exactly 200 samples.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"onset = UniformOnset(; width = 0, offset = 200);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#4.-Noise-specification","page":"Simulate event-related potentials (ERPs)","title":"4. Noise specification","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"As the last ingredient, we specify the noise, in this case, Pink noise.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"noise = PinkNoise(; noiselevel = 2);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/#Simulate-data","page":"Simulate event-related potentials (ERPs)","title":"Simulate data","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"Finally, we combine all the ingredients and simulate data. To make the simulation reproducible, one can specify a random generator.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"# Combine the components in a vector\ncomponents = [p1, n1, p3]\n\n# Simulate data\neeg_data, events_df = simulate(StableRNG(1), design, components, onset, noise);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"To inspect the simulated data we will visualize the first 1400 samples.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"<details>\n<summary>Click to show the code for the figure below</summary>","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"f = Figure(size = (1000, 400))\nax = Axis(\n    f[1, 1],\n    title = \"Simulated EEG data\",\n    titlesize = 18,\n    xlabel = \"Time [samples]\",\n    ylabel = \"Amplitude [µV]\",\n    xlabelsize = 16,\n    ylabelsize = 16,\n    xgridvisible = false,\n    ygridvisible = false,\n)\n\nn_samples = 1400\nlines!(eeg_data[1:n_samples]; color = \"black\")\nv_lines = [\n    vlines!(\n        [r[\"latency\"]];\n        color = [\"orange\", \"teal\"][1+(r[\"condition\"]==\"car\")],\n        label = r[\"condition\"],\n    ) for r in\n    filter(:latency => x -> x < n_samples, events_df)[:, [\"latency\", \"condition\"]] |>\n    eachrow\n]\nxlims!(ax, 0, n_samples)\naxislegend(\"Event onset\"; unique = true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"</details >","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"current_figure()","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"The vertical lines denote the event onsets and their colour represents the respective condition i.e. car or face.","category":"page"},{"location":"generated/tutorials/simulateERP/#Validate-the-simulation-results","page":"Simulate event-related potentials (ERPs)","title":"Validate the simulation results","text":"","category":"section"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"To validate the simulation results, we use the Unfold.jl package to fit an Unfold regression model to the simulated data and examine the estimated regression parameters and marginal effects. For the formula, we include a categorical predictor for condition and a non-linear predictor (based on splines) for continuous.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"m = fit(\n    UnfoldModel,\n    [\n        Any => (\n            @formula(0 ~ 1 + condition + spl(continuous, 4)),\n            firbasis(τ = [-0.1, 1], sfreq = 100, name = \"basis\"),\n        ),\n    ],\n    events_df,\n    eeg_data,\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"To inspect the modelling results we will visualize the model coefficient estimates together with the estimated marginal effects i.e. the predicted ERPs.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"<details>\n<summary>Click to show the code for the figure below</summary>","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"# Create a data frame with the model coefficients and extract the coefficient names\ncoefs = coeftable(m)\ncoefnames = unique(coefs.coefname)\n\nf2 = Figure(size = (1000, 400))\nga = f2[1, 1] = GridLayout()\ngb = f2[1, 2] = GridLayout()\n\n# Plot A: Estimated regression parameters\nax_A = Axis(\n    ga[1, 1],\n    title = \"Estimated regression parameters\",\n    titlegap = 12,\n    xlabel = \"Time [s]\",\n    ylabel = \"Amplitude [μV]\",\n    xlabelsize = 16,\n    ylabelsize = 16,\n    xgridvisible = false,\n    ygridvisible = false,\n)\n\nfor coef in coefnames\n    estimate = filter(:coefname => ==(coef), coefs)\n\n    lines!(ax_A, estimate.time, estimate.estimate, label = coef)\nend\naxislegend(\"Coefficient\", framevisible = false)\nhidespines!(ax_A, :t, :r)\n\n# Plot B: Marginal effects\nplot_B = plot_erp!(\n    gb,\n    effects(Dict(:condition => [\"car\", \"face\"], :continuous => 0:0.5:5), m);\n    mapping = (; color = :continuous, linestyle = :condition, group = :continuous),\n    legend = (; valign = :top, halign = :right),\n    axis = (\n        title = \"Marginal effects\",\n        titlegap = 12,\n        xlabel = \"Time [s]\",\n        ylabel = \"Amplitude [μV]\",\n        xlabelsize = 16,\n        ylabelsize = 16,\n        xgridvisible = false,\n        ygridvisible = false,\n    ),\n)\n\n# Add letter labels to the plots\n# Adapted from: https://docs.makie.org/stable/tutorials/layout-tutorial/\nfor (label, layout) in zip([\"A\", \"B\"], [ga, gb])\n    Label(\n        layout[1, 1, TopLeft()],\n        label,\n        fontsize = 26,\n        font = :bold,\n        padding = (0, 5, 5, 0),\n        halign = :right,\n    )\nend","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"</details >","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"current_figure()","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"In subplot A, one can see the model coefficient estimates and as intended the first component is unaffected by the experimental design, there is a condition effect in the second component and an effect of the continuous variable on the third component. The relation between the levels of the continuous variable and the scaling of the third component is even clearer visible in subplot B which depicts the estimated marginal effects of the predictors which are obtained by evaluating the estimated function at specific values of the continuous variable.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"As shown in this example, UnfoldSim.jl and Unfold.jl can be easily combined to investigate the effects of certain features, e.g. the type of noise or its intensity on the analysis result and thereby assess the robustness of the analysis.","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"","category":"page"},{"location":"generated/tutorials/simulateERP/","page":"Simulate event-related potentials (ERPs)","title":"Simulate event-related potentials (ERPs)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"EditURL = \"../../../literate/tutorials/multisubject.jl\"","category":"page"},{"location":"generated/tutorials/multisubject/#Multi-subject-simulation","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In this tutorial, you will learn how to simulate data for multiple subjects. In particular, you will learn how to specify fixed and random effects and what their influence on the simulated data looks like.","category":"page"},{"location":"generated/tutorials/multisubject/#Setup","page":"Multi-subject simulation","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"# Load required packages\nusing UnfoldSim\nusing Unfold\nusing CairoMakie\nusing UnfoldMakie\nusing DataFrames","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"</details >\n<br />","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Similar to the single subject case, multi-subject simulation depends on:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Design (typically a MultiSubjectDesign)\nComponents (typically a MixedModelComponent)\nOnset (any)\nNoise (any)","category":"page"},{"location":"generated/tutorials/multisubject/#Design","page":"Multi-subject simulation","title":"Design","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Our first design should be 20 subjects, with 4 items each. Any individual image is shown only either as large or small, thus we choose items_between.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"design = MultiSubjectDesign(\n    n_subjects = 20,\n    n_items = 4,\n    items_between = Dict(:condition => [\"large\", \"small\"]),\n)","category":"page"},{"location":"generated/tutorials/multisubject/#Between,-within?","page":"Multi-subject simulation","title":"Between, within?","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In the beginning, the distinction between between-items, between-subjects and within-subjects, within-items and both-between, both-within feels daunting.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We base our terminology on MixedModelsSim which uses the following definitions:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"subjects_between -> effects between subjects, e.g. young vs old\nitems_between -> effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified in subjects_between as well)\nboth_within -> effects completly crossed, e.g. word vs. scramble, where the \"original\" word is the item, and shown to all subjects","category":"page"},{"location":"generated/tutorials/multisubject/#Components","page":"Multi-subject simulation","title":"Components","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"For multi-subject, similar to the LinearModelComponent specified before, we have to define the fixed effect β, the model parameters that are applied to all subjects.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"β = [1, 2] # 1 = intercept, 2 = difference between large and small","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"In addition, we have to provide random effects σs, which define the spread (and  correlation) of the subjects around the fixed effects, foreach parameter","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"σs = Dict(\n    :subject => [0.5, 1], # we have more spread in the condition-effect\n    :item => [1], # the item-variability is higher than the subject-variability\n)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"now we are ready to assemble the parts","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"signal = MixedModelComponent(;\n    basis = UnfoldSim.hanning(50),\n    formula = @formula(0 ~ 1 + condition + (1 + condition | subject) + (1 | item)),\n    β = β,\n    σs = σs,\n    contrasts = Dict(:condition => EffectsCoding()), # we highly recommend specifying your contrasts, by Default its Dummy/ReferenceCoding with alphabetically sorted levels (relying 100% on StatsModels.jl)\n)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"and simulate!","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(design, signal, NoOnset(), NoNoise(), return_epoched = true);\nnothing #hide","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We get data with 50 samples (our basis from above), with 4 items and 20 subjects. We get items and subjects separately because we chose no-overlap (via NoOnset) and return_epoched = true`.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"size(data)\n\nfirst(evts, 5)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Finally, let's plot the data","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"f = Figure()\n\nfor k = 1:4\n    series(\n        f[1, k],\n        data[:, k, :]',\n        solid_color = :black,\n        axis = (; limits = ((0, 50), (-5, 6))),\n    )\n    Label(f[1, k, Top()], text = \"Item:\" * evts[k, :item] * \", c:\" * evts[k, :condition])\nend\nf","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Some remarks on interpreting the plot:","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"The β main-effect of small (#2 and #4) vs. large (#1 and #3) is clearly visible.\nThe variability between subjects, is the variability between the individual curves.\nThe item effect shows up e.g. that #2 vs. #4 column show different values.","category":"page"},{"location":"generated/tutorials/multisubject/#Continuous-Signals-/-Overlap","page":"Multi-subject simulation","title":"Continuous Signals / Overlap","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Let's continue our tutorial and simulate overlapping signals instead.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We replace the NoOnset with an UniformOnset with 20 to 70 samples between subsequent events.  We further remove the return_epoched, because we want to have continuous data for now.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(design, signal, UniformOnset(offset = 20, width = 50), NoNoise());\nsize(data)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"with the first dimension being continuous data, and the latter still the subjects.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"series(data', solid_color = :black)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"Each line is one subject, and it looks a bit unstructured, because the event-onsets are of course random for each subject.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"note: Note\nAll subjects have the same sequence of trials, if you need to change this, specify a event_order_function in the MultiSubjectDesign.","category":"page"},{"location":"generated/tutorials/multisubject/#Analyzing-these-data-with-Unfold.jl","page":"Multi-subject simulation","title":"Analyzing these data with Unfold.jl","text":"","category":"section"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"We will analyze these data using the Unfold.jl toolbox. While preliminary support for deconvolution (overlap correction) for mixed models is available, here we will not make use of it, but rather apply a MixedModel to each timepoint, following the Mass-univariate approach.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data, evts = simulate(\n    design,\n    signal,\n    UniformOnset(offset = 20, width = 50),\n    NoNoise();\n    return_epoched = true,\n);\nsize(data)","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"For Unfold.jl, we have to reshape the data, so that all subjects are concatenated.","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"data = reshape(data, size(data, 1), :)\ntimes = range(0, 1, length = size(data, 1))\nm = fit(\n    UnfoldModel,\n    @formula(0 ~ 1 + condition + (1 | item) + (1 + condition | subject)),\n    evts,\n    data,\n    times,\n)\nplot_erp(coeftable(m), mapping = (; col = :group))","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"The first column shows the fixed effects, the latter the item and subject random effects as they evolve across time","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"","category":"page"},{"location":"generated/tutorials/multisubject/","page":"Multi-subject simulation","title":"Multi-subject simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"EditURL = \"../../../literate/HowTo/newDesign.jl\"","category":"page"},{"location":"generated/HowTo/newDesign/#Define-a-new-(imbalanced)-design","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"A design specifies how much data is generated, and how the event-table(s) should be generated. Already implemented examples are MultiSubjectDesign and SingleSubjectDesign.","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"We need 3 things for a new design: a struct<:AbstractDesign, a size and a generate_events function.","category":"page"},{"location":"generated/HowTo/newDesign/#Setup","page":"Define a new (imbalanced) design","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"using UnfoldSim\nusing StableRNGs\nusing DataFrames\nusing Parameters\nusing Random","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"</details>\n<br />","category":"page"},{"location":"generated/HowTo/newDesign/#1)-type","page":"Define a new (imbalanced) design","title":"1) type","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"We need a ImbalanceSubjectDesign struct. You are free to implement it as you wish, as long as the other two functions are implemented","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"@with_kw struct ImbalanceSubjectDesign <: UnfoldSim.AbstractDesign\n    n_trials::Int\n    balance::Float64 = 0.5 # default balanced\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#2)-size","page":"Define a new (imbalanced) design","title":"2) size","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"we need a size(design::ImbalanceSubjectDesign) function to tell how many events we will have. This is used at different places, e.g. in the Default onset implementation","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"# note the trailing , to make it a Tuple\nUnfoldSim.size(design::ImbalanceSubjectDesign) = (design.n_trials,);\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/#3)-generate_events","page":"Define a new (imbalanced) design","title":"3) generate_events","text":"","category":"section"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"We need a type generate_events(rng::AbstractRNG, design::ImbalanceSubjectDesign) function. This function should return the actual table as a DataFrame","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"function UnfoldSim.generate_events(rng::AbstractRNG, design::ImbalanceSubjectDesign)\n    nA = Int(round.(design.n_trials .* design.balance))\n    nB = Int(round.(design.n_trials .* (1 - design.balance)))\n    @assert nA + nB ≈ design.n_trials\n    levels = vcat(repeat([\"levelA\"], nA), repeat([\"levelB\"], nB))\n    return DataFrame(Dict(:condition => levels))\nend;\nnothing #hide","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"Finally, we can test the function and see whether it returns a Design-DataFrame as we requested","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"design = ImbalanceSubjectDesign(; n_trials = 6, balance = 0.2)\ngenerate_events(design)","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"","category":"page"},{"location":"generated/HowTo/newDesign/","page":"Define a new (imbalanced) design","title":"Define a new (imbalanced) design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"EditURL = \"../../../literate/HowTo/multichannel.jl\"","category":"page"},{"location":"generated/HowTo/multichannel/#Generate-multi-channel-data","page":"Generate multi channel data","title":"Generate multi channel data","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Here you will learn how to simulate EEG data for multiple channels/electrodes. The idea is to specify a signal on source level and then use a head model or a manual projection matrix to project the source signal to a number of electrodes.","category":"page"},{"location":"generated/HowTo/multichannel/#Setup","page":"Generate multi channel data","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"# Load required packages\nusing UnfoldSim\nusing UnfoldMakie\nusing CairoMakie\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"</details >","category":"page"},{"location":"generated/HowTo/multichannel/#Specifying-a-design","page":"Generate multi channel data","title":"Specifying a design","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"We are using a one-level design for testing here.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"design = SingleSubjectDesign(conditions = Dict(:condA => [\"levelA\"]))","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Next we generate two simple components at two different times without any formula attached (we have a single condition anyway)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"c = LinearModelComponent(; basis = p100(), formula = @formula(0 ~ 1), β = [1]);\nc2 = LinearModelComponent(; basis = p300(), formula = @formula(0 ~ 1), β = [1]);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#The-multichannel-component","page":"Generate multi channel data","title":"The multichannel component","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Next, similar to the nested design above, we can nest the component in a MultichannelComponent. We could either provide the projection matrix manually, e.g.:","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"mc = UnfoldSim.MultichannelComponent(c, [1, 2, -1, 3, 5, 2.3, 1])","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"or maybe more convenient: use the pair-syntax: Headmodel=>Label which makes use of a headmodel (HaRTmuT is currently easily available in UnfoldSim)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hart = Hartmut()\nmc = UnfoldSim.MultichannelComponent(c, hart => \"Left Postcentral Gyrus\")\nmc2 = UnfoldSim.MultichannelComponent(c2, hart => \"Right Occipital Pole\")","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nYou could also specify a noise-specific component which is applied prior to projection & summing with other components.","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"finally we need to define the onsets of the signal","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"onset = UniformOnset(; width = 20, offset = 4);\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/#Simulation","page":"Generate multi channel data","title":"Simulation","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Now as usual we simulate data. Inspecting data shows our result is now indeed ~230 Electrodes large! Nice!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"data, events =\n    simulate(MersenneTwister(1), design, [mc, mc2], onset, PinkNoise(noiselevel = 0.05));\n\nsize(data)","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"hint: Hint\nThe noise declared in the simulate function is added after mixing to channels, each channel receives independent noise. It is also possible to add noise to each individual component+source prior to projection. This would introduce correlated noise.","category":"page"},{"location":"generated/HowTo/multichannel/#Plotting","page":"Generate multi channel data","title":"Plotting","text":"","category":"section"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"Let's plot using Butterfly & Topoplot first we convert the electrodes to positions usable in TopoPlots.jl","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"pos3d = hart.electrodes[\"pos\"];\npos2d = to_positions(pos3d')\npos2d = [Point2f(p[1] + 0.5, p[2] + 0.5) for p in pos2d];\nnothing #hide","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"now plot!","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"f = Figure()\ndf = DataFrame(\n    :estimate => data[:],\n    :channel => repeat(1:size(data, 1), outer = size(data, 2)),\n    :time => repeat(1:size(data, 2), inner = size(data, 1)),\n)\nplot_butterfly!(f[1, 1:2], df; positions = pos2d)\nplot_topoplot!(\n    f[2, 1],\n    df[df.time.==28, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nplot_topoplot!(\n    f[2, 2],\n    df[df.time.==48, :];\n    positions = pos2d,\n    visual = (; enlarge = 0.5, label_scatter = false),\n    axis = (; limits = ((0, 1), (0, 0.9))),\n)\nf","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"","category":"page"},{"location":"generated/HowTo/multichannel/","page":"Generate multi channel data","title":"Generate multi channel data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API / Docstrings","title":"API / Docstrings","text":"Modules = [UnfoldSim]","category":"page"},{"location":"api/#UnfoldSim.AutoRegressiveNoise","page":"API / Docstrings","title":"UnfoldSim.AutoRegressiveNoise","text":"AutoRegressiveNoise <: AbstractNoise\n\nNot implemented\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.ExponentialNoise","page":"API / Docstrings","title":"UnfoldSim.ExponentialNoise","text":"ExponentialNoise <: AbstractNoise\n\nNoise with exponential decay in AR spectrum.\n\nnoiselevel is used to scale the noise\n\nwarning: Warning\nWith the current implementation we try to get exponential decay over the whole autoregressive (AR) spectrum, which is N samples (the total number of samples in the signal) long. This involves the inversion of a Cholesky matrix of size NxN matrix, which will need lots of RAM for non-trivial problems.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.LinearModelComponent","page":"API / Docstrings","title":"UnfoldSim.LinearModelComponent","text":"A multiple regression component for one subject\n\nbasis: an object, if accessed, provides a 'basis-function', e.g. hanning(40), this defines the response at a single event. It will be weighted by the model-prediction\nformula: StatsModels Formula-Object  @formula 0~1+cond (left side must be 0)\nβ Vector of betas, must fit the formula\ncontrasts: Dict. Default is empty, e.g. Dict(:condA=>EffectsCoding())\n\nAll arguments can be named, in that case contrasts is optional\n\nWorks best with SingleSubjectDesign\n\nLinearModelComponent(;\n    basis=hanning(40),\n    formula=@formula(0~1+cond),\n    β = [1.,2.],\n    contrasts=Dict(:cond=>EffectsCoding())\n)\n\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.LogNormalOnset","page":"API / Docstrings","title":"UnfoldSim.LogNormalOnset","text":"@with_kw struct LogNormalOnset <: AbstractOnset\n\nLog-normal inter-event distances using the Distributions.jl truncated LogNormal distribution.\n\nBe careful with large μ and σ values, as they are on logscale. σ>8 can quickly give you out-of-memory sized signals!\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MixedModelComponent","page":"API / Docstrings","title":"UnfoldSim.MixedModelComponent","text":"A component that adds a hierarchical relation between parameters according to a LMM defined via MixedModels.jl\n\nbasis: an object, if accessed, provides a 'basis-function', e.g. hanning(40), this defines the response at a single event. It will be weighted by the model-prediction\nformula: Formula-Object in the style of MixedModels.jl e.g. @formula 0~1+cond + (1|subject) - left-handside is ignored\nβ Vector of betas, must fit the formula\nσs Dict of random effect variances, e.g. Dict(:subject=>[0.5,0.4]) or to specify correlationmatrix Dict(:subject=>[0.5,0.4,I(2,2)],...). Technically, this will be passed to MixedModels.jl create_re function, which creates the θ matrices.\ncontrasts: Dict in the style of MixedModels.jl. Default is empty.\n\nAll arguments can be named, in that case contrasts is optional\n\nWorks best with MultiSubjectDesign\n\nMixedModelComponent(;\n    basis=hanning(40),\n    formula=@formula(0~1+cond+(1+cond|subject)),\n    β = [1.,2.],\n    σs= Dict(:subject=>[0.5,0.4]),\n    contrasts=Dict(:cond=>EffectsCoding())\n)\n\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultiSubjectDesign","page":"API / Docstrings","title":"UnfoldSim.MultiSubjectDesign","text":"MultiSubjectDesign <: AbstractDesign\n\nA type for specifying the experimental design for multiple subjects (based on the given random-effects structure).\n\nFields\n\nn_subjects::Int -> number of subjects\nn_items::Int -> number of items (sometimes ≈trials)\nsubjects_between = Dict{Symbol,Vector} -> effects between subjects, e.g. young vs old \nitems_between = Dict{Symbol,Vector} -> effects between items, e.g. natural vs artificial images, (but shown to all subjects if not specified also in subjects_between)\nboth_within = Dict{Symbol,Vector}\t-> effects completly crossed\nevent_order_function = (rng, x) -> x; # can be used to sort, or e.g. (rng, x) -> shuffle(rng, x) (or shorter just event_order_function = shuffle)\n\nTip: Check the resulting dataframe using the generate_events function.\n\nExample\n\n# declaring same condition both sub-between and item-between results in a full between subject/item design\ndesign = MultiSubjectDesign(;\n\t\tn_items = 10,\n\t\tn_subjects = 30,\n\t\tsubjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n\t\titems_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n\t\t);\n\nSee also SingleSubjectDesign, RepeatDesign\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.MultichannelComponent","page":"API / Docstrings","title":"UnfoldSim.MultichannelComponent","text":"Wrapper for an AbstractComponent to project it to multiple target-channels via projection. optional adds noise to the source prior to projection.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.NoNoise","page":"API / Docstrings","title":"UnfoldSim.NoNoise","text":"NoNoise <: AbstractNoise\n\nReturn zeros instead of noise.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.NoOnset","page":"API / Docstrings","title":"UnfoldSim.NoOnset","text":"struct NoOnset <: AbstractOnset end\n\nIn the case that the user directly wants no overlap to be simulated (=> epoched data).\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.PinkNoise","page":"API / Docstrings","title":"UnfoldSim.PinkNoise","text":"PinkNoise <: AbstractNoise\n\nGenerate Pink Noise using the SignalAnalysis.jl implementation.\n\nnoiselevel is used to scale the noise\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RealisticNoise","page":"API / Docstrings","title":"UnfoldSim.RealisticNoise","text":"RealisticNoise <: AbstractNoise\n\nNot implemented - planned to use Artifacts.jl to provide real EEG data to add.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RedNoise","page":"API / Docstrings","title":"UnfoldSim.RedNoise","text":"RedNoise <: AbstractNoise\n\nGenerate Red Noise using the SignalAnalysis.jl implementation.\n\nnoiselevel is used to scale the noise\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.RepeatDesign","page":"API / Docstrings","title":"UnfoldSim.RepeatDesign","text":"RepeatDesign{T} <: AbstractDesign\n\nRepeat a design DataFrame multiple times to mimick repeatedly recorded trials.\n\ndesignOnce = MultiSubjectDesign(;\n\t\tn_items=2,\n\t\tn_subjects = 2,\n\t\tsubjects_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n\t\titems_between =Dict(:cond=>[\"levelA\",\"levelB\"]),\n\t\t);\n\ndesign = RepeatDesign(designOnce,4);\n\nSee also SingleSubjectDesign, MultiSubjectDesign\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.SingleSubjectDesign","page":"API / Docstrings","title":"UnfoldSim.SingleSubjectDesign","text":"SingleSubjectDesign <: AbstractDesign\n\nA type for specifying the experimental for a single subject (based on the given conditions).\n\nFields\n\nconditions = Dict{Symbol,Vector}of conditions, e.g.Dict(:A=>[\"asmall\",\"abig\"],:B=>[\"btiny\",\"blarge\"])`\nevent_order_function = (rng::AbstractRNG,x::DataFrame)->x; # can be used to sort by specifying sort, or shuffling by providing shuffle, or custom functions following the interface (rng,x)->my_shuffle(rng,x)\n\nNumber of trials / rows in generate_events([rng, ]design) depend on the full factorial of your conditions.\n\nTo increase the number of repetitions simply use RepeatDesign(SingleSubjectDesign(...),5)\n\nIf conditions are omitted (or set to nothing), a single trial is simulated with a column :dummy and content :dummy - this is for convenience.\n\nTip: Check the resulting dataframe using the generate_events function.\n\nExamples\n\ndesign = SingleSubjectDesign(;\n    conditions = Dict(\n        :stimulus_type => [\"natural\", \"artificial\"],\n        :contrast_level => range(0, 1, length = 5),\n);\n\nSee also MultiSubjectDesign, RepeatDesign\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.UniformOnset","page":"API / Docstrings","title":"UnfoldSim.UniformOnset","text":"struct UniformOnset <: AbstractOnset\n\nProvide a Uniform Distribution of the inter-event-distances. width  is the width of the uniform distribution (=> the jitter). Since the lower bound is 0, width is also the upper bound. offset is the minimal distance. The maximal distance is offset + width.\n\n\n\n\n\n","category":"type"},{"location":"api/#UnfoldSim.WhiteNoise","page":"API / Docstrings","title":"UnfoldSim.WhiteNoise","text":"WhiteNoise <: WhiteNoise\nnoiselevel = 1\nimfilter = 0\n\nGenerate White Noise using randn - thus Gaussian noise. noiselevel is used to scale the noise\n\nUsing imfilter > 0 it is possible to smooth the noise using Image.imfilter.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.size-Tuple{MultiSubjectDesign}","page":"API / Docstrings","title":"Base.size","text":"Returns dimension of experiment design\n\n\n\n\n\n","category":"method"},{"location":"api/#DSP.Windows.hanning-Tuple{Any, Any, Any}","page":"API / Docstrings","title":"DSP.Windows.hanning","text":"generate a hanning window\n\nduration: in s offset: in s, defines hanning peak sfreq: sampling rate in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.PuRF-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.PuRF","text":"PuRF()\n\nDefault generator for PuRF Pupil Response Function.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.add_noise!-Tuple{Any, AbstractNoise, Any}","page":"API / Docstrings","title":"UnfoldSim.add_noise!","text":"add_noise!(rng, noisetype::AbstractNoise, signal)\n\nGenerate and add noise to a data matrix. Assumes that the signal can be linearized, that is, that the noise is stationary\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.add_responses!-Tuple{Any, Vector, Vararg{Any, 4}}","page":"API / Docstrings","title":"UnfoldSim.add_responses!","text":"add_responses!(signal, responses::Vector, e, s, tvec, erpvec)\nadd_responses!(signal, responses::Matrix, e, s, tvec, erpvec)\nadd_responses!(signal, responses::AbstractArray, e, s, tvec, erpvec)\n\nHelper function to add inplace the responses to the signal, but for both 2D (1 channel) and 3D (X channel case).\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.apply_event_order_function-Tuple{Any, Any, Any}","page":"API / Docstrings","title":"UnfoldSim.apply_event_order_function","text":"apply_event_order_function(fun::Function, rng::AbstractRNG, events::DataFrame)\n\napply fun(rng,events), raise an error if function is wrongly defined. Convenience function to not repeat the error handling at multiple places.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{AbstractVector{<:AbstractVector}, Any}","page":"API / Docstrings","title":"UnfoldSim.closest_src","text":"closest_src(coords_list::AbstractVector{<:AbstractVector}, pos)\nclosest_src(coords::Vector{<:Real}, pos)\n\nTakes an array of 'm' target coordinate vector (size 3) (or vector of vectors) and a matrix (n-by-3) of all available positions, and returns an array of size 'm' containing the indices of the respective items in 'pos' that are nearest to each of the target coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.closest_src-Tuple{Hartmut, String}","page":"API / Docstrings","title":"UnfoldSim.closest_src","text":"closest_src(head::Hartmut,label::String)\n\nReturns src-ix of the Headmodel Hartmut which is closest to the average of the label.\n\nimportant: Important\nWe use the average in eucledean space, but the cortex is a curved surface. In most cases they will not overlap. Ideally we would calculate the average on the surface, but this is a bit more complex to do (you'd need to calculate the vertices etc.)\n\nhartmut = Hartmut()\npos = closest_src(hartmut=>\"Left Middle Temporal Gyrus, posterior division\")\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.convert-Tuple{Random.AbstractRNG, Vararg{Any, 4}}","page":"API / Docstrings","title":"UnfoldSim.convert","text":"Obsolete - # TODO: Transfer function to Unfold.jl\n\nFunction to convert output similar to unfold (data, events)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.create_continuous_signal-Tuple{Any, Any, Any}","page":"API / Docstrings","title":"UnfoldSim.create_continuous_signal","text":"create_continuous_signal(rng, responses, simulation)\n\nBased on the responses and simulation parameters, simulate onset latencies and add together a continuous signal.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.epoch-Tuple{AbstractVector, Vararg{Any}}","page":"API / Docstrings","title":"UnfoldSim.epoch","text":"epoch(data::AbstractVector, args...; kwargs...)\nepoch(\n    data::AbstractArray{T,2},\n    events,\n    τ::Tuple{Number,Number},\n    sfreq;\n    eventtime::Symbol = :latency,\n) where {T<:Union{Missing,Number}}\n\nHelper function to epoch data.\n\nAdapted from Unfold.jl: https://github.com/unfoldtoolbox/Unfold.jl/blob/b3a21c2bb7e93d2f45ec64b0197f4663a6d7939a/src/utilities.jl#L40\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, MultiSubjectDesign}","page":"API / Docstrings","title":"UnfoldSim.generate_events","text":"generate_events([rng::AbstractRNG, ]design::MultiSubjectDesign)\n\nGenerate full factorial Dataframe according to MixedModelsSim.jl 's simdat_crossed function.\n\nNote: n_items = you can think of it as trials or better, as stimuli. Note: No condition can be named dv which is used internally in MixedModelsSim / MixedModels as a dummy left-side Afterwards applies design.event_order_function. Could be used to duplicate trials, sort, subselect etc. Finally it sorts by :subject\n\nd = MultiSubjectDesign(; n_subjects = 10, n_items = 20, both_within = Dict(:A => nlevels(5),:B => nlevels(2)))\ngenerate_events(d)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, RepeatDesign}","page":"API / Docstrings","title":"UnfoldSim.generate_events","text":"UnfoldSim.generate_events([rng::AbstractRNG, ]design::RepeatDesign{T})\n\nIn a repeated design, iteratively calls the underlying {T} design and concatenates. In case of MultiSubjectDesign, sorts by subject.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.generate_events-Tuple{Random.AbstractRNG, SingleSubjectDesign}","page":"API / Docstrings","title":"UnfoldSim.generate_events","text":"generate_events([rng::AbstractRNG, ]design::SingleSubjectDesign)\n\nGenerates full-factorial DataFrame of design.conditions\n\nAfterwards applies design.event_order_function. If conditions is nothing, a single trial is simulated with a column :dummy and content :dummy - this is for convenience.\n\njulia> d = SingleSubjectDesign(;conditions= Dict(:A=>nlevels(5),:B=>nlevels(2))) julia> generate_events(d)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hartmut_citation-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.hartmut_citation","text":"Returns citation-string for HArtMuT\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.hrf-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.hrf","text":"Generate a HRF kernel. \n\nTR = 1/sfreq default parameters taken from SPM\n\nCode adapted from Unfold.jl\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.leadfield-Tuple{Hartmut}","page":"API / Docstrings","title":"UnfoldSim.leadfield","text":"Returns the leadfield\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Tuple{AbstractHeadmodel}","page":"API / Docstrings","title":"UnfoldSim.magnitude","text":"Extracts magnitude of the orientation-including leadfield.\n\nBy default uses the orientation specified in the headmodel\n\nFallback: along the third dimension using norm - the maximal projection\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Tuple{Hartmut}","page":"API / Docstrings","title":"UnfoldSim.magnitude","text":"magnitude(headmodel::Hartmut; type = \"perpendicular\") = Extract magnitude of 3-orientation-leadfield,  type (default: \"perpendicular\") => uses the provided source-point orientations - otherwise falls back to norm.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T<:Real","page":"API / Docstrings","title":"UnfoldSim.magnitude","text":"magnitude(lf::AbstractArray{T,3}) where {T<:Real}\n\nIf orientation is not specified, returns the maximal magnitude (norm of leadfield).\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.magnitude-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractMatrix{T}}} where T<:Real","page":"API / Docstrings","title":"UnfoldSim.magnitude","text":"magnitude(lf::AbstractArray{T,3}, orientation::AbstractArray{T,2}) where {T<:Real}\n\nReturn the magnitude along an orientation of the leadfield.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.maxlength-Tuple{Vector{<:AbstractComponent}}","page":"API / Docstrings","title":"UnfoldSim.maxlength","text":"maxlength(c::Vector{<:AbstractComponent}) = maximum(length.(c))\n\nmaximum of individual component lengths\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n170-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.n170","text":"n170(;sfreq=100)\n\nGenerator for Hanning window, negative (!) peak at 170ms, width 150ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n400-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.n400","text":"n400(;sfreq=100)\n\nGenerator for Hanning window, negative (!) peak at 400ms, width 400ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{AbstractComponent}","page":"API / Docstrings","title":"UnfoldSim.n_channels","text":"n_channels(c::AbstractComponent)\n\nReturn the number of channels. By default = 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{MultichannelComponent}","page":"API / Docstrings","title":"UnfoldSim.n_channels","text":"n_channels(c::MultichannelComponent)\n\nFor MultichannelComponent return the length of the projection vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.n_channels-Tuple{Vector{<:AbstractComponent}}","page":"API / Docstrings","title":"UnfoldSim.n_channels","text":"For a vector of MultichannelComponents, return the first but asserts all are of equal length.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.p100-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.p100","text":"p100(;sfreq=100)\n\nGenerator for Hanning window, peak at 100ms, width 100ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.p300-Tuple{}","page":"API / Docstrings","title":"UnfoldSim.p300","text":"p300(;sfreq=100)\n\nGenerator for Hanning window, peak at 300ms, width 300ms, at kwargs sfreq (default 100). Returns a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.pad_array-Tuple{Vector, Tuple, Any}","page":"API / Docstrings","title":"UnfoldSim.pad_array","text":"Pads array with specified value, length pad_array(arr, len, val)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_2x2-Tuple{Random.AbstractRNG}","page":"API / Docstrings","title":"UnfoldSim.predef_2x2","text":"predef_2x2(rng::AbstractRNG; kwargs...)\n\nThe most used kwargs is: return_epoched = true which returns already epoched data. If you want epoched data without overlap, specify onset = NoOnset() and return_epoched = true\n\nDesign\n\nn_items = 100,\nn_subjects = 1,\nconditions = Dict(:A => [\"a_small\",\"a_big\"], :B => [\"b_tiny\",\"b_large\"]),\nevent_order_function = shuffle,\n\nComponent / Signal\n\nsignalsize = 100, # Length of simulated hanning window\nbasis = hanning(signalsize), # The actual \"function\", signalsize is only used here\nβ = [1, -0.5, .5, +1], # The parameters\nσs = Dict(:subject => [1, 0.5, 0.5, 0.5],:item => [1]), # Only in n_subjects >= 2 case, specifies the random effects\ncontrasts = Dict(:A => EffectsCoding(), :B => EffectsCoding()) # Effect coding by default\nformula = n_subjects == 1 ? @formula(0 ~ 1 + A*B) : @formula(dv ~ 1 + A*B + (A*B|subject) + (1|item)),\n\nOnset\n\noverlap = (0.5,0.2),\nonset = UniformOnset(; offset = signalsize * overlap[1], width = signalsize * overlap[2]), # Put offset to 1 for no overlap. put width to 0 for no jitter\n\nNoise\n\nnoiselevel = 0.2,\nnoise = PinkNoise(; noiselevel = noiselevel),\n\nBe careful if you modify nitems with nsubjects = 1, n_items has to be a multiple of 4 (or your equivalent conditions factorial, e.g. all combinations length)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.predef_eeg-Tuple{Any}","page":"API / Docstrings","title":"UnfoldSim.predef_eeg","text":"predef_eeg(; kwargs...)\npredef_eeg(rng; kwargs...)\npredef_eeg(rng, n_subjects; kwargs...)\n\nGenerate a P1/N1/P3 complex. In case n_subjects is defined - MixedModelComponents are generated, else LinearModelComponents.\n\nThe most used kwargs is: return_epoched=true which returns already epoched data. If you want epoched data without overlap, specify onset = NoOnset() and return_epoched = true\n\nDefault parameters:\n\nDesign\n\nn_repeats = 100,\nevent_order_function = shuffle, # random trial order\nconditions = Dict(...),\n\nComponent / Signal\n\nsfreq = 100,\np1 = (p100(; sfreq = sfreq), @formula(0 ~ 1), [5], Dict()), # P1 amp 5, no effects\nn1 = (n170(; sfreq = sfreq), @formula(0 ~ 1 + condition), [5,-3], Dict()), # N1 amp 5, dummy-coded condition effect (levels \"car\", \"face\") of -3\np3 = (p300(; sfreq = sfreq), @formula(0 ~ 1 + continuous), [5,1], Dict()), # P3 amp 5, continuous effect range [-5,5] with slope 1\n\nOnset\n\noverlap = (0.5,0.2), # offset + width/length of Uniform noise. put offset to 1 for no overlap. put width to 0 for no jitter\nonset = UniformOnset(; offset = sfreq * 0.5 * overlap[1], width = sfreq * 0.5 * overlap[2]), \n\nNoise\n\nnoiselevel = 0.2,\nnoise = PinkNoise(; noiselevel = noiselevel),\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate","page":"API / Docstrings","title":"UnfoldSim.simulate","text":"simulate(\n[rng::AbstractRNG,]\ndesign::AbstractDesign,\nsignal,\nonset::AbstractOnset,\nnoise::AbstractNoise = NoNoise();\nreturn_epoched=false,\n)\n\nMain simulation function, given Design, [Array of] Component, Onset and optional [Noise], returns continuous or epoched signal.\n\noptional\n\nreturn_epoched (Bool, default: false):  Skip the Onset-calculation and conversion to continuous data and return the epoched data directly (see also remarks below).\n\nReturn\n\nDepending on the design, the components and on return_epoched, the output can be a 1-D, 2-D, 3-D or 4-D Array. For example, a 4-D Array would have the dimensions channels x time x trials x subjects\n\nNotes\n\nSome remarks to how the noise is added:\n\nIf return_epoched = true and onset =NoOnset() the noise is added to the epoched data matrix\nIf onset is not NoOnset, a continuous signal is created and the noise is added to this i.e. this means that the noise won't be the same as in the onset = NoOnset() case even if return_epoched = true.\nThe case return_epoched = false and onset = NoOnset() is not possible and therefore covered by an assert statement\n\n\n\n\n\n","category":"function"},{"location":"api/#UnfoldSim.simulate_and_add!-Tuple{AbstractMatrix, Any, Any, Any}","page":"API / Docstrings","title":"UnfoldSim.simulate_and_add!","text":"simulate_and_add!(epoch_data::AbstractMatrix, c, simulation, rng)\nsimulate_and_add!(epoch_data::AbstractArray, c, simulation, rng)\n\nHelper function to call simulate_component and add it to a provided Array.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, AbstractComponent, Simulation}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::AbstractComponent, simulation::Simulation)\n\nBy default call simulate_component with (::Abstractcomponent,::AbstractDesign) instead of the whole simulation. This allows users to provide a hook to do something completely different :)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, LinearModelComponent, AbstractDesign}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::AbstractComponent, simulation::Simulation)\n\nGenerate a linear model design matrix, weight it by c.β and multiply the result with the given basis vector.\n\njulia> c = UnfoldSim.LinearModelComponent([0,1,1,0],@formula(0~1+cond),[1,2],Dict()) julia> design = MultiSubjectDesign(;nsubjects=2,nitems=50,itemsbetween=(;:cond=>[\"A\",\"B\"])) julia> simulatecomponent(StableRNG(1),c,design)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, MixedModelComponent, AbstractDesign}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng, c::MixedModelComponent, design::AbstractDesign)\n\nGenerates a MixedModel and simulates data according to c.β and c.σs.\n\nA trick is used to remove the Normal-Noise from the MixedModel which might lead to rare numerical instabilities. Practically, we upscale the σs by factor 10000, and provide a σ=0.0001. Internally this results in a normalization where the response scale is 10000 times larger than the noise.\n\nCurrently, it is not possible to use a different basis for fixed and random effects, but a code-stub exists (it is slow though).\n\nreturn_parameters (Bool,false) - can be used to return the per-event parameters used to weight the basis function. Sometimes useful to see what is simulated\n\njulia> design = MultiSubjectDesign(;nsubjects=2,nitems=50,items_between=(;:cond=>[\"A\",\"B\"])) julia> c = UnfoldSim.MixedModelComponent([0.,1,1,0],@formula(0~1+cond+(1|subject)),[1,2],Dict(:subject=>[2],),Dict()) julia> simulate(StableRNG(1),c,design)\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_component-Tuple{Any, MultichannelComponent, AbstractDesign}","page":"API / Docstrings","title":"UnfoldSim.simulate_component","text":"simulate_component(rng,c::MultichannelComponent,design::AbstractDesign)\n\nReturn the projection of a component from source to \"sensor\" space.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_noise-Tuple{Any, NoNoise, Int64}","page":"API / Docstrings","title":"UnfoldSim.simulate_noise","text":"simulate_noise(rng, t::NoNoise, n::Int)\n\nReturn zeros instead of noise.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_noise-Tuple{Any, Union{PinkNoise, RedNoise}, Int64}","page":"API / Docstrings","title":"UnfoldSim.simulate_noise","text":"simulate_noise(rng, t::Union{PinkNoise,RedNoise}, n::Int)\n\nGenerate Pink or Red Noise using the SignalAnalysis.jl implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_onsets-Tuple{Any, AbstractOnset, Simulation}","page":"API / Docstrings","title":"UnfoldSim.simulate_onsets","text":"simulate_onsets(rng, onset::AbstractOnset, simulation::Simulation)\n\nCall simulate_interonset_distances to generate distances between events and then add them up to generate the actual latencies in samples.\n\nmain call from simulation\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.simulate_responses-Tuple{Any, Vector{<:AbstractComponent}, Simulation}","page":"API / Docstrings","title":"UnfoldSim.simulate_responses","text":"simulate_responses(\n    rng,\n    components::Vector{<:AbstractComponent},\n    simulation::Simulation)\n\nSimulate multiple component responses and accumulates them on a per-event basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnfoldSim.weight_σs-Tuple{Dict, Float64, Float64}","page":"API / Docstrings","title":"UnfoldSim.weight_σs","text":"Weights a σs Dict for MixedModels.jl by a Float64\n\nFinally sales it by σ_lmm, as a trick to simulate noise-free LMMs\n\nI anticipate a function     function weight_σs(σs::Dict,b_σs::Dict,σ_lmm::Float64) where each σs entry can be weighted individually\n\n\n\n\n\n","category":"method"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"EditURL = \"../../../literate/reference/noisetypes.jl\"","category":"page"},{"location":"generated/reference/noisetypes/#Overview:-Noise-types","page":"Overview: Noise types","title":"Overview: Noise types","text":"","category":"section"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"There are different types of noise signals which differ in their power spectra. If you are not familiar with different types/colors of noise yet, have a look at thecolors of noise Wikipedia page.","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"There are several noise types directly implemented in UnfoldSim.jl. Here is a comparison:","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"using UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs\nimport StatsBase.autocor\n\nf = Figure()\nax_sig =\n    f[1, 1:3] =\n        Axis(f; title = \"1.000 samples of noise\", xlabel = \"Time\", ylabel = \"Amplitude\")\nax_spec =\n    f[2, 1:2] = Axis(\n        f;\n        title = \"Welch Periodogram\",\n        xlabel = \"Normalized frequency\",\n        ylabel = \"log(Power)\",\n    )\nax_auto =\n    f[2, 3:4] = Axis(\n        f;\n        title = \"Autocorrelogram (every 10th lag)\",\n        xlabel = \"Lag\",\n        ylabel = \"Autocorrelation\",\n    )\nfor n in [PinkNoise RedNoise WhiteNoise NoNoise ExponentialNoise]\n\n    # generate\n    noisevec = simulate_noise(StableRNG(1), n(), 10000)\n\n    # plot 1000 samples\n    lines!(ax_sig, noisevec[1:1000]; label = string(n))\n\n    # calc spectrum\n    perio = welch_pgram(noisevec)\n\n    # plot spectrum\n    lines!(ax_spec, freq(perio), log10.(power(perio)))\n\n    lags = 0:10:500\n    autocor_vec = autocor(noisevec, lags)\n    lines!(ax_auto, lags, autocor_vec)\n\nend\nf[1, 4] = Legend(f, ax_sig, \"Noise type\", tellheight = true)\nf","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"hint: Hint\nWe recommed for smaller signals the ExponentialNoise, maybe with a removed DC offset or a HighPass filter. For long signals, this Noise requires lots of memory though. maybe Pinknoise is a better choice then.","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"","category":"page"},{"location":"generated/reference/noisetypes/","page":"Overview: Noise types","title":"Overview: Noise types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"EditURL = \"../../../literate/reference/basistypes.jl\"","category":"page"},{"location":"generated/reference/basistypes/#Overview:-Basis-function-(component)-types","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"There are several basis types directly implemented. They can be easily used for the components.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"note: Note\nYou can use any arbitrary shape defined by yourself! We often make use of hanning(50) from the DSP.jl package.","category":"page"},{"location":"generated/reference/basistypes/#Setup","page":"Overview: Basis function (component) types","title":"Setup","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"# Load required packages\nusing UnfoldSim\nusing CairoMakie\nusing DSP\nusing StableRNGs","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"</details >","category":"page"},{"location":"generated/reference/basistypes/#EEG","page":"Overview: Basis function (component) types","title":"EEG","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"By default, the EEG bases assume a sampling rate of 100, which can easily be changed by e.g. p100(; sfreq=300)","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"f = Figure()\nax = f[1, 1] = Axis(f)\nfor b in [p100, n170, p300, n400]\n    lines!(ax, b(), label = string(b))\n    scatter!(ax, b(), label = string(b))\nend\naxislegend(ax, merge = true)\nf","category":"page"},{"location":"generated/reference/basistypes/#fMRI","page":"Overview: Basis function (component) types","title":"fMRI","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"default hrf TR is 1. Get to know all your favourite shapes!","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"##--\nf = Figure()\nplotConfig = (\n    :peak => 1:3:10,\n    :post_undershoot => 10:5:30,\n    :amplitude => 2:5,\n    :shift => 0:3:10,\n    :peak_width => 0.1:0.5:1.5,\n    :post_undershoot_width => 0.1:0.5:1.5,\n)\n\nfor (ix, pl) in enumerate(plotConfig)\n    col = (ix - 1) % 3 + 1\n    row = Int(ceil(ix / 3))\n\n    ax = f[row, col] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.hrf(; TR = 0.1, (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/#Pupil","page":"Overview: Basis function (component) types","title":"Pupil","text":"","category":"section"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"We use the simplified PuRF from Hoeks & Levelt, 1993. Note that https://www.science.org/doi/10.1126/sciadv.abi9979 show some evidence in their supplementary material, that the convolution model is not fully applicable.","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"f = Figure()\nplotConfig = (:n => 5:3:15, :tmax => 0.5:0.2:1.1)\n\nfor (ix, pl) in enumerate(plotConfig)\n    ax = f[1, ix] = Axis(f)\n    cfg = collect(pl)\n    for k in cfg[2]\n        lines!(ax, UnfoldSim.PuRF(; (cfg[1] => k,)...), label = string(k))\n    end\n\n    axislegend(string(cfg[1]); merge = true)\nend\nf","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"","category":"page"},{"location":"generated/reference/basistypes/","page":"Overview: Basis function (component) types","title":"Overview: Basis function (component) types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"EditURL = \"../../../literate/tutorials/poweranalysis.jl\"","category":"page"},{"location":"generated/tutorials/poweranalysis/#Power-analysis","page":"Power analysis","title":"Power analysis","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"For a power analysis, we will repeatedly simulate data, and check whether we can find a significant effect. We perform the power analysis on epoched data.","category":"page"},{"location":"generated/tutorials/poweranalysis/#Setup","page":"Power analysis","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"# Load required packages\nusing UnfoldSim\nusing Statistics\nusing HypothesisTests\nusing DataFrames\nusing Random","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"</details >\n<br />","category":"page"},{"location":"generated/tutorials/poweranalysis/#Simulation-loop","page":"Power analysis","title":"Simulation loop","text":"","category":"section"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"pvals = fill(NaN, 100)\n@time for seed in eachindex(pvals)\n    # Simulate data of 30 subjects\n    data, evts = UnfoldSim.predef_2x2(\n        MersenneTwister(seed);\n        n_subjects = 20, ## 30 subjects\n        overlap = (1, 0), ## deactivate overlap\n        noiselevel = 10,  ## add more noise to make it more challenging\n        return_epoched = true, ## saves us the epoching step\n    )\n\n\n    # take the mean over a pre-specified timewindow\n    evts.y = dropdims(mean(data[40:60, :, :], dims = 1), dims = (1))[:]\n\n    # extract the two levels of condition A\n    evts_reduced = combine(groupby(evts, [:subject, :A]), :y => mean)\n    y_big = evts_reduced[evts_reduced.A.==\"a_big\", :y_mean]\n    y_small = evts_reduced[evts_reduced.A.==\"a_small\", :y_mean]\n\n    # calculate a one-sided t-test\n    pvals[seed] = pvalue(OneSampleTTest(y_big, y_small))\nend","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"Let's calculate the power","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"power = mean(pvals .< 0.05) * 100","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"","category":"page"},{"location":"generated/tutorials/poweranalysis/","page":"Power analysis","title":"Power analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"EditURL = \"../../../literate/reference/designtypes.jl\"","category":"page"},{"location":"generated/reference/designtypes/#Overview:-Experimental-design-types","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The experimental design specifies the experimental conditions and other variables that are supposed to have an influence on the simulated data. Currently, there are three types of designs implemented: SingleSubjectDesign, MultiSubjectDesign and RepeatDesign.","category":"page"},{"location":"generated/reference/designtypes/#Setup","page":"Overview: Experimental design types","title":"Setup","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"# Load required packages\nusing UnfoldSim\nusing Random","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >","category":"page"},{"location":"generated/reference/designtypes/#Single-subject-designs","page":"Overview: Experimental design types","title":"Single-subject designs","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"As the name suggests, the SingleSubjectDesign type can be used to specify the experimental design for a single subject. Using the conditions arguments, the user can specify all relevant conditions or predictors and their levels or value range.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The current implementation assumes a full factorial design (also called fully crossed design) in which each level of a factor occurs with each level of the other factors. Moreover, in the current implementation, there is exactly one instance of each of these factor combinations.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"Example:","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_single = SingleSubjectDesign(;\n    conditions = Dict(\n        :stimulus_type => [\"natural\", \"artificial\"],\n        :contrast_level => range(0, 1, length = 3),\n    ),\n);\nnothing #hide","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"In order to inspect the design, we can use the generate_events function to create an event table based on the design we specified.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_single)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"To change the order of the trials e.g. to sort or shuffle them, one can use the event_order_function argument. Example: Randomize the order of trials","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_single_shuffled = SingleSubjectDesign(;\n    conditions = Dict(\n        :stimulus_type => [\"natural\", \"artificial\"],\n        :contrast_level => range(0, 1, length = 3),\n    ),\n    event_order_function = shuffle,\n);\nnothing #hide","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand event table </summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_single_shuffled)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >","category":"page"},{"location":"generated/reference/designtypes/#Multi-subject-designs","page":"Overview: Experimental design types","title":"Multi-subject designs","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The MultiSubjectDesign type can be used to simulate data for an experiment with multiple subjects. Internally, it uses the MixedModelsSim.jl package. One needs to specify the number of subjects n_subjects and the number of items n_items i.e. stimuli. In addition, one needs to decide for every experimental factor whether it should be between- or within-subject (and item).","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"note: Note\nFor factors that are not listed in items_between it is assumed that they vary within-item (accordingly for subjects_between).","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_multi = MultiSubjectDesign(\n    n_subjects = 6,\n    n_items = 4,\n    items_between = Dict(:colour => [\"red\", \"blue\"]),\n    subjects_between = Dict(:age_group => [\"young\", \"old\"]),\n    both_within = Dict(:luminance => range(0, 1, length = 3)),\n);\nnothing #hide","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand event table </summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_multi)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >\n<br />","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"As with the SingleSubjectDesign one can use the event_order_function argument to determine the order of events/trials.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"important: Important\nThe number of subjects/items has to be a divisor of the number of factor level combinations, i.e. it is assumed that the design is balanced which means that there is an equal number of observations for all possible factor level combinations.","category":"page"},{"location":"generated/reference/designtypes/#Repeat-designs","page":"Overview: Experimental design types","title":"Repeat designs","text":"","category":"section"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"The RepeatDesign type is a functionality to encapsulate single- or multi-subject designs. It allows to repeat a generated event table multiple times. In other words, the RepeatDesign type allows to have multiple instances of the same item/subject/factor level combination.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"Example: Assume, we have the following single-subject design from above:","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"<details>\n<summary>Click to expand event table </summary>","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"generate_events(design_single)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"</details >\n<br />","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"But instead of having only one instance of the factor combinations e.g. stimulus_type: natural and contrast_level: 0, we will repeat the design three times such that there are three occurrences of each combination.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"design_repeated = RepeatDesign(design_single, 3);\ngenerate_events(design_repeated)","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"Here one can find another example of how to repeat design entries for multi-subject designs.","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"","category":"page"},{"location":"generated/reference/designtypes/","page":"Overview: Experimental design types","title":"Overview: Experimental design types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"EditURL = \"../../../literate/reference/onsettypes.jl\"","category":"page"},{"location":"generated/reference/onsettypes/#Overview:-Onset-types","page":"Overview: Onset types","title":"Overview: Onset types","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The onset types determine the distances between event onsets in the continuous EEG signal. The distances are sampled from a certain probability distribution. Currently, there are two types of onset distributions implemented: UniformOnset and LogNormalOnset.","category":"page"},{"location":"generated/reference/onsettypes/#Setup","page":"Overview: Onset types","title":"Setup","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"# Load required packages\nusing UnfoldSim\nusing CairoMakie\nusing Random\n\n# Define a simple design and repeat it 10000.\n# This will result in 20000 events i.e. event onsets.\ndesign =\n    SingleSubjectDesign(conditions = Dict(:cond => [\"A\", \"B\"])) |>\n    x -> RepeatDesign(x, 10000);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#UniformOnset","page":"Overview: Onset types","title":"UniformOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The UniformOnset is based on a uniform distribution and has two parameters: width and offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"onset_uniform = UniformOnset(; width = 50, offset = 0);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The width parameter defines the upper bound of the interval of the uniform distribution (its lower bound is 0) i.e. all values between 0 and width are equally probable.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the uniform distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let # hide\n    f = Figure() # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((50, 0), (80, 0)), \"width\"), # hide\n        (((50, 0), (50, 20)), \"offset\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for width and one for offset # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (width, offset) in combinations # hide\n            distances = UnfoldSim.simulate_interonset_distances( # hide\n                MersenneTwister(42), # hide\n                UniformOnset(; width = width, offset = offset), # hide\n                design, # hide\n            ) # hide\n\n            hist!( # hide\n                ax, # hide\n                distances, # hide\n                bins = range(0, 100, step = 1), # hide\n                label = \"($width, $offset)\", # hide\n            ) # hide\n\n            if label == \"offset\" && offset != 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let\n    f = Figure()\n\n    # Define parameter combinations\n    parameters = [(((50, 0), (80, 0)), \"width\"), (((50, 0), (50, 20)), \"offset\")]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for width and one for offset\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (width, offset) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                UniformOnset(; width = width, offset = offset),\n                design,\n            )\n\n            hist!(ax, onsets, bins = range(0, 100, step = 1), label = \"($width, $offset)\")\n\n            if label == \"offset\" && offset != 0\n                vlines!(offset, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#LogNormalOnset","page":"Overview: Onset types","title":"LogNormalOnset","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The LogNormalOnset is based on a log-normal distribution and has four parameters: μ, σ, offset and truncate_upper.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"Example:","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"onset_lognormal = LogNormalOnset(; μ = 3, σ = 0.25, offset = 0, truncate_upper = nothing);\nnothing #hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The parameters μ and σ are the location and scale parameter of the log-normal distribution. However, they are not identical to its mean and standard deviation. If a variable X is log-normally distributed then Y = ln(X) is normally distributed with mean μ and standard deviation σ[1].","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The offset parameter determines the minimal distance between two events and its value is added to the value sampled from the log-normal distribution i.e. it shifts the distribution. Its default value is 0, i.e. no offset.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"The truncate_upper parameter allows to truncate the distribution at a certain sample value. Its default value is nothing, i.e. no truncation.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"In the figure below, it is illustrated how the onset distribution changes when changing one of its parameters.","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let # hide\n    f = Figure(size = (600, 800)) # hide\n\n    # Define parameter combinations # hide\n    parameters = [ # hide\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"), # hide\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"), # hide\n    ] # hide\n\n    axes_list = Array{Any}(undef, length(parameters)) # hide\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc # hide\n    for (index, (combinations, label)) in enumerate(parameters) # hide\n        ax = Axis(f[index, 1], title = \"Parameter: $label\") # hide\n        axes_list[index] = ax # hide\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets # hide\n        for (μ, σ, offset, truncate_upper) in combinations # hide\n            onsets = UnfoldSim.simulate_interonset_distances( # hide\n                MersenneTwister(42), # hide\n                LogNormalOnset(; # hide\n                    μ = μ, # hide\n                    σ = σ, # hide\n                    offset = offset, # hide\n                    truncate_upper = truncate_upper, # hide\n                ), # hide\n                design, # hide\n            ) # hide\n\n            hist!( # hide\n                ax, # hide\n                onsets, # hide\n                bins = range(0, 100, step = 1), # hide\n                label = \"($μ,$σ,$offset,$truncate_upper)\", # hide\n            ) # hide\n\n            if label == \"offset\" && offset !== 0 # hide\n                vlines!(offset, color = \"black\") # hide\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing # hide\n                vlines!(truncate_upper, color = \"black\") # hide\n            end # hide\n        end # hide\n        hideydecorations!(ax) # hide\n        hidespines!(ax, :t, :r) # hide\n        axislegend( # hide\n            ax, # hide\n            framevisible = false, # hide\n            labelsize = 12, # hide\n            markersize = 5, # hide\n            patchsize = (10, 10), # hide\n        ) # hide\n    end # hide\n    axes_list[end].xlabel = \"Time between events [samples]\" # hide\n    linkyaxes!(axes_list...) # hide\n    current_figure() # hide\nend # hide\n\n\n# Note: The code is repeated because I did not manage to show the figure but make the code collapsible # hide","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"<details>\n<summary>Click to show the code for the figure above</summary>","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"let\n    f = Figure(size = (600, 800))\n\n    # Define parameter combinations\n    parameters = [\n        (((3, 0.25, 0, nothing), (2.5, 0.25, 0, nothing)), \"μ\"),\n        (((3, 0.25, 0, nothing), (3, 0.35, 0, nothing)), \"σ\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 30, nothing)), \"offset\"),\n        (((3, 0.25, 0, nothing), (3, 0.25, 0, 25)), \"truncate_upper\"),\n    ]\n\n    axes_list = Array{Any}(undef, length(parameters))\n\n    # Create a subplot for each parameter i.e. one for μ, one for σ etc\n    for (index, (combinations, label)) in enumerate(parameters)\n        ax = Axis(f[index, 1], title = \"Parameter: $label\")\n        axes_list[index] = ax\n\n        # Go through all parameter combinations and plot a histogram of the sampled onsets\n        for (μ, σ, offset, truncate_upper) in combinations\n            onsets = UnfoldSim.simulate_interonset_distances(\n                MersenneTwister(42),\n                LogNormalOnset(;\n                    μ = μ,\n                    σ = σ,\n                    offset = offset,\n                    truncate_upper = truncate_upper,\n                ),\n                design,\n            )\n\n            hist!(\n                ax,\n                onsets,\n                bins = range(0, 100, step = 1),\n                label = \"($μ,$σ,$offset,$truncate_upper)\",\n            )\n\n            if label == \"offset\" && offset !== 0\n                vlines!(offset, color = \"black\")\n            elseif label == \"truncate_upper\" && truncate_upper !== nothing\n                vlines!(truncate_upper, color = \"black\")\n            end\n        end\n        hideydecorations!(ax)\n        hidespines!(ax, :t, :r)\n        axislegend(\n            ax,\n            framevisible = false,\n            labelsize = 12,\n            markersize = 5,\n            patchsize = (10, 10),\n        )\n    end\n    axes_list[end].xlabel = \"Time between events [samples]\"\n    linkyaxes!(axes_list...)\nend","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"</details >","category":"page"},{"location":"generated/reference/onsettypes/#Overlap-of-subsequent-events","page":"Overview: Onset types","title":"Overlap of subsequent events","text":"","category":"section"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"note: Note\nThe overlap of subsequent events can be indirectly controlled by setting the offset parameter relative to the length of the component basis.   Assuming that signal is a component e.g. LinearModelComponent,if offset > length(signal.basis) -> no overlap\nif offset < length(signal.basis) -> there might be overlap, depending on the other parameters of the onset distribution","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"[1]: Wikipedia contributors. (2023, December 5). Log-normal distribution. In Wikipedia, The Free Encyclopedia. Retrieved 12:27, December 7, 2023, from https://en.wikipedia.org/w/index.php?title=Log-normal_distribution&oldid=1188400077#","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"","category":"page"},{"location":"generated/reference/onsettypes/","page":"Overview: Onset types","title":"Overview: Onset types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"EditURL = \"../../../literate/reference/overview.jl\"","category":"page"},{"location":"generated/reference/overview/#Overview-of-functionality","page":"Overview of functionality","title":"Overview of functionality","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"A UnfoldSim simulation has four ingredients: Design, Component, Onset and Noise. Here we provide a short overview of the implemented types.","category":"page"},{"location":"generated/reference/overview/#Setup","page":"Overview of functionality","title":"Setup","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"# Load required packages\nusing UnfoldSim\nusing InteractiveUtils","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"</details>","category":"page"},{"location":"generated/reference/overview/#Design","page":"Overview of functionality","title":"Design","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Designs define the experimental design. They can be nested, e.g. RepeatDesign(SingleSubjectDesign,10) would repeat the generated design-dataframe 10x.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractDesign)","category":"page"},{"location":"generated/reference/overview/#Component","page":"Overview of functionality","title":"Component","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Components define a signal. Some components can be nested, e.g. LinearModelComponent|>MultichannelComponent, see the multi-channel tutorial for more information.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractComponent)","category":"page"},{"location":"generated/reference/overview/#Onsets","page":"Overview of functionality","title":"Onsets","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Onsets define the distance between events in the continuous signal.","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractOnset)","category":"page"},{"location":"generated/reference/overview/#Noise","page":"Overview of functionality","title":"Noise","text":"","category":"section"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"Choose the noise you need!","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"subtypes(AbstractNoise)","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"","category":"page"},{"location":"generated/reference/overview/","page":"Overview of functionality","title":"Overview of functionality","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"EditURL = \"../../../literate/tutorials/quickstart.jl\"","category":"page"},{"location":"generated/tutorials/quickstart/#Quickstart","page":"Quickstart","title":"Quickstart","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"To get started with data simulation, the user needs to provide four ingredients:","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"an experimental design, defining which conditions and how many events/\"trials\" exist\nan event basis function, defining the simulated event-related response for every event (e.g. the ERP shape in EEG)\nan inter-onset event distribution, defining the distances in time of the event sequence\na noise specification, defining the type of noise signal that is added to the simulated signal (e.g. pink noise)","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"tip: Tip\nUse subtypes(AbstractNoise) (or subtypes(AbstractComponent) etc.) to find already implemented building blocks.","category":"page"},{"location":"generated/tutorials/quickstart/#Specify-the-simulation-ingredients","page":"Quickstart","title":"Specify the simulation ingredients","text":"","category":"section"},{"location":"generated/tutorials/quickstart/#Setup","page":"Quickstart","title":"Setup","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"# Load required packages\nusing UnfoldSim\nusing Random # to get an RNG\nusing CairoMakie # for plotting","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"</details >","category":"page"},{"location":"generated/tutorials/quickstart/#Experimental-Design","page":"Quickstart","title":"Experimental Design","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a 1 x 2 design with 20 trials. That is, one condition (cond_A) with two levels.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"design =\n    SingleSubjectDesign(; conditions = Dict(:cond_A => [\"level_A\", \"level_B\"])) |>\n    x -> RepeatDesign(x, 10);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Event-basis-function-(Component)","page":"Quickstart","title":"Event basis function (Component)","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Define a simple component and ground truth simulation formula. Akin to ERP components, we call one simulation signal a component.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"note: Note\nYou could easily specify multiple components by providing a vector of components, which are automatically added at the same onsets. This procedure simplifies to generate some response that is independent of simulated condition, whereas other depends on it.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"signal = LinearModelComponent(;\n    basis = [0, 0, 0, 0.5, 1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + cond_A),\n    β = [1, 0.5],\n);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Onsets-and-Noise","page":"Quickstart","title":"Onsets and Noise","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"We will start with a uniform (but overlapping, offset < length(signal.basis)) inter-onset distribution.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"onset = UniformOnset(; width = 20, offset = 4);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"And we will use some noise","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"noise = PinkNoise(; noiselevel = 0.2);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/#Combine-and-Generate","page":"Quickstart","title":"Combine & Generate","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"Finally, we will combine all ingredients and simulate some data.","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"data, events = simulate(MersenneTwister(1), design, signal, onset, noise);\nnothing #hide","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"data is a n-sample Vector (but could be a Matrix for e.g. MultiSubjectDesign or epoched data).","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"events is a DataFrame that contains a column latency with the onsets of events (in samples).","category":"page"},{"location":"generated/tutorials/quickstart/#Plot-them!","page":"Quickstart","title":"Plot them!","text":"","category":"section"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"lines(data; color = \"black\")\nvlines!(events.latency; color = [\"orange\", \"teal\"][1 .+ (events.cond_A.==\"level_B\")])\n\ncurrent_axis().title = \"Simulated data\"\ncurrent_axis().xlabel = \"Time [samples]\"\ncurrent_axis().ylabel = \"Amplitude [μV]\"\n\ncurrent_figure()","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"","category":"page"},{"location":"generated/tutorials/quickstart/","page":"Quickstart","title":"Quickstart","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"EditURL = \"../../../literate/HowTo/repeatTrials.jl\"","category":"page"},{"location":"generated/HowTo/repeatTrials/#howto_repeat_design","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"","category":"section"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"Sometimes we want to repeat a design, that is, have multiple trials with identical values, but it is not always straight forward to implement. For instance, there is no way to easily modify MultiSubjectDesign to have multiple identical subject/item combinations, without doing awkward repetitions of condition-levels or something.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"If you struggle with this problem RepeatDesign is an easy tool for you:","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"using UnfoldSim\n\ndesignOnce = MultiSubjectDesign(;\n    n_items = 2,\n    n_subjects = 2,\n    subjects_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n    items_between = Dict(:cond => [\"levelA\", \"levelB\"]),\n);\n\ndesign = RepeatDesign(designOnce, 4);\ngenerate_events(design)","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"As you can see, the design was simply repeated.","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"note: Note\nIf you implemented your own AbstractDesign, you need to define the size function accordingly. E.g.:   Base.size(design::RepeatDesign{SingleSubjectDesign}) = size(design.design).*design.repeat","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"","category":"page"},{"location":"generated/HowTo/repeatTrials/","page":"Get multiple trials with identical subject/item combinations","title":"Get multiple trials with identical subject/item combinations","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = UnfoldSim","category":"page"},{"location":"#UnfoldSim.jl","page":"Home","title":"UnfoldSim.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for UnfoldSim.jl: a Julia package for simulating multivariate timeseries data with a special focus on EEG data.","category":"page"},{"location":"#Start-simulating-time-series-data","page":"Home","title":"Start simulating time series data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We offer some predefined (EEG) signals, check them out!","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance a P1/N170/P300 complex (containing three typical ERP components).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using UnfoldSim\nusing CairoMakie # plotting\n\ndata, evts = UnfoldSim.predef_eeg(; n_repeats = 1, noiselevel = 0.8)\n\nlines(data; color = \"black\")\nvlines!(evts.latency; color = [\"orange\", \"teal\"][1 .+ (evts.condition.==\"car\")])\n\ncurrent_figure()","category":"page"},{"location":"#Or-simulate-epoched-data-directly","page":"Home","title":"Or simulate epoched data directly","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"\ndata, evts = UnfoldSim.predef_eeg(; n_repeats = 20, noiselevel = 0.8, return_epoched = true)\nheatmap(data[:, sortperm(evts, [:condition, :continuous])])\n","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"EditURL = \"../../../literate/HowTo/predefinedData.jl\"","category":"page"},{"location":"generated/HowTo/predefinedData/#Use-existing-experimental-designs-and-onsets-in-the-simulation","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Let's say you want to use the events data frame (containing the levels of the experimental variables and the event onsets (latencies)) from a previous study in your simulation.","category":"page"},{"location":"generated/HowTo/predefinedData/#Setup","page":"Use existing experimental designs & onsets in the simulation","title":"Setup","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"<details>\n<summary>Click to expand</summary>","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"# Load required packages\nusing UnfoldSim\nusing DataFrames\nusing Random\nusing CairoMakie # for plotting","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"</details >\n<br />","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"From a previous study, we (somehow, e.g. by using pyMNE.jl) imported an event data frame like this:","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"my_events = DataFrame(:condition => [:A, :B, :B, :A, :A], :latency => [7, 13, 22, 35, 41])","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"To use exactly these values, we can generate a new AbstractDesign, which will always return this event dataframe","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"struct MyManualDesign <: AbstractDesign\n    my_events::Any\nend\nUnfoldSim.generate_events(rng, d::MyManualDesign) = deepcopy(d.my_events) ## generate function which is called internally in UnfoldSim\nUnfoldSim.size(d::MyManualDesign) = size(d.my_events, 1); ## necessary function to tell what the dimensionality of the experimental design is\nnothing #hide","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"note: Note\nNote the UnfoldSim.generate_events which tells Julia to \"overload\" the generate_events function as defined in UnfoldSim.","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Next we generate a MyManualDesign","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"mydesign = MyManualDesign(my_events);\nnothing #hide","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"We could already use this \"solo\" and simulate some data, for example:","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"signal = LinearModelComponent(;\n    basis = [1, 1, 0.5, 0, 0],\n    formula = @formula(0 ~ 1 + condition),\n    β = [1, 0.5],\n);\n\ndata, events =\n    simulate(MersenneTwister(1), mydesign, signal, UniformOnset(; width = 10, offset = 5))\nlines(data) # plotting\nvlines!(my_events.latency; linestyle = :dash)\ncurrent_figure()","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Looks good, but the events don't match our custom onsets yet.","category":"page"},{"location":"generated/HowTo/predefinedData/#Custom-Timings","page":"Use existing experimental designs & onsets in the simulation","title":"Custom Timings","text":"","category":"section"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"Finally, we want to use our custom timings as well. For this we define a new AbstractOnset. Again, it simply returns our manually provided latencies","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"struct MyManualOnset <: AbstractOnset end\nUnfoldSim.simulate_onsets(rng, onset::MyManualOnset, simulation::Simulation) =\n    generate_events(rng, simulation.design).latency","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"hint: Hint\nThis is a bit of a trick, it relies that MyManualOnset is always used in combination with MyManualDesign. You could of course repeat the structure from MyManualDesign also for MyManualOnset and have an explicit field in the structure containing the onsets.","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"And that's it","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"data, events = simulate(MersenneTwister(1), mydesign, signal, MyManualOnset())\nlines(data) # plotting\nvlines!(my_events.latency, linestyle = :dash)\ncurrent_figure()","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"now everything matches, lovely!","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"","category":"page"},{"location":"generated/HowTo/predefinedData/","page":"Use existing experimental designs & onsets in the simulation","title":"Use existing experimental designs & onsets in the simulation","text":"This page was generated using Literate.jl.","category":"page"}]
}
